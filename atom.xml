<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Miraitowa🥑</title>
  
  
  <link href="https://www.cameliia.top/atom.xml" rel="self"/>
  
  <link href="https://www.cameliia.top/"/>
  <updated>2024-01-02T08:00:00.000Z</updated>
  <id>https://www.cameliia.top/</id>
  
  <author>
    <name>Miraitowa🥑</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Egg(二)_Egg项目配置路由，写接口数据</title>
    <link href="https://www.cameliia.top/posts/601.html"/>
    <id>https://www.cameliia.top/posts/601.html</id>
    <published>2024-01-02T08:00:00.000Z</published>
    <updated>2024-01-02T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /># 前言<p><strong>给Egg项目中配置路由，并写入接口，提供数据。</strong></p><p><strong>实现效果：</strong></p><p><img src="https://img-blog.csdnimg.cn/direct/adb8588be5f44ae6a65b1993121c7077.png" alt="在这里插入图片描述"></p><h2 id="一、创建控制器-controller-home-js">一、创建控制器    controller/home.js</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller/home.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Controller</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;egg&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomeController</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Controller</span> &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">index</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx &#125; = <span class="variable language_">this</span>;</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">&#x27;hi, egg&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">list</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; ctx &#125; = <span class="variable language_">this</span>;</span><br><span class="line">  ctx.<span class="property">body</span>=(&#123;</span><br><span class="line">      <span class="attr">code</span>:<span class="number">200</span>,</span><br><span class="line">      <span class="attr">masg</span>:<span class="string">&#x27;查询成功&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>:[</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>,<span class="attr">age</span>:<span class="number">19</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">HomeController</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二、编写路由">二、编写路由</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Egg.Application</span>&#125; <span class="variable">app</span> - egg application</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; router, controller &#125; = app;</span><br><span class="line">  router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, controller.<span class="property">home</span>.<span class="property">index</span>);</span><br><span class="line">  router.<span class="title function_">get</span>(<span class="string">&#x27;/list&#x27;</span>, controller.<span class="property">home</span>.<span class="property">list</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="三、页面上输入：http-localhost-7001-list">三、页面上输入：<a href="http://localhost:7001/list">http://localhost:7001/list</a></h2><p><img src="https://img-blog.csdnimg.cn/direct/187ec0cee14b42a996648bf9baeb7ecd.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">🍠本文汇总Egg项目配置路由，写接口数据 ，可作为文档进行查询</summary>
    
    
    
    <category term="node" scheme="https://www.cameliia.top/categories/node/"/>
    
    
    <category term="Egg" scheme="https://www.cameliia.top/tags/Egg/"/>
    
  </entry>
  
  <entry>
    <title>Egg(四)_Egg使用MySql数据库</title>
    <link href="https://www.cameliia.top/posts/603.html"/>
    <id>https://www.cameliia.top/posts/603.html</id>
    <published>2024-01-02T08:00:00.000Z</published>
    <updated>2024-01-02T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1>前言</h1><p><strong>Egg中配合使用mysql来实现数据的获取和写入，并通过Egg定义的方式发送到接口里面。</strong></p><h2 id="一、项目中安装mysql">一、项目中安装mysql</h2><h3 id="1、安装egg-mysql插件">1、安装egg-mysql插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save egg-mysql</span><br></pre></td></tr></table></figure><h3 id="2、配置插件：打开config-plugin-js">2、配置插件：打开config/plugin.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mysql配置</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mysql</span>: &#123;</span><br><span class="line">    <span class="attr">enable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">package</span>: <span class="string">&#x27;egg-mysql&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3、配置插件：打开config-config-default-js">3、配置插件：打开config/config.default.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据库连接</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">mysql</span> = &#123;</span><br><span class="line">  <span class="comment">// 单数据库信息配置</span></span><br><span class="line">  <span class="attr">client</span>: &#123;</span><br><span class="line">     <span class="comment">// host</span></span><br><span class="line">     <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">     <span class="comment">// 端口号</span></span><br><span class="line">     <span class="attr">port</span>: <span class="string">&#x27;3306&#x27;</span>,</span><br><span class="line">     <span class="comment">// 用户名</span></span><br><span class="line">     <span class="attr">user</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">     <span class="comment">// 密码</span></span><br><span class="line">     <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">     <span class="comment">// 数据库名</span></span><br><span class="line">     <span class="attr">database</span>: <span class="string">&#x27;egg&#x27;</span>,</span><br><span class="line"> &#125;,</span><br><span class="line">  <span class="comment">// 是否加载到 app 上，默认开启</span></span><br><span class="line">  <span class="attr">app</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 是否加载到 agent 上，默认关闭</span></span><br><span class="line">  <span class="attr">agent</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二、Egg-js-操作-MySql-数据库">二、Egg.js 操作 MySql 数据库</h2><h3 id="1、新建一个stu数据库表">1、新建一个stu数据库表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `stu` (  </span><br><span class="line"> `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line"> `name` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,   </span><br><span class="line"> `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`) </span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><h3 id="2、添加路由-router-js">2、添加路由  router.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/getStu&#x27;</span>, controller.<span class="property">stu</span>.<span class="property">getStu</span>);</span><br><span class="line"> router.<span class="title function_">post</span>(<span class="string">&#x27;/addStu&#x27;</span>, controller.<span class="property">stu</span>.<span class="property">addStu</span>);</span><br><span class="line"> router.<span class="title function_">post</span>(<span class="string">&#x27;/updateStu&#x27;</span>, controller.<span class="property">stu</span>.<span class="property">updateStu</span>);</span><br><span class="line"> router.<span class="title function_">post</span>(<span class="string">&#x27;/delStu&#x27;</span>, controller.<span class="property">stu</span>.<span class="property">delStu</span>);</span><br></pre></td></tr></table></figure><h3 id="3、添加学生信息">3、添加学生信息</h3><p>1、打开controller 中的stu.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加学生信息</span></span><br><span class="line"> <span class="keyword">async</span> <span class="title function_">addStu</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> &#123; ctx &#125; = <span class="variable language_">this</span>;</span><br><span class="line">     <span class="keyword">const</span> &#123; name, age &#125; = ctx.<span class="property">request</span>.<span class="property">body</span>;</span><br><span class="line">     <span class="keyword">const</span> result = <span class="keyword">await</span> ctx.<span class="property">service</span>.<span class="property">stu</span>.<span class="title function_">addStu</span>(name, age);</span><br><span class="line">     <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">          <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">          <span class="attr">msg</span>: <span class="string">&#x27;添加成功&#x27;</span>,</span><br><span class="line">          <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">          <span class="attr">status</span>: <span class="number">201</span>,</span><br><span class="line">          <span class="attr">msg</span>: <span class="string">&#x27;添加失败&#x27;</span>,</span><br><span class="line">          <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>2、打开service中的stu.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加学生信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">name</span> -名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">age</span> -年龄</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Object</span>&#125; 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">addStu</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> params = &#123;</span><br><span class="line">       name,</span><br><span class="line">       age,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">app</span>.<span class="property">mysql</span>.<span class="title function_">insert</span>(<span class="string">&#x27;stu&#x27;</span>, params);</span><br><span class="line">    <span class="keyword">const</span> insertSuccess = result.<span class="property">affectedRows</span> === <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (insertSuccess) &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用接口如下图</strong><br><img src="https://img-blog.csdnimg.cn/direct/f24f8aaf91394ae98dd72c95b2058d65.png" alt="在这里插入图片描述"><br>·我们可以在数据库的表中查看到<br><img src="https://img-blog.csdnimg.cn/direct/8d6d2fd5c11447e7b07bc70dbee5e71b.png" alt="在这里插入图片描述"></p><h3 id="4、根据ID查寻学生信息">4、根据ID查寻学生信息</h3><p>1、打开controller 中的stu.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询学生信息</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">getStu</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; ctx &#125; = <span class="variable language_">this</span>;</span><br><span class="line">   <span class="keyword">const</span> &#123; id &#125; = ctx.<span class="property">query</span>;</span><br><span class="line">   <span class="keyword">const</span> result = <span class="keyword">await</span> ctx.<span class="property">service</span>.<span class="property">stu</span>.<span class="title function_">getStu</span>(id);</span><br><span class="line">   ctx.<span class="property">body</span> = &#123;</span><br><span class="line">     <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">     <span class="attr">msg</span>: <span class="string">&#x27;查询成功&#x27;</span>,</span><br><span class="line">     <span class="attr">data</span>: result,</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、打开service中的stu.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 查询学生信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">id</span> -学生ID</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Object</span>&#125; 学生信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="keyword">async</span> <span class="title function_">getStu</span>(<span class="params">id</span>) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> params = &#123;</span><br><span class="line">        id</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">app</span>.<span class="property">mysql</span>.<span class="title function_">get</span>(<span class="string">&#x27;stu&#x27;</span>, params);</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>调用接口如下图</strong><br><img src="https://img-blog.csdnimg.cn/direct/48b5a0630c324803a9858a094776d5ed.png" alt="在这里插入图片描述"></p><h3 id="5、根据ID更新学生信息">5、根据ID更新学生信息</h3><p>1、打开controller 中的stu.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新学生信息</span></span><br><span class="line"> <span class="keyword">async</span> <span class="title function_">updateStu</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; ctx &#125; = <span class="variable language_">this</span>;</span><br><span class="line">   <span class="keyword">const</span> params = ctx.<span class="property">request</span>.<span class="property">body</span>;</span><br><span class="line">   <span class="keyword">const</span> result = <span class="keyword">await</span> ctx.<span class="property">service</span>.<span class="property">stu</span>.<span class="title function_">updateStu</span>(params);</span><br><span class="line">   <span class="keyword">if</span> (result) &#123;</span><br><span class="line">       ctx.<span class="property">body</span> = &#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;更新成功&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: result,</span><br><span class="line">       &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       ctx.<span class="property">body</span> = &#123;</span><br><span class="line">         <span class="attr">status</span>: <span class="number">201</span>,</span><br><span class="line">         <span class="attr">msg</span>: <span class="string">&#x27;更新失败&#x27;</span>,</span><br><span class="line">         <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>2、打开service中的stu.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 更新学生信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; params 学生信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Object</span>&#125; 对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="keyword">async</span> <span class="title function_">updateStu</span>(<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">app</span>.<span class="property">mysql</span>.<span class="title function_">update</span>(<span class="string">&#x27;stu&#x27;</span>, params); </span><br><span class="line">     <span class="keyword">const</span> updateSuccess = result.<span class="property">affectedRows</span> === <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> (updateSuccess) &#123;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>调用接口如下图</strong><br><img src="https://img-blog.csdnimg.cn/direct/8c02efe0cfb7417a95f3a4d5604e58aa.png" alt="在这里插入图片描述"><br>我们可以在数据库的表看到数据已经更新啦<br><img src="https://img-blog.csdnimg.cn/direct/cbba90d3502749caa1328adeb805bc71.png" alt="在这里插入图片描述"></p><h3 id="6、根据ID删除学生信息">6、根据ID删除学生信息</h3><p>1、打开controller 中的stu.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除学生信息</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">delStu</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; ctx &#125; = <span class="variable language_">this</span>;</span><br><span class="line">   <span class="keyword">const</span> &#123; id &#125; = ctx.<span class="property">request</span>.<span class="property">body</span>;</span><br><span class="line">   <span class="keyword">const</span> result = <span class="keyword">await</span> ctx.<span class="property">service</span>.<span class="property">stu</span>.<span class="title function_">delStu</span>(id);</span><br><span class="line">   <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      ctx.<span class="property">body</span> = &#123;</span><br><span class="line">         <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">         <span class="attr">msg</span>: <span class="string">&#x27;删除成功&#x27;</span>,</span><br><span class="line">         <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">     &#125;;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.<span class="property">body</span> = &#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">201</span>,</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;删除失败&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">     &#125;;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>2、打开service中的stu.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除学生信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; id  学生ID</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Object</span>&#125; 对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="keyword">async</span> <span class="title function_">delStu</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">app</span>.<span class="property">mysql</span>.<span class="title function_">delete</span>(<span class="string">&#x27;stu&#x27;</span>, &#123;</span><br><span class="line">          id,</span><br><span class="line">        &#125;);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>调用接口如下图</strong><br><img src="https://img-blog.csdnimg.cn/direct/d68034cb244d4ea0b09fd6a24e41d293.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">🍠本文汇总Egg使用MySql数据库 ，可作为文档进行查询</summary>
    
    
    
    <category term="node" scheme="https://www.cameliia.top/categories/node/"/>
    
    
    <category term="Egg" scheme="https://www.cameliia.top/tags/Egg/"/>
    
  </entry>
  
  <entry>
    <title>Egg(五)_Egg+Mysql实现图片上传</title>
    <link href="https://www.cameliia.top/posts/604.html"/>
    <id>https://www.cameliia.top/posts/604.html</id>
    <published>2024-01-02T08:00:00.000Z</published>
    <updated>2024-01-02T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /># 前言<p><strong>Egg实现图片上传</strong></p><blockquote><ol><li>首先前端调用上传接口，将上传的资源经过 FormData 实例封装之后，传给服务端</li><li>在服务端接收前端传进来的图片信息，通过 fs.readFileSync 方法，来读取图片内容，并存放在变量中</li><li>找个存放图片的公共位置</li><li>通过 fs.writeFileSync 方法，将图片内容写入公共位置</li><li>最后返回图片地址上传到数据库</li></ol></blockquote><hr><h2 id="一、数据库建表">一、数据库建表</h2><h3 id="1-数据库建表，表结构为">1.数据库建表，表结构为</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `img` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `imgurl` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;图片url&#x27;</span>,</span><br><span class="line">  `filename` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;图片名称&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM AUTO_INCREMENT<span class="operator">=</span><span class="number">210</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_unicode_ci;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/direct/00cad9c7e04a45b29067c72d95843bc5.png" alt="在这里插入图片描述"></p><h2 id="二、egg实现图片上传">二、egg实现图片上传</h2><h3 id="1-安装依赖">1.安装依赖</h3><p><code>mkdirp</code> 是一款在 node.js 中像 mkdir -p 一样递归创建目录及其子目录。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g mkdirp</span><br></pre></td></tr></table></figure><p><code>Moment.js</code> 是一个轻量级的 JavaScript 时间库，它方便了日常开发中对时间的操作，提高了开发效率。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install moment</span><br></pre></td></tr></table></figure><h3 id="2-打开-config-config-defalut-js">2.打开 config -&gt; config.defalut.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先引入path</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">//文件存放路径和文件白名单</span></span><br><span class="line">  config.<span class="property">uploadDir</span> = <span class="string">&#x27;app/public/upload&#x27;</span></span><br><span class="line">  config.<span class="property">multipart</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;file&#x27;</span>,</span><br><span class="line">    <span class="attr">fileSize</span>: <span class="number">1048576000</span>,</span><br><span class="line">    <span class="attr">whitelist</span>: [ <span class="string">&#x27;.txt&#x27;</span>, <span class="string">&#x27;.png&#x27;</span>, <span class="string">&#x27;.jpg&#x27;</span> ],</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">// 文件静态路径</span></span><br><span class="line">config.<span class="property">static</span> = &#123;</span><br><span class="line">    <span class="attr">prefix</span>: <span class="string">&#x27;/app/public&#x27;</span>, <span class="comment">//访问前缀</span></span><br><span class="line">    <span class="attr">dir</span>: path.<span class="title function_">join</span>(appInfo.<span class="property">baseDir</span>, <span class="string">&#x27;app/public&#x27;</span>), </span><br><span class="line">    <span class="attr">dynamic</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="attr">preload</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">maxAge</span>: <span class="number">31536000</span>, </span><br><span class="line">    <span class="attr">buffer</span>: <span class="literal">true</span>, </span><br><span class="line"> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-新建controller-upload-js">3.新建controller -&gt; upload.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">&#x27;moment&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> mkdirp = <span class="built_in">require</span>(<span class="string">&#x27;mkdirp&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// const api = require(&#x27;../utils/utils&#x27;).api;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Controller</span> = <span class="built_in">require</span>(<span class="string">&#x27;egg&#x27;</span>).<span class="property">Controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UploadController</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Controller</span> &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">upload</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx &#125; = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">// 需要前往 config/config.default.js 设置 config.multipart 的 mode 属性为 file</span></span><br><span class="line">    <span class="keyword">const</span> file = ctx.<span class="property">request</span>.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 声明存放资源的路径</span></span><br><span class="line">    <span class="keyword">let</span> uploadDir = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> id = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> api = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// ctx.request.files[0] 表示获取第一个文件，若前端上传多个文件则可以遍历这个数组对象</span></span><br><span class="line">      <span class="keyword">const</span> f = fs.<span class="title function_">readFileSync</span>(file.<span class="property">filepath</span>);</span><br><span class="line">      <span class="comment">// 1.获取当前日期</span></span><br><span class="line">      <span class="keyword">const</span> day = <span class="title function_">moment</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">format</span>(<span class="string">&#x27;YYYYMMDD&#x27;</span>);</span><br><span class="line">      <span class="comment">// 2.创建图片保存的路径</span></span><br><span class="line">      <span class="keyword">const</span> dir = path.<span class="title function_">join</span>(<span class="variable language_">this</span>.<span class="property">config</span>.<span class="property">uploadDir</span>, day);</span><br><span class="line">      <span class="keyword">const</span> date = <span class="title class_">Date</span>.<span class="title function_">now</span>(); <span class="comment">// 毫秒数</span></span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">mkdirp</span>(dir); <span class="comment">// 不存在就创建目录</span></span><br><span class="line">      <span class="comment">// 返回图片保存的路径</span></span><br><span class="line">      uploadDir = path.<span class="title function_">join</span>(dir, date + path.<span class="title function_">extname</span>(file.<span class="property">filename</span>));</span><br><span class="line">       api=<span class="string">&quot;http://localhost:7001/&quot;</span></span><br><span class="line">      <span class="comment">// decodeURI是为了中文乱码</span></span><br><span class="line">      id = <span class="keyword">await</span> ctx.<span class="property">service</span>.<span class="property">upload</span>.<span class="title function_">add</span>(&#123; <span class="attr">img_url</span>: api + uploadDir, <span class="attr">filename</span>: file.<span class="property">filename</span> &#125;);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>( id);</span><br><span class="line">      <span class="comment">// 写入文件夹</span></span><br><span class="line">      fs.<span class="title function_">writeFileSync</span>(uploadDir, f);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error&#x27;</span>, e);</span><br><span class="line">      <span class="comment">// 清除临时文件</span></span><br><span class="line">      ctx.<span class="title function_">cleanupRequestFiles</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.<span class="property">body</span> = &#123;</span><br><span class="line">      <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&#x27;上传成功&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>: api + uploadDir,</span><br><span class="line">      id,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">UploadController</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-新建-service-upload-js">4.新建 service -&gt; upload.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Service</span> = <span class="built_in">require</span>(<span class="string">&#x27;egg&#x27;</span>).<span class="property">Service</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UploadService</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Service</span> &#123;</span><br><span class="line">  <span class="comment">// 获取图片</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">query</span>(<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; app &#125; = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> app.<span class="property">mysql</span>.<span class="title function_">get</span>(<span class="string">&#x27;img&#x27;</span>, params);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 增加图片</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">add</span>(<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; app &#125; = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> app.<span class="property">mysql</span>.<span class="title function_">insert</span>(<span class="string">&#x27;img&#x27;</span>, params);</span><br><span class="line">      <span class="keyword">return</span> result.<span class="property">insertId</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">UploadService</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-最后在-router-js-中加入">5.最后在 router.js 中加入</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/api/upload/upload&#x27;</span>,controller.<span class="property">upload</span>.<span class="property">upload</span>; <span class="comment">// 上传图片</span></span><br></pre></td></tr></table></figure><h3 id="6-发送接口请求数据">6.发送接口请求数据</h3><p><img src="https://img-blog.csdnimg.cn/direct/6e4c767068f94404ad83c5e63b9594b2.png" alt="在这里插入图片描述">数据库插入一条数据</p><p><img src="https://img-blog.csdnimg.cn/direct/e681bf2b6f7646228f914babdd5ea8ea.png" alt="在这里插入图片描述"><br>本地查看图片<br><img src="https://img-blog.csdnimg.cn/direct/98016aa675da402f97962c0b74047ea9.png" alt="在这里插入图片描述"></p><blockquote><p>在使用egg的上传图片功能的时候出现的这个报错：<code>Cannot read properties of undefined (reading ‘0‘)</code>  请查看这篇文章：<a href="https://blog.csdn.net/m0_58352785/article/details/135271321?spm=1001.2014.3001.5501">传送口</a></p></blockquote>]]></content>
    
    
    <summary type="html">🍠本文汇总Egg+Mysql实现图片上传，可作为文档进行查询</summary>
    
    
    
    <category term="node" scheme="https://www.cameliia.top/categories/node/"/>
    
    
    <category term="Egg" scheme="https://www.cameliia.top/tags/Egg/"/>
    
  </entry>
  
  <entry>
    <title>Egg(六)_实现列表的模糊查询</title>
    <link href="https://www.cameliia.top/posts/605.html"/>
    <id>https://www.cameliia.top/posts/605.html</id>
    <published>2024-01-02T08:00:00.000Z</published>
    <updated>2024-01-02T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1>前言</h1><p><strong>列表数据系列增删改查的查询实现</strong></p><h2 id="一、实现步骤：">一、实现步骤：</h2><h3 id="1、路由配置：">1、路由配置：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 路由配置</span><br><span class="line"> * @param app</span><br><span class="line"> */</span><br><span class="line">module.exports = app =&gt; &#123;</span><br><span class="line">   const &#123; router, controller &#125; = app;</span><br><span class="line">    //用户信息</span><br><span class="line">    router.get(<span class="string">&#x27;/getUser, controller.user.getUser);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2、controller-user-js-中-写入查询方法-getUser">2、controller  / user.js`中 写入查询方法  getUser</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  用户信息路由</span><br><span class="line"> * @param app</span><br><span class="line"> * @returns &#123;HomeController&#125;</span><br><span class="line"> */</span><br><span class="line">const Controller = require(<span class="string">&#x27;egg&#x27;</span>).Controller;</span><br><span class="line">class UserController extends Controller &#123;</span><br><span class="line">   async <span class="function"><span class="title">getUser</span></span>() &#123;</span><br><span class="line">    //查询库里的user表</span><br><span class="line">    <span class="built_in">let</span> params = this.ctx.query //获取路径后面的参数</span><br><span class="line">    console.log(<span class="string">&#x27;用户的参数：&#x27;</span>);</span><br><span class="line">    console.log(params);</span><br><span class="line">    <span class="built_in">let</span> sql = <span class="string">&#x27;select * from user&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">let</span> content = [];//参数</span><br><span class="line">    <span class="built_in">let</span> isMore = <span class="literal">false</span>;//是否有多个查询参数</span><br><span class="line">    /**</span><br><span class="line">     * @模糊查询-量大的时候效率低</span><br><span class="line">     * <span class="keyword">select</span> * from user <span class="built_in">where</span> name like ? % 内容 %</span><br><span class="line">     * 在user表中全局查找name值 == 内容的</span><br><span class="line">     * % 内容 % 全局查找内容</span><br><span class="line">     *   内容 %  查找以 内容 开头的数据</span><br><span class="line">     * */</span><br><span class="line">    <span class="keyword">if</span>(params.name)&#123;</span><br><span class="line">      sql += <span class="string">&quot; where name like ?&quot;</span>;</span><br><span class="line">      content.push( <span class="string">&quot;%&quot;</span>+params.name+<span class="string">&quot;%&quot;</span> );</span><br><span class="line">      isMore = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(params.phone)&#123;</span><br><span class="line">      <span class="keyword">if</span>(isMore)&#123;//true代表有多个参数</span><br><span class="line">        sql += <span class="string">&quot;and phone LIKE ?&quot;</span>;//and是两个条件都必须满足，or是或的关系</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sql += <span class="string">&quot; WHERE phone LIKE ?&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      content.push( <span class="string">&quot;%&quot;</span>+params.phone+<span class="string">&quot;%&quot;</span> )</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //开启分页</span><br><span class="line">    <span class="keyword">if</span>(params.page || params.pageSize)&#123;</span><br><span class="line">      <span class="built_in">let</span> current = params.page;//当前页码</span><br><span class="line">      <span class="built_in">let</span> pageSize = params.pageSize;//一页展示多少条数据</span><br><span class="line">      sql += <span class="string">&quot; limit ?,?&quot;</span>;</span><br><span class="line">      content.push((current-<span class="number">1</span>)*pageSize,parseInt(pageSize));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">let</span> userList= await this.app.mysql.query(</span><br><span class="line">      sql,content</span><br><span class="line">    );</span><br><span class="line">    this.ctx.body = &#123;</span><br><span class="line">      code:200,</span><br><span class="line">      masg:<span class="string">&#x27;success&#x27;</span>,</span><br><span class="line">      data:userList</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module.exports = UserController;</span><br></pre></td></tr></table></figure><h2 id="二、接口如图所示">二、接口如图所示</h2><h3 id="1、页面输入：http-127-0-0-1-7001-getUser-page-1-pageSize-4">1、页面输入：<a href="http://127.0.0.1:7001/getUser?page=1&amp;pageSize=4">http://127.0.0.1:7001/getUser?page=1&amp;pageSize=4</a></h3><p><img src="https://img-blog.csdnimg.cn/direct/04577c907b86471e896836e450d40020.png" alt="在这里插入图片描述"></p><h3 id="2、页面输入：http-127-0-0-1-7001-getUser-name-张三">2、页面输入：<a href="http://127.0.0.1:7001/getUser?name=%E5%BC%A0%E4%B8%89">http://127.0.0.1:7001/getUser?name=张三</a></h3><p><img src="https://img-blog.csdnimg.cn/direct/a1cfde5c8e4f440090b7bbfbe2ef1b48.png" alt="在这里插入图片描述"></p><h3 id="3、页面输入：http-127-0-0-1-7001-getUser">3、页面输入：<a href="http://127.0.0.1:7001/getUser">http://127.0.0.1:7001/getUser</a></h3><p><img src="https://img-blog.csdnimg.cn/direct/290c35d1784043b0a37703493f8a1372.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">🍠本文汇总Egg实现列表的模糊查询 ，可作为文档进行查询</summary>
    
    
    
    <category term="node" scheme="https://www.cameliia.top/categories/node/"/>
    
    
    <category term="Egg" scheme="https://www.cameliia.top/tags/Egg/"/>
    
  </entry>
  
  <entry>
    <title>Vue3.0笔记</title>
    <link href="https://www.cameliia.top/posts/307.html"/>
    <id>https://www.cameliia.top/posts/307.html</id>
    <published>2023-12-12T08:00:00.000Z</published>
    <updated>2022-03-12T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1. Vue3简介</h1><ul><li><p>2020年9月18日，<code>Vue.js</code>发布版<code>3.0</code>版本，代号：<code>One Piece</code>（n</p></li><li><p>经历了：<a href="https://github.com/vuejs/core/commits/main">4800+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">40+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is%3Apr+is%3Amerged+-author%3Aapp%2Fdependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/core/graphs/contributors">300+贡献者</a></p></li><li><p>官方发版地址：<a href="https://github.com/vuejs/core/releases/tag/v3.0.0">Release v3.0.0 One Piece · vuejs/core</a></p></li><li><p>截止2023年10月，最新的公开版本为：<code>3.3.4</code></p><img src="https://picdemo.cameliia.top/images//1695089947298-161c1b47-eb86-42fb-b1f8-d6a4fcab8ee2.png" alt="image.png" style="zoom:30%;" /> </li></ul><h2 id="1-1-【性能的提升】">1.1. 【性能的提升】</h2><ul><li><p>打包大小减少<code>41%</code>。</p></li><li><p>初次渲染快<code>55%</code>, 更新渲染快<code>133%</code>。</p></li><li><p>内存减少<code>54%</code>。</p></li></ul><h2 id="1-2-【-源码的升级】">1.2.【 源码的升级】</h2><ul><li><p>使用<code>Proxy</code>代替<code>defineProperty</code>实现响应式。</p></li><li><p>重写虚拟<code>DOM</code>的实现和<code>Tree-Shaking</code>。</p></li></ul><h2 id="1-3-【拥抱TypeScript】">1.3. 【拥抱TypeScript】</h2><ul><li><code>Vue3</code>可以更好的支持<code>TypeScript</code>。</li></ul><h2 id="1-4-【新的特性】">1.4. 【新的特性】</h2><ol><li><p><code>Composition API</code>（组合<code>API</code>）：</p><ul><li><p><code>setup</code></p></li><li><p><code>ref</code>与<code>reactive</code></p></li><li><p><code>computed</code>与<code>watch</code></p><p>…</p></li></ul></li><li><p>新的内置组件：</p><ul><li><p><code>Fragment</code></p></li><li><p><code>Teleport</code></p></li><li><p><code>Suspense</code></p><p>…</p></li></ul></li><li><p>其他改变：</p><ul><li><p>新的生命周期钩子</p></li><li><p><code>data</code> 选项应始终被声明为一个函数</p></li><li><p>移除<code>keyCode</code>支持作为<code> v-on</code> 的修饰符</p><p>…</p></li></ul></li></ol><h1>2. 创建Vue3工程</h1><h2 id="2-1-【基于-vue-cli-创建】">2.1. 【基于 vue-cli 创建】</h2><p>点击查看<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">官方文档</a></p><blockquote><p>备注：目前<code>vue-cli</code>已处于维护模式，官方推荐基于 <code>Vite</code> 创建项目。</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span></span><br><span class="line">vue <span class="literal">--version</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装或者升级你的@vue/cli </span></span><br><span class="line">npm install <span class="literal">-g</span> @vue/<span class="built_in">cli</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 执行创建命令</span></span><br><span class="line">vue create vue_test</span><br><span class="line"></span><br><span class="line"><span class="comment">##  随后选择3.x</span></span><br><span class="line"><span class="comment">##  Choose a version of Vue.js that you want to start the project with (Use arrow keys)</span></span><br><span class="line"><span class="comment">##  &gt; 3.x</span></span><br><span class="line"><span class="comment">##    2.x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 启动</span></span><br><span class="line"><span class="built_in">cd</span> vue_test</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><hr><h2 id="2-2-【基于-vite-创建】-推荐">2.2. 【基于 vite 创建】(推荐)</h2><p><code>vite</code> 是新一代前端构建工具，官网地址：<a href="https://vitejs.cn/">https://vitejs.cn</a>，<code>vite</code>的优势如下：</p><ul><li>轻量快速的热重载（<code>HMR</code>），能实现极速的服务启动。</li><li>对 <code>TypeScript</code>、<code>JSX</code>、<code>CSS</code> 等支持开箱即用。</li><li>真正的按需编译，不再等待整个应用编译完成。</li><li><code>webpack</code>构建 与 <code>vite</code>构建对比图如下：<br><img src="https://picdemo.cameliia.top/images/1683167182037-71c78210-8217-4e7d-9a83-e463035efbbe.png" alt="webpack构建" title="webpack构建" style="zoom:20%;box-shadow:0 0 10px black" /><img src="https://picdemo.cameliia.top/images/1683167204081-582dc237-72bc-499e-9589-2cdfd452e62f.png" alt="vite构建" title="vite构建" style="zoom: 20%;box-shadow:0 0 10px black" /></li></ul><ul><li>具体操作如下（点击查看<a href="https://cn.vuejs.org/guide/quick-start.html#creating-a-vue-application">官方文档</a>）</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 1.创建命令</span></span><br><span class="line">npm create vue@latest</span><br><span class="line"></span><br><span class="line"><span class="comment">## 2.具体配置</span></span><br><span class="line"><span class="comment">## 配置项目名称</span></span><br><span class="line">√ Project name: vue3_test</span><br><span class="line"><span class="comment">## 是否添加TypeScript支持</span></span><br><span class="line">√ Add TypeScript?  Yes</span><br><span class="line"><span class="comment">## 是否添加JSX支持</span></span><br><span class="line">√ Add JSX Support?  No</span><br><span class="line"><span class="comment">## 是否添加路由环境</span></span><br><span class="line">√ Add Vue Router <span class="keyword">for</span> Single Page Application development?  No</span><br><span class="line"><span class="comment">## 是否添加pinia环境</span></span><br><span class="line">√ Add Pinia <span class="keyword">for</span> state management?  No</span><br><span class="line"><span class="comment">## 是否添加单元测试</span></span><br><span class="line">√ Add Vitest <span class="keyword">for</span> Unit Testing?  No</span><br><span class="line"><span class="comment">## 是否添加端到端测试方案</span></span><br><span class="line">√ Add an <span class="keyword">End</span><span class="literal">-to-End</span> Testing Solution? » No</span><br><span class="line"><span class="comment">## 是否添加ESLint语法检查</span></span><br><span class="line">√ Add ESLint <span class="keyword">for</span> code quality?  Yes</span><br><span class="line"><span class="comment">## 是否添加Prettiert代码格式化</span></span><br><span class="line">√ Add Prettier <span class="keyword">for</span> code formatting?  No</span><br></pre></td></tr></table></figure><p>自己动手编写一个App组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h1&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name:&#x27;App&#x27; //组件名</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .app &#123;</span><br><span class="line">    background-color: #ddd;</span><br><span class="line">    box-shadow: 0 0 10px;</span><br><span class="line">    border-radius: 10px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>安装官方推荐的<code>vscode</code>插件：</p><img src="https://picdemo.cameliia.top/images/volar.png" alt="Snipaste_2023-10-08_20-46-34" style="zoom:50%;" /> <img src="https://picdemo.cameliia.top/images/image-20231218085906380.png" alt="image-20231218085906380" style="zoom:42%;" /> <p>总结：</p><ul><li><code>Vite</code> 项目中，<code>index.html</code> 是项目的入口文件，在项目最外层。</li><li>加载<code>index.html</code>后，<code>Vite</code> 解析 <code>&lt;script type=&quot;module&quot; src=&quot;xxx&quot;&gt;</code> 指向的<code>JavaScript</code>。</li><li><code>Vue3</code>**中是通过 **<code>createApp</code> 函数创建一个应用实例。</li></ul><h2 id="2-3-【一个简单的效果】">2.3. 【一个简单的效果】</h2><p><code>Vue3</code>向下兼容<code>Vue2</code>语法，且<code>Vue3</code>中的模板中可以没有根标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeAge&quot;&gt;年龄+1&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name:&#x27;App&#x27;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        name:&#x27;张三&#x27;,</span><br><span class="line">        age:18,</span><br><span class="line">        tel:&#x27;13888888888&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      changeName()&#123;</span><br><span class="line">        this.name = &#x27;zhang-san&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      changeAge()&#123;</span><br><span class="line">        this.age += 1</span><br><span class="line">      &#125;,</span><br><span class="line">      showTel()&#123;</span><br><span class="line">        alert(this.tel)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1>3. Vue3核心语法</h1><h2 id="3-1-【OptionsAPI-与-CompositionAPI】">3.1.  【OptionsAPI 与 CompositionAPI】</h2><ul><li><code>Vue2</code>的<code>API</code>设计是<code>Options</code>（配置）风格的。</li><li><code>Vue3</code>的<code>API</code>设计是<code>Composition</code>（组合）风格的。</li></ul><h3 id="Options-API-的弊端">Options API 的弊端</h3><p><code>Options</code>类型的 <code>API</code>，数据、方法、计算属性等，是分散在：<code>data</code>、<code>methods</code>、<code>computed</code>中的，若想新增或者修改一个需求，就需要分别修改：<code>data</code>、<code>methods</code>、<code>computed</code>，不便于维护和复用。</p><p><img src="https://picdemo.cameliia.top/images/1696662197101-55d2b251-f6e5-47f4-b3f1-d8531bbf9279.gif" alt="1.gif" style="zoom:70%;border-radius:20px" /><img src="https://picdemo.cameliia.top/images/1696662200734-1bad8249-d7a2-423e-a3c3-ab4c110628be.gif" alt="2.gif" style="zoom:70%;border-radius:20px" /></p><h3 id="Composition-API-的优势">Composition API 的优势</h3><p>可以用函数的方式，更加优雅的组织代码，让相关功能的代码更加有序的组织在一起。</p><p><img src="https://picdemo.cameliia.top/images/1696662249851-db6403a1-acb5-481a-88e0-e1e34d2ef53a.gif" alt="3.gif" style="height:300px;border-radius:10px"  /><img src="https://picdemo.cameliia.top/images/1696662256560-7239b9f9-a770-43c1-9386-6cc12ef1e9c0.gif" alt="4.gif" style="height:300px;border-radius:10px"  /></p><blockquote><p>说明：以上四张动图原创作者：大帅老猿</p></blockquote><h2 id="3-2-【拉开序幕的-setup】">3.2. 【拉开序幕的 setup】</h2><h3 id="setup-概述">setup 概述</h3><p><code>setup</code>是<code>Vue3</code>中一个新的配置项，值是一个函数，它是 <code>Composition API</code> <strong>“表演的舞台</strong><em><strong>”</strong></em>，组件中所用到的：数据、方法、计算属性、监视…等等，均配置在<code>setup</code>中。</p><p>特点如下：</p><ul><li><code>setup</code>函数返回的对象中的内容，可直接在模板中使用。</li><li><code>setup</code>中访问<code>this</code>是<code>undefined</code>。</li><li><code>setup</code>函数会在<code>beforeCreate</code>之前调用，它是“领先”所有钩子执行的。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeAge&quot;&gt;年龄+1&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name:&#x27;Person&#x27;,</span><br><span class="line">    setup()&#123;</span><br><span class="line">      // 数据，原来写在data中（注意：此时的name、age、tel数据都不是响应式数据）</span><br><span class="line">      let name = &#x27;张三&#x27;</span><br><span class="line">      let age = 18</span><br><span class="line">      let tel = &#x27;13888888888&#x27;</span><br><span class="line"></span><br><span class="line">      // 方法，原来写在methods中</span><br><span class="line">      function changeName()&#123;</span><br><span class="line">        name = &#x27;zhang-san&#x27; //注意：此时这么修改name页面是不变化的</span><br><span class="line">        console.log(name)</span><br><span class="line">      &#125;</span><br><span class="line">      function changeAge()&#123;</span><br><span class="line">        age += 1 //注意：此时这么修改age页面是不变化的</span><br><span class="line">        console.log(age)</span><br><span class="line">      &#125;</span><br><span class="line">      function showTel()&#123;</span><br><span class="line">        alert(tel)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 返回一个对象，对象中的内容，模板中可以直接使用</span><br><span class="line">      return &#123;name,age,tel,changeName,changeAge,showTel&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="setup-的返回值">setup 的返回值</h3><ul><li>若返回一个<strong>对象</strong>：则对象中的：属性、方法等，在模板中均可以直接使用**（重点关注）。**</li><li>若返回一个<strong>函数</strong>：则可以自定义渲染内容，代码如下：</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">()=&gt;</span> <span class="string">&#x27;你好啊！&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="setup-与-Options-API-的关系">setup 与 Options API 的关系</h3><ul><li><code>Vue2</code> 的配置（<code>data</code>、<code>methos</code>…）中<strong>可以访问到</strong> <code>setup</code>中的属性、方法。</li><li>但在<code>setup</code>中<strong>不能访问到</strong><code>Vue2</code>的配置（<code>data</code>、<code>methos</code>…）。</li><li>如果与<code>Vue2</code>冲突，则<code>setup</code>优先。</li></ul><h3 id="setup-语法糖">setup 语法糖</h3><p><code>setup</code>函数有一个语法糖，这个语法糖，可以让我们把<code>setup</code>独立出去，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changAge&quot;&gt;年龄+1&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name:&#x27;Person&#x27;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 下面的写法是setup语法糖 --&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">  console.log(this) //undefined</span><br><span class="line">  </span><br><span class="line">  // 数据（注意：此时的name、age、tel都不是响应式数据）</span><br><span class="line">  let name = &#x27;张三&#x27;</span><br><span class="line">  let age = 18</span><br><span class="line">  let tel = &#x27;13888888888&#x27;</span><br><span class="line"></span><br><span class="line">  // 方法</span><br><span class="line">  function changName()&#123;</span><br><span class="line">    name = &#x27;李四&#x27;//注意：此时这么修改name页面是不变化的</span><br><span class="line">  &#125;</span><br><span class="line">  function changAge()&#123;</span><br><span class="line">    console.log(age)</span><br><span class="line">    age += 1 //注意：此时这么修改age页面是不变化的</span><br><span class="line">  &#125;</span><br><span class="line">  function showTel()&#123;</span><br><span class="line">    alert(tel)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>扩展：上述代码，还需要编写一个不写<code>setup</code>的<code>script</code>标签，去指定组件名字，比较麻烦，我们可以借助<code>vite</code>中的插件简化</p><ol><li>第一步：<code>npm i vite-plugin-vue-setup-extend -D</code></li><li>第二步：<code>vite.config.ts</code></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueSetupExtend</span> <span class="keyword">from</span> <span class="string">&#x27;vite-plugin-vue-setup-extend&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [ <span class="title class_">VueSetupExtend</span>() ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>第三步：<code>&lt;script setup lang=&quot;ts&quot; name=&quot;Person&quot;&gt;</code></li></ol><h2 id="3-3-【ref-创建：基本类型的响应式数据】">3.3. 【ref 创建：基本类型的响应式数据】</h2><ul><li>**作用：**定义响应式变量。</li><li><strong>语法：</strong><code>let xxx = ref(初始值)</code>。</li><li>**返回值：**一个<code>RefImpl</code>的实例对象，简称<code>ref对象</code>或<code>ref</code>，<code>ref</code>对象的<code>value</code><strong>属性是响应式的</strong>。</li><li><strong>注意点：</strong><ul><li><code>JS</code>中操作数据需要：<code>xxx.value</code>，但模板中不需要<code>.value</code>，直接使用即可。</li><li>对于<code>let name = ref('张三')</code>来说，<code>name</code>不是响应式的，<code>name.value</code>是响应式的。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeAge&quot;&gt;年龄+1&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123;ref&#125; from &#x27;vue&#x27;</span><br><span class="line">  // name和age是一个RefImpl的实例对象，简称ref对象，它们的value属性是响应式的。</span><br><span class="line">  let name = ref(&#x27;张三&#x27;)</span><br><span class="line">  let age = ref(18)</span><br><span class="line">  // tel就是一个普通的字符串，不是响应式的</span><br><span class="line">  let tel = &#x27;13888888888&#x27;</span><br><span class="line"></span><br><span class="line">  function changeName()&#123;</span><br><span class="line">    // JS中操作ref对象时候需要.value</span><br><span class="line">    name.value = &#x27;李四&#x27;</span><br><span class="line">    console.log(name.value)</span><br><span class="line"></span><br><span class="line">    // 注意：name不是响应式的，name.value是响应式的，所以如下代码并不会引起页面的更新。</span><br><span class="line">    // name = ref(&#x27;zhang-san&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  function changeAge()&#123;</span><br><span class="line">    // JS中操作ref对象时候需要.value</span><br><span class="line">    age.value += 1 </span><br><span class="line">    console.log(age.value)</span><br><span class="line">  &#125;</span><br><span class="line">  function showTel()&#123;</span><br><span class="line">    alert(tel)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-4-【reactive-创建：对象类型的响应式数据】">3.4. 【reactive 创建：对象类型的响应式数据】</h2><ul><li><strong>作用：<strong>定义一个</strong>响应式对象</strong>（基本类型不要用它，要用<code>ref</code>，否则报错）</li><li><strong>语法：</strong><code>let 响应式对象= reactive(源对象)</code>。</li><li>**返回值：**一个<code>Proxy</code>的实例对象，简称：响应式对象。</li><li><strong>注意点：</strong><code>reactive</code>定义的响应式数据是“深层次”的。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h2&gt;汽车信息：一台&#123;&#123; car.brand &#125;&#125;汽车，价值&#123;&#123; car.price &#125;&#125;万&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;游戏列表：&lt;/h2&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;h2&gt;测试：&#123;&#123;obj.a.b.c.d&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeCarPrice&quot;&gt;修改汽车价格&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeFirstGame&quot;&gt;修改第一游戏&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">import &#123; reactive &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">// 数据</span><br><span class="line">let car = reactive(&#123; brand: &#x27;奔驰&#x27;, price: 100 &#125;)</span><br><span class="line">let games = reactive([</span><br><span class="line">  &#123; id: &#x27;ahsgdyfa01&#x27;, name: &#x27;英雄联盟&#x27; &#125;,</span><br><span class="line">  &#123; id: &#x27;ahsgdyfa02&#x27;, name: &#x27;王者荣耀&#x27; &#125;,</span><br><span class="line">  &#123; id: &#x27;ahsgdyfa03&#x27;, name: &#x27;原神&#x27; &#125;</span><br><span class="line">])</span><br><span class="line">let obj = reactive(&#123;</span><br><span class="line">  a:&#123;</span><br><span class="line">    b:&#123;</span><br><span class="line">      c:&#123;</span><br><span class="line">        d:666</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function changeCarPrice() &#123;</span><br><span class="line">  car.price += 10</span><br><span class="line">&#125;</span><br><span class="line">function changeFirstGame() &#123;</span><br><span class="line">  games[0].name = &#x27;流星蝴蝶剑&#x27;</span><br><span class="line">&#125;</span><br><span class="line">function test()&#123;</span><br><span class="line">  obj.a.b.c.d = 999</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-5-【ref-创建：对象类型的响应式数据】">3.5. 【ref 创建：对象类型的响应式数据】</h2><ul><li>其实<code>ref</code>接收的数据可以是：<strong>基本类型</strong>、<strong>对象类型</strong>。</li><li>若<code>ref</code>接收的是对象类型，内部其实也是调用了<code>reactive</code>函数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h2&gt;汽车信息：一台&#123;&#123; car.brand &#125;&#125;汽车，价值&#123;&#123; car.price &#125;&#125;万&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;游戏列表：&lt;/h2&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;h2&gt;测试：&#123;&#123;obj.a.b.c.d&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeCarPrice&quot;&gt;修改汽车价格&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeFirstGame&quot;&gt;修改第一游戏&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">// 数据</span><br><span class="line">let car = ref(&#123; brand: &#x27;奔驰&#x27;, price: 100 &#125;)</span><br><span class="line">let games = ref([</span><br><span class="line">  &#123; id: &#x27;ahsgdyfa01&#x27;, name: &#x27;英雄联盟&#x27; &#125;,</span><br><span class="line">  &#123; id: &#x27;ahsgdyfa02&#x27;, name: &#x27;王者荣耀&#x27; &#125;,</span><br><span class="line">  &#123; id: &#x27;ahsgdyfa03&#x27;, name: &#x27;原神&#x27; &#125;</span><br><span class="line">])</span><br><span class="line">let obj = ref(&#123;</span><br><span class="line">  a:&#123;</span><br><span class="line">    b:&#123;</span><br><span class="line">      c:&#123;</span><br><span class="line">        d:666</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(car)</span><br><span class="line"></span><br><span class="line">function changeCarPrice() &#123;</span><br><span class="line">  car.value.price += 10</span><br><span class="line">&#125;</span><br><span class="line">function changeFirstGame() &#123;</span><br><span class="line">  games.value[0].name = &#x27;流星蝴蝶剑&#x27;</span><br><span class="line">&#125;</span><br><span class="line">function test()&#123;</span><br><span class="line">  obj.value.a.b.c.d = 999</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-6-【ref-对比-reactive】">3.6. 【ref 对比 reactive】</h2><p>宏观角度看：</p><blockquote><ol><li><p><code>ref</code>用来定义：<strong>基本类型数据</strong>、<strong>对象类型数据</strong>；</p></li><li><p><code>reactive</code>用来定义：<strong>对象类型数据</strong>。</p></li></ol></blockquote><ul><li>区别：</li></ul><blockquote><ol><li><p><code>ref</code>创建的变量必须使用<code>.value</code>（可以使用<code>volar</code>插件自动添加<code>.value</code>）。</p><img src="../../social/images/自动补充value.png" alt="自动补充value" style="zoom:50%;border-radius:20px" /> </li><li><p><code>reactive</code>重新分配一个新对象，会<strong>失去</strong>响应式（可以使用<code>Object.assign</code>去整体替换）。</p></li></ol></blockquote><ul><li>使用原则：</li></ul><blockquote><ol><li>若需要一个基本类型的响应式数据，必须使用<code>ref</code>。</li><li>若需要一个响应式对象，层级不深，<code>ref</code>、<code>reactive</code>都可以。</li><li>若需要一个响应式对象，且层级较深，推荐使用<code>reactive</code>。</li></ol></blockquote><h2 id="3-7-【toRefs-与-toRef】">3.7. 【toRefs 与 toRef】</h2><ul><li>作用：将一个响应式对象中的每一个属性，转换为<code>ref</code>对象。</li><li>备注：<code>toRefs</code>与<code>toRef</code>功能一致，但<code>toRefs</code>可以批量转换。</li><li>语法如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;性别：&#123;&#123;person.gender&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeGender&quot;&gt;修改性别&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123;ref,reactive,toRefs,toRef&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  // 数据</span><br><span class="line">  let person = reactive(&#123;name:&#x27;张三&#x27;, age:18, gender:&#x27;男&#x27;&#125;)</span><br><span class="line"></span><br><span class="line">  // 通过toRefs将person对象中的n个属性批量取出，且依然保持响应式的能力</span><br><span class="line">  let &#123;name,gender&#125; =  toRefs(person)</span><br><span class="line"></span><br><span class="line">  // 通过toRef将person对象中的gender属性取出，且依然保持响应式的能力</span><br><span class="line">  let age = toRef(person,&#x27;age&#x27;)</span><br><span class="line"></span><br><span class="line">  // 方法</span><br><span class="line">  function changeName()&#123;</span><br><span class="line">    name.value += &#x27;~&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeAge()&#123;</span><br><span class="line">    age.value += 1</span><br><span class="line">  &#125;</span><br><span class="line">  function changeGender()&#123;</span><br><span class="line">    gender.value = &#x27;女&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-8-【computed】">3.8. 【computed】</h2><p>作用：根据已有数据计算出新数据（和<code>Vue2</code>中的<code>computed</code>作用一致）。</p><img src="https://picdemo.cameliia.top/images/computed.gif" style="zoom:20%;" />  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br&gt;</span><br><span class="line">    名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br&gt;</span><br><span class="line">    全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br&gt;</span><br><span class="line">    &lt;button @click=&quot;changeFullName&quot;&gt;全名改为：li-si&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;App&quot;&gt;</span><br><span class="line">  import &#123;ref,computed&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  let firstName = ref(&#x27;zhang&#x27;)</span><br><span class="line">  let lastName = ref(&#x27;san&#x27;)</span><br><span class="line"></span><br><span class="line">  // 计算属性——只读取，不修改</span><br><span class="line">  /* let fullName = computed(()=&gt;&#123;</span><br><span class="line">    return firstName.value + &#x27;-&#x27; + lastName.value</span><br><span class="line">  &#125;) */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 计算属性——既读取又修改</span><br><span class="line">  let fullName = computed(&#123;</span><br><span class="line">    // 读取</span><br><span class="line">    get()&#123;</span><br><span class="line">      return firstName.value + &#x27;-&#x27; + lastName.value</span><br><span class="line">    &#125;,</span><br><span class="line">    // 修改</span><br><span class="line">    set(val)&#123;</span><br><span class="line">      console.log(&#x27;有人修改了fullName&#x27;,val)</span><br><span class="line">      firstName.value = val.split(&#x27;-&#x27;)[0]</span><br><span class="line">      lastName.value = val.split(&#x27;-&#x27;)[1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  function changeFullName()&#123;</span><br><span class="line">    fullName.value = &#x27;li-si&#x27;</span><br><span class="line">  &#125; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-9-【watch】">3.9.【watch】</h2><ul><li>作用：监视数据的变化（和<code>Vue2</code>中的<code>watch</code>作用一致）</li><li>特点：<code>Vue3</code>中的<code>watch</code>只能监视以下<strong>四种数据</strong>：</li></ul><blockquote><ol><li><code>ref</code>定义的数据。</li><li><code>reactive</code>定义的数据。</li><li>函数返回一个值（<code>getter</code>函数）。</li><li>一个包含上述内容的数组。</li></ol></blockquote><p>我们在<code>Vue3</code>中使用<code>watch</code>的时候，通常会遇到以下几种情况：</p><h3 id="情况一">* 情况一</h3><p>监视<code>ref</code>定义的【基本类型】数据：直接写数据名即可，监视的是其<code>value</code>值的改变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h1&gt;情况一：监视【ref】定义的【基本类型】数据&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeSum&quot;&gt;点我sum+1&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123;ref,watch&#125; from &#x27;vue&#x27;</span><br><span class="line">  // 数据</span><br><span class="line">  let sum = ref(0)</span><br><span class="line">  // 方法</span><br><span class="line">  function changeSum()&#123;</span><br><span class="line">    sum.value += 1</span><br><span class="line">  &#125;</span><br><span class="line">  // 监视，情况一：监视【ref】定义的【基本类型】数据</span><br><span class="line">  const stopWatch = watch(sum,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;sum变化了&#x27;,newValue,oldValue)</span><br><span class="line">    if(newValue &gt;= 10)&#123;</span><br><span class="line">      stopWatch()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="情况二">* 情况二</h3><p>监视<code>ref</code>定义的【对象类型】数据：直接写数据名，监视的是对象的【地址值】，若想监视对象内部的数据，要手动开启深度监视。</p><blockquote><p>注意：</p><ul><li><p>若修改的是<code>ref</code>定义的对象中的属性，<code>newValue</code> 和 <code>oldValue</code> 都是新值，因为它们是同一个对象。</p></li><li><p>若修改整个<code>ref</code>定义的对象，<code>newValue</code> 是新值， <code>oldValue</code> 是旧值，因为不是同一个对象了。</p></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h1&gt;情况二：监视【ref】定义的【对象类型】数据&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changePerson&quot;&gt;修改整个人&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123;ref,watch&#125; from &#x27;vue&#x27;</span><br><span class="line">  // 数据</span><br><span class="line">  let person = ref(&#123;</span><br><span class="line">    name:&#x27;张三&#x27;,</span><br><span class="line">    age:18</span><br><span class="line">  &#125;)</span><br><span class="line">  // 方法</span><br><span class="line">  function changeName()&#123;</span><br><span class="line">    person.value.name += &#x27;~&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeAge()&#123;</span><br><span class="line">    person.value.age += 1</span><br><span class="line">  &#125;</span><br><span class="line">  function changePerson()&#123;</span><br><span class="line">    person.value = &#123;name:&#x27;李四&#x27;,age:90&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  /* </span><br><span class="line">    监视，情况一：监视【ref】定义的【对象类型】数据，监视的是对象的地址值，若想监视对象内部属性的变化，需要手动开启深度监视</span><br><span class="line">    watch的第一个参数是：被监视的数据</span><br><span class="line">    watch的第二个参数是：监视的回调</span><br><span class="line">    watch的第三个参数是：配置对象（deep、immediate等等.....） </span><br><span class="line">  */</span><br><span class="line">  watch(person,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;person变化了&#x27;,newValue,oldValue)</span><br><span class="line">  &#125;,&#123;deep:true&#125;)</span><br><span class="line">  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="情况三">*  情况三</h3><p>监视<code>reactive</code>定义的【对象类型】数据，且默认开启了深度监视。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h1&gt;情况三：监视【reactive】定义的【对象类型】数据&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changePerson&quot;&gt;修改整个人&lt;/button&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;h2&gt;测试：&#123;&#123;obj.a.b.c&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;test&quot;&gt;修改obj.a.b.c&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123;reactive,watch&#125; from &#x27;vue&#x27;</span><br><span class="line">  // 数据</span><br><span class="line">  let person = reactive(&#123;</span><br><span class="line">    name:&#x27;张三&#x27;,</span><br><span class="line">    age:18</span><br><span class="line">  &#125;)</span><br><span class="line">  let obj = reactive(&#123;</span><br><span class="line">    a:&#123;</span><br><span class="line">      b:&#123;</span><br><span class="line">        c:666</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  // 方法</span><br><span class="line">  function changeName()&#123;</span><br><span class="line">    person.name += &#x27;~&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeAge()&#123;</span><br><span class="line">    person.age += 1</span><br><span class="line">  &#125;</span><br><span class="line">  function changePerson()&#123;</span><br><span class="line">    Object.assign(person,&#123;name:&#x27;李四&#x27;,age:80&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  function test()&#123;</span><br><span class="line">    obj.a.b.c = 888</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 监视，情况三：监视【reactive】定义的【对象类型】数据，且默认是开启深度监视的</span><br><span class="line">  watch(person,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;person变化了&#x27;,newValue,oldValue)</span><br><span class="line">  &#125;)</span><br><span class="line">  watch(obj,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;Obj变化了&#x27;,newValue,oldValue)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="情况四">* 情况四</h3><p>监视<code>ref</code>或<code>reactive</code>定义的【对象类型】数据中的<strong>某个属性</strong>，注意点如下：</p><ol><li>若该属性值<strong>不是</strong>【对象类型】，需要写成函数形式。</li><li>若该属性值是<strong>依然</strong>是【对象类型】，可直接编，也可写成函数，建议写成函数。</li></ol><p>结论：监视的要是对象里的属性，那么最好写函数式，注意点：若是对象监视的是地址值，需要关注对象内部，需要手动开启深度监视。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h1&gt;情况四：监视【ref】或【reactive】定义的【对象类型】数据中的某个属性&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;汽车：&#123;&#123; person.car.c1 &#125;&#125;、&#123;&#123; person.car.c2 &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeC1&quot;&gt;修改第一台车&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeC2&quot;&gt;修改第二台车&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeCar&quot;&gt;修改整个车&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123;reactive,watch&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  // 数据</span><br><span class="line">  let person = reactive(&#123;</span><br><span class="line">    name:&#x27;张三&#x27;,</span><br><span class="line">    age:18,</span><br><span class="line">    car:&#123;</span><br><span class="line">      c1:&#x27;奔驰&#x27;,</span><br><span class="line">      c2:&#x27;宝马&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  // 方法</span><br><span class="line">  function changeName()&#123;</span><br><span class="line">    person.name += &#x27;~&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeAge()&#123;</span><br><span class="line">    person.age += 1</span><br><span class="line">  &#125;</span><br><span class="line">  function changeC1()&#123;</span><br><span class="line">    person.car.c1 = &#x27;奥迪&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeC2()&#123;</span><br><span class="line">    person.car.c2 = &#x27;大众&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeCar()&#123;</span><br><span class="line">    person.car = &#123;c1:&#x27;雅迪&#x27;,c2:&#x27;爱玛&#x27;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 监视，情况四：监视响应式对象中的某个属性，且该属性是基本类型的，要写成函数式</span><br><span class="line">  /* watch(()=&gt; person.name,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;person.name变化了&#x27;,newValue,oldValue)</span><br><span class="line">  &#125;) */</span><br><span class="line"></span><br><span class="line">  // 监视，情况四：监视响应式对象中的某个属性，且该属性是对象类型的，可以直接写，也能写函数，更推荐写函数</span><br><span class="line">  watch(()=&gt;person.car,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;person.car变化了&#x27;,newValue,oldValue)</span><br><span class="line">  &#125;,&#123;deep:true&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="情况五">* 情况五</h3><p>监视上述的多个数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h1&gt;情况五：监视上述的多个数据&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;汽车：&#123;&#123; person.car.c1 &#125;&#125;、&#123;&#123; person.car.c2 &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeC1&quot;&gt;修改第一台车&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeC2&quot;&gt;修改第二台车&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeCar&quot;&gt;修改整个车&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123;reactive,watch&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  // 数据</span><br><span class="line">  let person = reactive(&#123;</span><br><span class="line">    name:&#x27;张三&#x27;,</span><br><span class="line">    age:18,</span><br><span class="line">    car:&#123;</span><br><span class="line">      c1:&#x27;奔驰&#x27;,</span><br><span class="line">      c2:&#x27;宝马&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  // 方法</span><br><span class="line">  function changeName()&#123;</span><br><span class="line">    person.name += &#x27;~&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeAge()&#123;</span><br><span class="line">    person.age += 1</span><br><span class="line">  &#125;</span><br><span class="line">  function changeC1()&#123;</span><br><span class="line">    person.car.c1 = &#x27;奥迪&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeC2()&#123;</span><br><span class="line">    person.car.c2 = &#x27;大众&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeCar()&#123;</span><br><span class="line">    person.car = &#123;c1:&#x27;雅迪&#x27;,c2:&#x27;爱玛&#x27;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 监视，情况五：监视上述的多个数据</span><br><span class="line">  watch([()=&gt;person.name,person.car],(newValue,oldValue)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;person.car变化了&#x27;,newValue,oldValue)</span><br><span class="line">  &#125;,&#123;deep:true&#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-10-【watchEffect】">3.10. 【watchEffect】</h2><ul><li><p>官网：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行该函数。</p></li><li><p><code>watch</code>对比<code>watchEffect</code></p><blockquote><ol><li><p>都能监听响应式数据的变化，不同的是监听数据变化的方式不同</p></li><li><p><code>watch</code>：要明确指出监视的数据</p></li><li><p><code>watchEffect</code>：不用明确指出监视的数据（函数中用到哪些属性，那就监视哪些属性）。</p></li></ol></blockquote></li><li><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h1&gt;需求：水温达到50℃，或水位达到20cm，则联系服务器&lt;/h1&gt;</span><br><span class="line">    &lt;h2 id=&quot;demo&quot;&gt;水温：&#123;&#123;temp&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;水位：&#123;&#123;height&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changePrice&quot;&gt;水温+1&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeSum&quot;&gt;水位+10&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123;ref,watch,watchEffect&#125; from &#x27;vue&#x27;</span><br><span class="line">  // 数据</span><br><span class="line">  let temp = ref(0)</span><br><span class="line">  let height = ref(0)</span><br><span class="line"></span><br><span class="line">  // 方法</span><br><span class="line">  function changePrice()&#123;</span><br><span class="line">    temp.value += 10</span><br><span class="line">  &#125;</span><br><span class="line">  function changeSum()&#123;</span><br><span class="line">    height.value += 1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 用watch实现，需要明确的指出要监视：temp、height</span><br><span class="line">  watch([temp,height],(value)=&gt;&#123;</span><br><span class="line">    // 从value中获取最新的temp值、height值</span><br><span class="line">    const [newTemp,newHeight] = value</span><br><span class="line">    // 室温达到50℃，或水位达到20cm，立刻联系服务器</span><br><span class="line">    if(newTemp &gt;= 50 || newHeight &gt;= 20)&#123;</span><br><span class="line">      console.log(&#x27;联系服务器&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // 用watchEffect实现，不用</span><br><span class="line">  const stopWtach = watchEffect(()=&gt;&#123;</span><br><span class="line">    // 室温达到50℃，或水位达到20cm，立刻联系服务器</span><br><span class="line">    if(temp.value &gt;= 50 || height.value &gt;= 20)&#123;</span><br><span class="line">      console.log(document.getElementById(&#x27;demo&#x27;)?.innerText)</span><br><span class="line">      console.log(&#x27;联系服务器&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 水温达到100，或水位达到50，取消监视</span><br><span class="line">    if(temp.value === 100 || height.value === 50)&#123;</span><br><span class="line">      console.log(&#x27;清理了&#x27;)</span><br><span class="line">      stopWtach()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-11-【标签的-ref-属性】">3.11. 【标签的 ref 属性】</h2><p>作用：用于注册模板引用。</p><blockquote><ul><li><p>用在普通<code>DOM</code>标签上，获取的是<code>DOM</code>节点。</p></li><li><p>用在组件标签上，获取的是组件实例对象。</p></li></ul></blockquote><p>用在普通<code>DOM</code>标签上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h1 ref=&quot;title1&quot;&gt;尚硅谷&lt;/h1&gt;</span><br><span class="line">    &lt;h2 ref=&quot;title2&quot;&gt;前端&lt;/h2&gt;</span><br><span class="line">    &lt;h3 ref=&quot;title3&quot;&gt;Vue&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; ref=&quot;inpt&quot;&gt; &lt;br&gt;&lt;br&gt;</span><br><span class="line">    &lt;button @click=&quot;showLog&quot;&gt;点我打印内容&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123;ref&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  let title1 = ref()</span><br><span class="line">  let title2 = ref()</span><br><span class="line">  let title3 = ref()</span><br><span class="line"></span><br><span class="line">  function showLog()&#123;</span><br><span class="line">    // 通过id获取元素</span><br><span class="line">    const t1 = document.getElementById(&#x27;title1&#x27;)</span><br><span class="line">    // 打印内容</span><br><span class="line">    console.log((t1 as HTMLElement).innerText)</span><br><span class="line">    console.log((&lt;HTMLElement&gt;t1).innerText)</span><br><span class="line">    console.log(t1?.innerText)</span><br><span class="line">    </span><br><span class="line">/************************************/</span><br><span class="line"></span><br><span class="line">    // 通过ref获取元素</span><br><span class="line">    console.log(title1.value)</span><br><span class="line">    console.log(title2.value)</span><br><span class="line">    console.log(title3.value)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>用在组件标签上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件App.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Person ref=&quot;ren&quot;/&gt;</span><br><span class="line">  &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;</span><br><span class="line">  import Person from &#x27;./components/Person.vue&#x27;</span><br><span class="line">  import &#123;ref&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  let ren = ref()</span><br><span class="line"></span><br><span class="line">  function test()&#123;</span><br><span class="line">    console.log(ren.value.name)</span><br><span class="line">    console.log(ren.value.age)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 子组件Person.vue中要使用defineExpose暴露内容 --&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123;ref,defineExpose&#125; from &#x27;vue&#x27;</span><br><span class="line">// 数据</span><br><span class="line">  let name = ref(&#x27;张三&#x27;)</span><br><span class="line">  let age = ref(18)</span><br><span class="line">  /****************************/</span><br><span class="line">  /****************************/</span><br><span class="line">  // 使用defineExpose将组件中的数据交给外部</span><br><span class="line">  defineExpose(&#123;name,age&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-12-【props】">3.12. 【props】</h2><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 定义一个接口，限制每个Person对象的格式</span></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">PersonInter</span> &#123;</span><br><span class="line"> <span class="attr">id</span>:string,</span><br><span class="line"> <span class="attr">name</span>:string,</span><br><span class="line">    <span class="attr">age</span>:number</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 定义一个自定义类型Persons</span></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">Persons</span> = <span class="title class_">Array</span>&lt;<span class="title class_">PersonInter</span>&gt;</span><br></pre></td></tr></table></figure><p><code>App.vue</code>中代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;template&gt;</span><br><span class="line">&lt;Person :list=&quot;persons&quot;/&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">  </span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;</span><br><span class="line">  import Person from &#x27;./components/Person.vue&#x27;</span><br><span class="line">  import &#123;reactive&#125; from &#x27;vue&#x27;</span><br><span class="line">    import &#123;type Persons&#125; from &#x27;./types&#x27;</span><br><span class="line">  </span><br><span class="line">    let persons = reactive&lt;Persons&gt;([</span><br><span class="line">     &#123;id:&#x27;e98219e12&#x27;,name:&#x27;张三&#x27;,age:18&#125;,</span><br><span class="line">      &#123;id:&#x27;e98219e13&#x27;,name:&#x27;李四&#x27;,age:19&#125;,</span><br><span class="line">       &#123;id:&#x27;e98219e14&#x27;,name:&#x27;王五&#x27;,age:20&#125;</span><br><span class="line">     ])</span><br><span class="line">   &lt;/script&gt;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p><code>Person.vue</code>中代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;person&quot;&gt;</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line">     &lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">        &#123;&#123;item.name&#125;&#125;--&#123;&#123;item.age&#125;&#125;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">   &lt;/template&gt;</span><br><span class="line">  </span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">import &#123;defineProps&#125; from &#x27;vue&#x27;</span><br><span class="line">import &#123;type PersonInter&#125; from &#x27;@/types&#x27;</span><br><span class="line">  </span><br><span class="line">  // 第一种写法：仅接收</span><br><span class="line">// const props = defineProps([&#x27;list&#x27;])</span><br><span class="line">  </span><br><span class="line">  // 第二种写法：接收+限制类型</span><br><span class="line">// defineProps&lt;&#123;list:Persons&#125;&gt;()</span><br><span class="line">  </span><br><span class="line">  // 第三种写法：接收+限制类型+指定默认值+限制必要性</span><br><span class="line">let props = withDefaults(defineProps&lt;&#123;list?:Persons&#125;&gt;(),&#123;</span><br><span class="line">     list:()=&gt;[&#123;id:&#x27;asdasg01&#x27;,name:&#x27;小猪佩奇&#x27;,age:18&#125;]</span><br><span class="line">  &#125;)</span><br><span class="line">   console.log(props)</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="3-13-【生命周期】">3.13. 【生命周期】</h2><ul><li><p>概念：<code>Vue</code>组件实例在创建时要经历一系列的初始化步骤，在此过程中<code>Vue</code>会在合适的时机，调用特定的函数，从而让开发者有机会在特定阶段运行自己的代码，这些特定的函数统称为：生命周期钩子</p></li><li><p>规律：</p><blockquote><p>生命周期整体分为四个阶段，分别是：<strong>创建、挂载、更新、销毁</strong>，每个阶段都有两个钩子，一前一后。</p></blockquote></li><li><p><code>Vue2</code>的生命周期</p><blockquote><p>创建阶段：<code>beforeCreate</code>、<code>created</code></p><p>挂载阶段：<code>beforeMount</code>、<code>mounted</code></p><p>更新阶段：<code>beforeUpdate</code>、<code>updated</code></p><p>销毁阶段：<code>beforeDestroy</code>、<code>destroyed</code></p></blockquote></li><li><p><code>Vue3</code>的生命周期</p><blockquote><p>创建阶段：<code>setup</code></p><p>挂载阶段：<code>onBeforeMount</code>、<code>onMounted</code></p><p>更新阶段：<code>onBeforeUpdate</code>、<code>onUpdated</code></p><p>卸载阶段：<code>onBeforeUnmount</code>、<code>onUnmounted</code></p></blockquote></li><li><p>常用的钩子：<code>onMounted</code>(挂载完毕)、<code>onUpdated</code>(更新完毕)、<code>onBeforeUnmount</code>(卸载之前)</p></li><li><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h2&gt;当前求和为：&#123;&#123; sum &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeSum&quot;&gt;点我sum+1&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- vue3写法 --&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123; </span><br><span class="line">    ref, </span><br><span class="line">    onBeforeMount, </span><br><span class="line">    onMounted, </span><br><span class="line">    onBeforeUpdate, </span><br><span class="line">    onUpdated, </span><br><span class="line">    onBeforeUnmount, </span><br><span class="line">    onUnmounted </span><br><span class="line">  &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  // 数据</span><br><span class="line">  let sum = ref(0)</span><br><span class="line">  // 方法</span><br><span class="line">  function changeSum() &#123;</span><br><span class="line">    sum.value += 1</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&#x27;setup&#x27;)</span><br><span class="line">  // 生命周期钩子</span><br><span class="line">  onBeforeMount(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;挂载之前&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  onMounted(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;挂载完毕&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  onBeforeUpdate(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;更新之前&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  onUpdated(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;更新完毕&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  onBeforeUnmount(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;卸载之前&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  onUnmounted(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;卸载完毕&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-14-【自定义hook】">3.14. 【自定义hook】</h2><ul><li><p>什么是<code>hook</code>？—— 本质是一个函数，把<code>setup</code>函数中使用的<code>Composition API</code>进行了封装，类似于<code>vue2.x</code>中的<code>mixin</code>。</p></li><li><p>自定义<code>hook</code>的优势：复用代码, 让<code>setup</code>中的逻辑更清楚易懂。</p></li></ul><p>示例代码：</p><ul><li><p><code>useSum.ts</code>中内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ref,onMounted&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    sum.<span class="property">value</span> += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    sum.<span class="property">value</span> -= <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">increment</span>()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向外部暴露数据</span></span><br><span class="line">  <span class="keyword">return</span> &#123;sum,increment,decrement&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>useDog.ts</code>中内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reactive,onMounted&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios,&#123;<span class="title class_">AxiosError</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> dogList = reactive&lt;string[]&gt;([])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getDog</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 发请求</span></span><br><span class="line">      <span class="keyword">let</span> &#123;data&#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;https://dog.ceo/api/breed/pembroke/images/random&#x27;</span>)</span><br><span class="line">      <span class="comment">// 维护数据</span></span><br><span class="line">      dogList.<span class="title function_">push</span>(data.<span class="property">message</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// 处理错误</span></span><br><span class="line">      <span class="keyword">const</span> err = &lt;<span class="title class_">AxiosError</span>&gt;error</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 挂载钩子</span></span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">getDog</span>()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向外部暴露数据</span></span><br><span class="line">  <span class="keyword">return</span> &#123;dogList,getDog&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>组件中具体使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;button @click=&quot;increment&quot;&gt;点我+1&lt;/button&gt;</span><br><span class="line">  &lt;button @click=&quot;decrement&quot;&gt;点我-1&lt;/button&gt;</span><br><span class="line">  &lt;hr&gt;</span><br><span class="line">  &lt;img v-for=&quot;(u,index) in dogList.urlList&quot; :key=&quot;index&quot; :src=&quot;(u as string)&quot;&gt; </span><br><span class="line">  &lt;span v-show=&quot;dogList.isLoading&quot;&gt;加载中......&lt;/span&gt;&lt;br&gt;</span><br><span class="line">  &lt;button @click=&quot;getDog&quot;&gt;再来一只狗&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">  import &#123;defineComponent&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  export default defineComponent(&#123;</span><br><span class="line">    name:&#x27;App&#x27;,</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">  import useSum from &#x27;./hooks/useSum&#x27;</span><br><span class="line">  import useDog from &#x27;./hooks/useDog&#x27;</span><br><span class="line"></span><br><span class="line">  let &#123;sum,increment,decrement&#125; = useSum()</span><br><span class="line">  let &#123;dogList,getDog&#125; = useDog()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><hr><h1>4. 路由</h1><h2 id="4-1-【对路由的理解】">4.1. 【对路由的理解】</h2><img src="../../social/images/image-20231018144351536.png" alt="image-20231018144351536" style="zoom:20%;border-radius:40px" /> <h2 id="4-2-【基本切换效果】">4.2. 【基本切换效果】</h2><ul><li><p><code>Vue3</code>中要使用<code>vue-router</code>的最新版本，目前是<code>4</code>版本。</p></li><li><p>路由配置文件代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createRouter,createWebHistory&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;@/pages/Home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">News</span> <span class="keyword">from</span> <span class="string">&#x27;@/pages/News.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;@/pages/About.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line"><span class="attr">history</span>:<span class="title function_">createWebHistory</span>(),</span><br><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>main.ts</code>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/index&#x27;</span></span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>App.vue</code>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h2 class=&quot;title&quot;&gt;Vue路由测试&lt;/h2&gt;</span><br><span class="line">    &lt;!-- 导航区 --&gt;</span><br><span class="line">    &lt;div class=&quot;navigate&quot;&gt;</span><br><span class="line">      &lt;RouterLink to=&quot;/home&quot; active-class=&quot;active&quot;&gt;首页&lt;/RouterLink&gt;</span><br><span class="line">      &lt;RouterLink to=&quot;/news&quot; active-class=&quot;active&quot;&gt;新闻&lt;/RouterLink&gt;</span><br><span class="line">      &lt;RouterLink to=&quot;/about&quot; active-class=&quot;active&quot;&gt;关于&lt;/RouterLink&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!-- 展示区 --&gt;</span><br><span class="line">    &lt;div class=&quot;main-content&quot;&gt;</span><br><span class="line">      &lt;RouterView&gt;&lt;/RouterView&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;</span><br><span class="line">  import &#123;RouterLink,RouterView&#125; from &#x27;vue-router&#x27;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-3-【两个注意点】">4.3. 【两个注意点】</h2><blockquote><ol><li><p>路由组件通常存放在<code>pages</code> 或 <code>views</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</p></li><li><p>通过点击导航，视觉效果上“消失” 了的路由组件，默认是被<strong>卸载</strong>掉的，需要的时候再去<strong>挂载</strong>。</p></li></ol></blockquote><h2 id="4-4-【路由器工作模式】">4.4.【路由器工作模式】</h2><ol><li><p><code>history</code>模式</p><blockquote><p>优点：<code>URL</code>更加美观，不带有<code>#</code>，更接近传统的网站<code>URL</code>。</p><p>缺点：后期项目上线，需要服务端配合处理路径问题，否则刷新会有<code>404</code>错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>:<span class="title function_">createWebHistory</span>(), <span class="comment">//history模式</span></span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></blockquote></li><li><p><code>hash</code>模式</p><blockquote><p>优点：兼容性更好，因为不需要服务器端处理路径。</p><p>缺点：<code>URL</code>带有<code>#</code>不太美观，且在<code>SEO</code>优化方面相对较差。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>:<span class="title function_">createWebHashHistory</span>(), <span class="comment">//hash模式</span></span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></blockquote></li></ol><h2 id="4-5-【to的两种写法】">4.5. 【to的两种写法】</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 第一种：to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link active-class=&quot;active&quot; to=&quot;/home&quot;&gt;主页&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 第二种：to的对象写法 --&gt;</span><br><span class="line">&lt;router-link active-class=&quot;active&quot; :to=&quot;&#123;path:&#x27;/home&#x27;&#125;&quot;&gt;Home&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><h2 id="4-6-【命名路由】">4.6. 【命名路由】</h2><p>作用：可以简化路由跳转及传参（后面就讲）。</p><p>给路由规则命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;zhuye&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;xinwen&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">News</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;guanyu&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>跳转路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--简化前：需要写完整的路径（to的字符串写法） --&gt;</span><br><span class="line">&lt;router-link to=&quot;/news/detail&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化后：直接通过名字跳转（to的对象写法配合name属性） --&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123;name:&#x27;guanyu&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><h2 id="4-7-【嵌套路由】">4.7. 【嵌套路由】</h2><ol><li><p>编写<code>News</code>的子路由：<code>Detail.vue</code></p></li><li><p>配置路由规则，使用<code>children</code>配置项：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>:<span class="title function_">createWebHistory</span>(),</span><br><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;zhuye&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xinwen&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">News</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiang&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;detail&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Detail</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;guanyu&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure></li><li><p>跳转路由（记得要加完整路径）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/news/detail&quot;&gt;xxxx&lt;/router-link&gt;</span><br><span class="line">&lt;!-- 或 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123;path:&#x27;/news/detail&#x27;&#125;&quot;&gt;xxxx&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li><li><p>记得去<code>Home</code>组件中预留一个<code>&lt;router-view&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;news&quot;&gt;</span><br><span class="line">    &lt;nav class=&quot;news-list&quot;&gt;</span><br><span class="line">      &lt;RouterLink v-for=&quot;news in newsList&quot; :key=&quot;news.id&quot; :to=&quot;&#123;path:&#x27;/news/detail&#x27;&#125;&quot;&gt;</span><br><span class="line">        &#123;&#123;news.name&#125;&#125;</span><br><span class="line">      &lt;/RouterLink&gt;</span><br><span class="line">    &lt;/nav&gt;</span><br><span class="line">    &lt;div class=&quot;news-detail&quot;&gt;</span><br><span class="line">      &lt;RouterView/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-8-【路由传参】">4.8. 【路由传参】</h2><h3 id="query参数">query参数</h3><ol><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 跳转并携带query参数（to的字符串写法） --&gt;</span><br><span class="line">&lt;router-link to=&quot;/news/detail?a=1&amp;b=2&amp;content=欢迎你&quot;&gt;</span><br><span class="line">跳转</span><br><span class="line">&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带query参数（to的对象写法） --&gt;</span><br><span class="line">&lt;RouterLink </span><br><span class="line">  :to=&quot;&#123;</span><br><span class="line">    //name:&#x27;xiang&#x27;, //用name也可以跳转</span><br><span class="line">    path:&#x27;/news/detail&#x27;,</span><br><span class="line">    query:&#123;</span><br><span class="line">      id:news.id,</span><br><span class="line">      title:news.title,</span><br><span class="line">      content:news.content</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &#123;&#123;news.title&#125;&#125;</span><br><span class="line">&lt;/RouterLink&gt;</span><br></pre></td></tr></table></figure></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useRoute&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"><span class="comment">// 打印query参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">query</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="params参数">params参数</h3><ol><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 跳转并携带params参数（to的字符串写法） --&gt;</span><br><span class="line">&lt;RouterLink :to=&quot;`/news/detail/001/新闻001/内容001`&quot;&gt;&#123;&#123;news.title&#125;&#125;&lt;/RouterLink&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带params参数（to的对象写法） --&gt;</span><br><span class="line">&lt;RouterLink </span><br><span class="line">  :to=&quot;&#123;</span><br><span class="line">    name:&#x27;xiang&#x27;, //用name跳转</span><br><span class="line">    params:&#123;</span><br><span class="line">      id:news.id,</span><br><span class="line">      title:news.title,</span><br><span class="line">      content:news.title</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &#123;&#123;news.title&#125;&#125;</span><br><span class="line">&lt;/RouterLink&gt;</span><br></pre></td></tr></table></figure></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useRoute&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"><span class="comment">// 打印params参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">params</span>)</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>备注1：传递<code>params</code>参数时，若使用<code>to</code>的对象写法，必须使用<code>name</code>配置项，不能用<code>path</code>。</p><p>备注2：传递<code>params</code>参数时，需要提前在规则中占位。</p></blockquote><h2 id="4-9-【路由的props配置】">4.9. 【路由的props配置】</h2><p>作用：让路由组件更方便的收到参数（可以将路由参数作为<code>props</code>传给组件）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiang&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title/:content&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Detail</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// props的对象写法，作用：把对象中的每一组key-value作为props传给Detail组件</span></span><br><span class="line">  <span class="comment">// props:&#123;a:1,b:2,c:3&#125;, </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// props的布尔值写法，作用：把收到了每一组params参数，作为props传给Detail组件</span></span><br><span class="line">  <span class="comment">// props:true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// props的函数写法，作用：把返回的对象中每一组key-value作为props传给Detail组件</span></span><br><span class="line">  <span class="title function_">props</span>(<span class="params">route</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> route.<span class="property">query</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-10-【-replace属性】">4.10. 【 replace属性】</h2><ol><li><p>作用：控制路由跳转时操作浏览器历史记录的模式。</p></li><li><p>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>：</p><ul><li><code>push</code>是追加历史记录（默认值）。</li><li><code>replace</code>是替换当前记录。</li></ul></li><li><p>开启<code>replace</code>模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;RouterLink replace .......&gt;News&lt;/RouterLink&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-11-【编程式导航】">4.11. 【编程式导航】</h2><p>路由组件的两个重要的属性：<code>$route</code>和<code>$router</code>变成了两个<code>hooks</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useRoute,useRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">query</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">parmas</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(router.<span class="property">push</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(router.<span class="property">replace</span>)</span><br></pre></td></tr></table></figure><h2 id="4-12-【重定向】">4.12. 【重定向】</h2><ol><li><p>作用：将特定的路径，重新定向到已有路由。</p></li><li><p>具体编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">redirect</span>:<span class="string">&#x27;/about&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1>5. pinia</h1><h2 id="5-1【准备一个效果】">5.1【准备一个效果】</h2><img src="../../social/images/pinia_example.gif" alt="pinia_example" style="zoom:30%;border:3px solid" /> <h2 id="5-2【搭建-pinia-环境】">5.2【搭建 pinia 环境】</h2><p>第一步：<code>npm install pinia</code></p><p>第二步：操作<code>src/main.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 引入createPinia，用于创建pinia */</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建pinia */</span></span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用插件 */</span>&#123;&#125;</span><br><span class="line">app.<span class="title function_">use</span>(pinia)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>此时开发者工具中已经有了<code>pinia</code>选项</p><img src="https://cdn.nlark.com/yuque/0/2023/png/35780599/1684309952481-c67f67f9-d1a3-4d69-8bd6-2b381e003f31.png" style="zoom:80%;border:1px solid black;border-radius:10px" /><h2 id="5-3【存储-读取数据】">5.3【存储+读取数据】</h2><ol><li><p><code>Store</code>是一个保存：<strong>状态</strong>、<strong>业务逻辑</strong> 的实体，每个组件都可以<strong>读取</strong>、<strong>写入</strong>它。</p></li><li><p>它有三个概念：<code>state</code>、<code>getter</code>、<code>action</code>，相当于组件中的： <code>data</code>、 <code>computed</code> 和 <code>methods</code>。</p></li><li><p>具体编码：<code>src/store/count.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入defineStore用于创建store</span></span><br><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并暴露一个store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;count&#x27;</span>,&#123;</span><br><span class="line">  <span class="comment">// 动作</span></span><br><span class="line">  <span class="attr">actions</span>:&#123;&#125;,</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">sum</span>:<span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 计算</span></span><br><span class="line">  <span class="attr">getters</span>:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>具体编码：<code>src/store/talk.ts</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入defineStore用于创建store</span></span><br><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并暴露一个store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useTalkStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;talk&#x27;</span>,&#123;</span><br><span class="line">  <span class="comment">// 动作</span></span><br><span class="line">  <span class="attr">actions</span>:&#123;&#125;,</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">talkList</span>:[</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;yuysada01&#x27;</span>,<span class="attr">content</span>:<span class="string">&#x27;你今天有点怪，哪里怪？怪好看的！&#x27;</span>&#125;,</span><br><span class="line">     &#123;<span class="attr">id</span>:<span class="string">&#x27;yuysada02&#x27;</span>,<span class="attr">content</span>:<span class="string">&#x27;草莓、蓝莓、蔓越莓，你想我了没？&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;yuysada03&#x27;</span>,<span class="attr">content</span>:<span class="string">&#x27;心里给你留了一块地，我的死心塌地&#x27;</span>&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 计算</span></span><br><span class="line">  <span class="attr">getters</span>:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件中使用<code>state</code>中的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;当前求和为：&#123;&#123; sumStore.sum &#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;</span><br><span class="line">  // 引入对应的useXxxxxStore</span><br><span class="line">  import &#123;useSumStore&#125; from &#x27;@/store/sum&#x27;</span><br><span class="line">  </span><br><span class="line">  // 调用useXxxxxStore得到对应的store</span><br><span class="line">  const sumStore = useSumStore()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;talk in talkStore.talkList&quot; :key=&quot;talk.id&quot;&gt;</span><br><span class="line">      &#123;&#123; talk.content &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;</span><br><span class="line">  import axios from &#x27;axios&#x27;</span><br><span class="line">  import &#123;useTalkStore&#125; from &#x27;@/store/talk&#x27;</span><br><span class="line"></span><br><span class="line">  const talkStore = useTalkStore()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="5-4-【修改数据】-三种方式">5.4.【修改数据】(三种方式)</h2><ol><li><p>第一种修改方式，直接修改</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">countStore.<span class="property">sum</span> = <span class="number">666</span></span><br></pre></td></tr></table></figure></li><li><p>第二种修改方式：批量修改</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">countStore.$patch(&#123;</span><br><span class="line">  <span class="attr">sum</span>:<span class="number">999</span>,</span><br><span class="line">  <span class="attr">school</span>:<span class="string">&#x27;atguigu&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>第三种修改方式：借助<code>action</code>修改（<code>action</code>中可以编写一些业务逻辑）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">/*************/</span></span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="comment">//加</span></span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">value:number</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">sum</span> &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">//操作countStore中的sum</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sum</span> += value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//减</span></span><br><span class="line">    <span class="title function_">decrement</span>(<span class="params">value:number</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">sum</span> &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sum</span> -= value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/*************/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件中调用<code>action</code>即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用countStore</span></span><br><span class="line"><span class="keyword">const</span> countStore = <span class="title function_">useCountStore</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用对应action</span></span><br><span class="line">countStore.<span class="title function_">incrementOdd</span>(n.<span class="property">value</span>)</span><br></pre></td></tr></table></figure></li></ol><h2 id="5-5-【storeToRefs】">5.5.【storeToRefs】</h2><ul><li>借助<code>storeToRefs</code>将<code>store</code>中的数据转为<code>ref</code>对象，方便在模板中使用。</li><li>注意：<code>pinia</code>提供的<code>storeToRefs</code>只会将数据做转换，而<code>Vue</code>的<code>toRefs</code>会转换<code>store</code>中数据。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;count&quot;&gt;</span><br><span class="line">&lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;</span><br><span class="line">  import &#123; useCountStore &#125; from &#x27;@/store/count&#x27;</span><br><span class="line">  /* 引入storeToRefs */</span><br><span class="line">  import &#123; storeToRefs &#125; from &#x27;pinia&#x27;</span><br><span class="line"></span><br><span class="line">/* 得到countStore */</span><br><span class="line">  const countStore = useCountStore()</span><br><span class="line">  /* 使用storeToRefs转换countStore，随后解构 */</span><br><span class="line">  const &#123;sum&#125; = storeToRefs(countStore)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-6-【getters】">5.6.【getters】</h2><ol><li><p>概念：当<code>state</code>中的数据，需要经过处理后再使用时，可以使用<code>getters</code>配置。</p></li><li><p>追加<code>getters</code>配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入defineStore用于创建store</span></span><br><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并暴露一个store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;count&#x27;</span>,&#123;</span><br><span class="line">  <span class="comment">// 动作</span></span><br><span class="line">  <span class="attr">actions</span>:&#123;</span><br><span class="line">    <span class="comment">/************/</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">sum</span>:<span class="number">1</span>,</span><br><span class="line">      <span class="attr">school</span>:<span class="string">&#x27;atguigu&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 计算</span></span><br><span class="line">  <span class="attr">getters</span>:&#123;</span><br><span class="line">    <span class="attr">bigSum</span>:(state):<span class="function"><span class="params">number</span> =&gt;</span> state.<span class="property">sum</span> *<span class="number">10</span>,</span><br><span class="line">    <span class="title function_">upperSchool</span>():string&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>. school.<span class="title function_">toUpperCase</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件中读取数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;increment,decrement&#125; = countStore</span><br><span class="line"><span class="keyword">let</span> &#123;sum,school,bigSum,upperSchool&#125; = <span class="title function_">storeToRefs</span>(countStore)</span><br></pre></td></tr></table></figure></li></ol><h2 id="5-7-【-subscribe】">5.7.【$subscribe】</h2><p>通过 store 的 <code>$subscribe()</code> 方法侦听 <code>state</code> 及其变化</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">talkStore.$subscribe(<span class="function">(<span class="params">mutate,state</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;LoveTalk&#x27;</span>,mutate,state)</span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;talk&#x27;</span>,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(talkList.<span class="property">value</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="5-8-【store组合式写法】">5.8. 【store组合式写法】</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;nanoid&#125; <span class="keyword">from</span> <span class="string">&#x27;nanoid&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useTalkStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;talk&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// talkList就是state</span></span><br><span class="line">  <span class="keyword">const</span> talkList = <span class="title function_">reactive</span>(</span><br><span class="line">    <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;talkList&#x27;</span>) <span class="keyword">as</span> <span class="built_in">string</span>) || []</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getATalk函数相当于action</span></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getATalk</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 发请求，下面这行的写法是：连续解构赋值+重命名</span></span><br><span class="line">    <span class="keyword">let</span> &#123;<span class="attr">data</span>:&#123;<span class="attr">content</span>:title&#125;&#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;https://api.uomg.com/api/rand.qinghua?format=json&#x27;</span>)</span><br><span class="line">    <span class="comment">// 把请求回来的字符串，包装成一个对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;<span class="attr">id</span>:<span class="title function_">nanoid</span>(),title&#125;</span><br><span class="line">    <span class="comment">// 放到数组中</span></span><br><span class="line">    talkList.<span class="title function_">unshift</span>(obj)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;talkList,getATalk&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1>6. 组件通信</h1><p><strong><code>Vue3</code>组件通信和<code>Vue2</code>的区别：</strong></p><ul><li>移出事件总线，使用<code>mitt</code>代替。</li></ul><ul><li><code>vuex</code>换成了<code>pinia</code>。</li><li>把<code>.sync</code>优化到了<code>v-model</code>里面了。</li><li>把<code>$listeners</code>所有的东西，合并到<code>$attrs</code>中了。</li><li><code>$children</code>被砍掉了。</li></ul><p><strong>常见搭配形式：</strong></p><img src="../../social/images/image-20231119185900990.png" alt="image-20231119185900990" style="zoom:60%;" /> <h2 id="6-1-【props】">6.1. 【props】</h2><p>概述：<code>props</code>是使用频率最高的一种通信方式，常用与 ：<strong>父 ↔ 子</strong>。</p><ul><li>若 <strong>父传子</strong>：属性值是<strong>非函数</strong>。</li><li>若 <strong>子传父</strong>：属性值是<strong>函数</strong>。</li></ul><p>父组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;h3&gt;父组件，&lt;/h3&gt;</span><br><span class="line">&lt;h4&gt;我的车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;h4&gt;儿子给的玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;Child :car=&quot;car&quot; :getToy=&quot;getToy&quot;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;</span><br><span class="line">import Child from &#x27;./Child.vue&#x27;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">// 数据</span><br><span class="line">const car = ref(&#x27;奔驰&#x27;)</span><br><span class="line">const toy = ref()</span><br><span class="line">// 方法</span><br><span class="line">function getToy(value:string)&#123;</span><br><span class="line">toy.value = value</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">    &lt;h3&gt;子组件&lt;/h3&gt;</span><br><span class="line">&lt;h4&gt;我的玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;h4&gt;父给我的车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;button @click=&quot;getToy(toy)&quot;&gt;玩具给父亲&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Child&quot;&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const toy = ref(&#x27;奥特曼&#x27;)</span><br><span class="line"></span><br><span class="line">defineProps([&#x27;car&#x27;,&#x27;getToy&#x27;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="6-2-【自定义事件】">6.2. 【自定义事件】</h2><ol><li>概述：自定义事件常用于：<strong>子 =&gt; 父。</strong></li><li>注意区分好：原生事件、自定义事件。</li></ol><ul><li>原生事件：<ul><li>事件名是特定的（<code>click</code>、<code>mosueenter</code>等等）</li><li>事件对象<code>$event</code>: 是包含事件相关信息的对象（<code>pageX</code>、<code>pageY</code>、<code>target</code>、<code>keyCode</code>）</li></ul></li><li>自定义事件：<ul><li>事件名是任意名称</li><li><strong style="color:red">事件对象<code>$event</code>: 是调用<code>emit</code>时所提供的数据，可以是任意类型！！！</strong ></li></ul></li></ul><ol start="3"><li><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在父组件中，给子组件绑定自定义事件：--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Child</span> @<span class="attr">send-toy</span>=<span class="string">&quot;toy = $event&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--注意区分原生事件与自定义事件中的$event--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toy = $event&quot;</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件中，触发事件：</span></span><br><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;send-toy&#x27;</span>, 具体数据)</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-3-【mitt】">6.3. 【mitt】</h2><p>概述：与消息订阅与发布（<code>pubsub</code>）功能类似，可以实现任意组件间通信。</p><p>安装<code>mitt</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mitt</span><br></pre></td></tr></table></figure><p>新建文件：<code>src\utils\emitter.ts</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入mitt </span></span><br><span class="line"><span class="keyword">import</span> mitt <span class="keyword">from</span> <span class="string">&quot;mitt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建emitter</span></span><br><span class="line"><span class="keyword">const</span> emitter = <span class="title function_">mitt</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  // 绑定事件</span></span><br><span class="line"><span class="comment">  emitter.on(&#x27;abc&#x27;,(value)=&gt;&#123;</span></span><br><span class="line"><span class="comment">    console.log(&#x27;abc事件被触发&#x27;,value)</span></span><br><span class="line"><span class="comment">  &#125;)</span></span><br><span class="line"><span class="comment">  emitter.on(&#x27;xyz&#x27;,(value)=&gt;&#123;</span></span><br><span class="line"><span class="comment">    console.log(&#x27;xyz事件被触发&#x27;,value)</span></span><br><span class="line"><span class="comment">  &#125;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">    // 触发事件</span></span><br><span class="line"><span class="comment">    emitter.emit(&#x27;abc&#x27;,666)</span></span><br><span class="line"><span class="comment">    emitter.emit(&#x27;xyz&#x27;,777)</span></span><br><span class="line"><span class="comment">  &#125;, 1000);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">    // 清理事件</span></span><br><span class="line"><span class="comment">    emitter.all.clear()</span></span><br><span class="line"><span class="comment">  &#125;, 3000); </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并暴露mitt</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> emitter</span><br></pre></td></tr></table></figure><p>接收数据的组件中：绑定事件、同时在销毁前解绑事件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&quot;@/utils/emitter&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; onUnmounted &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定事件</span></span><br><span class="line">emitter.<span class="title function_">on</span>(<span class="string">&#x27;send-toy&#x27;</span>,<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;send-toy事件被触发&#x27;</span>,value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 解绑事件</span></span><br><span class="line">  emitter.<span class="title function_">off</span>(<span class="string">&#x27;send-toy&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>【第三步】：提供数据的组件，在合适的时候触发事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&quot;@/utils/emitter&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sendToy</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 触发事件</span></span><br><span class="line">  emitter.<span class="title function_">emit</span>(<span class="string">&#x27;send-toy&#x27;</span>,toy.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意这个重要的内置关系，总线依赖着这个内置关系</strong></p><h2 id="6-4-【v-model】">6.4.【v-model】</h2><ol><li><p>概述：实现 <strong>父↔子</strong> 之间相互通信。</p></li><li><p>前序知识 —— <code>v-model</code>的本质</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用v-model指令 --&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;userName&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- v-model的本质是下面这行代码 --&gt;</span><br><span class="line">&lt;input </span><br><span class="line">  type=&quot;text&quot; </span><br><span class="line">  :value=&quot;userName&quot; </span><br><span class="line">  @input=&quot;userName =(&lt;HTMLInputElement&gt;$event.target).value&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li><li><p>组件标签上的<code>v-model</code>的本质：<code>:moldeValue</code> ＋ <code>update:modelValue</code>事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 组件标签上使用v-model指令 --&gt;</span><br><span class="line">&lt;AtguiguInput v-model=&quot;userName&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 组件标签上v-model的本质 --&gt;</span><br><span class="line">&lt;AtguiguInput :modelValue=&quot;userName&quot; @update:model-value=&quot;userName = $event&quot;/&gt;</span><br></pre></td></tr></table></figure><p><code>AtguiguInput</code>组件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;!--将接收的value值赋给input元素的value属性，目的是：为了呈现数据 --&gt;</span><br><span class="line">&lt;!--给input元素绑定原生input事件，触发input事件时，进而触发update:model-value事件--&gt;</span><br><span class="line">    &lt;input </span><br><span class="line">       type=&quot;text&quot; </span><br><span class="line">       :value=&quot;modelValue&quot; </span><br><span class="line">       @input=&quot;emit(&#x27;update:model-value&#x27;,$event.target.value)&quot;</span><br><span class="line">    &gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;AtguiguInput&quot;&gt;</span><br><span class="line">  // 接收props</span><br><span class="line">  defineProps([&#x27;modelValue&#x27;])</span><br><span class="line">  // 声明事件</span><br><span class="line">  const emit = defineEmits([&#x27;update:model-value&#x27;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>也可以更换<code>value</code>，例如改成<code>abc</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 也可以更换value，例如改成abc--&gt;</span><br><span class="line">&lt;AtguiguInput v-model:abc=&quot;userName&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 上面代码的本质如下 --&gt;</span><br><span class="line">&lt;AtguiguInput :abc=&quot;userName&quot; @update:abc=&quot;userName = $event&quot;/&gt;</span><br></pre></td></tr></table></figure><p><code>AtguiguInput</code>组件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;input </span><br><span class="line">       type=&quot;text&quot; </span><br><span class="line">       :value=&quot;abc&quot; </span><br><span class="line">       @input=&quot;emit(&#x27;update:abc&#x27;,$event.target.value)&quot;</span><br><span class="line">    &gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;AtguiguInput&quot;&gt;</span><br><span class="line">  // 接收props</span><br><span class="line">  defineProps([&#x27;abc&#x27;])</span><br><span class="line">  // 声明事件</span><br><span class="line">  const emit = defineEmits([&#x27;update:abc&#x27;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>如果<code>value</code>可以更换，那么就可以在组件标签上多次使用<code>v-model</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;AtguiguInput v-model:abc=&quot;userName&quot; v-model:xyz=&quot;password&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-5-【-attrs-】">6.5.【$attrs 】</h2><ol><li><p>概述：<code>$attrs</code>用于实现<strong>当前组件的父组件</strong>，向<strong>当前组件的子组件</strong>通信（<strong>祖→孙</strong>）。</p></li><li><p>具体说明：<code>$attrs</code>是一个对象，包含所有父组件传入的标签属性。</p><blockquote><p>注意：<code>$attrs</code>会自动排除<code>props</code>中声明的属性(可以认为声明过的 <code>props</code> 被子组件自己“消费”了)</p></blockquote></li></ol><p>父组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;h3&gt;父组件&lt;/h3&gt;</span><br><span class="line">&lt;Child :a=&quot;a&quot; :b=&quot;b&quot; :c=&quot;c&quot; :d=&quot;d&quot; v-bind=&quot;&#123;x:100,y:200&#125;&quot; :updateA=&quot;updateA&quot;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;</span><br><span class="line">import Child from &#x27;./Child.vue&#x27;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">let a = ref(1)</span><br><span class="line">let b = ref(2)</span><br><span class="line">let c = ref(3)</span><br><span class="line">let d = ref(4)</span><br><span class="line"></span><br><span class="line">function updateA(value)&#123;</span><br><span class="line">a.value = value</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;child&quot;&gt;</span><br><span class="line">&lt;h3&gt;子组件&lt;/h3&gt;</span><br><span class="line">&lt;GrandChild v-bind=&quot;$attrs&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Child&quot;&gt;</span><br><span class="line">import GrandChild from &#x27;./GrandChild.vue&#x27;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>孙组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;grand-child&quot;&gt;</span><br><span class="line">&lt;h3&gt;孙组件&lt;/h3&gt;</span><br><span class="line">&lt;h4&gt;a：&#123;&#123; a &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;h4&gt;b：&#123;&#123; b &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;h4&gt;c：&#123;&#123; c &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;h4&gt;d：&#123;&#123; d &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;h4&gt;x：&#123;&#123; x &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;h4&gt;y：&#123;&#123; y &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;button @click=&quot;updateA(666)&quot;&gt;点我更新A&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;GrandChild&quot;&gt;</span><br><span class="line">defineProps([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;updateA&#x27;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="6-6-【-refs、-parent】">6.6. 【$refs、$parent】</h2><ol><li><p>概述：</p><ul><li><code>$refs</code>用于 ：<strong>父→子。</strong></li><li><code>$parent</code>用于：<strong>子→父。</strong></li></ul></li><li><p>原理如下：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>$refs</code></td><td>值为对象，包含所有被<code>ref</code>属性标识的<code>DOM</code>元素或组件实例。</td></tr><tr><td><code>$parent</code></td><td>值为对象，当前组件的父组件实例对象。</td></tr></tbody></table></li></ol><h2 id="6-7-【provide、inject】">6.7. 【provide、inject】</h2><ol><li><p>概述：实现<strong>祖孙组件</strong>直接通信</p></li><li><p>具体使用：</p><ul><li>在祖先组件中通过<code>provide</code>配置向后代组件提供数据</li><li>在后代组件中通过<code>inject</code>配置来声明接收数据</li></ul></li><li><p>具体编码：</p><p>【第一步】父组件中，使用<code>provide</code>提供数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;h3&gt;父组件&lt;/h3&gt;</span><br><span class="line">    &lt;h4&gt;资产：&#123;&#123; money &#125;&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;h4&gt;汽车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;button @click=&quot;money += 1&quot;&gt;资产+1&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;car.price += 1&quot;&gt;汽车价格+1&lt;/button&gt;</span><br><span class="line">    &lt;Child/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;</span><br><span class="line">  import Child from &#x27;./Child.vue&#x27;</span><br><span class="line">  import &#123; ref,reactive,provide &#125; from &quot;vue&quot;;</span><br><span class="line">  // 数据</span><br><span class="line">  let money = ref(100)</span><br><span class="line">  let car = reactive(&#123;</span><br><span class="line">    brand:&#x27;奔驰&#x27;,</span><br><span class="line">    price:100</span><br><span class="line">  &#125;)</span><br><span class="line">  // 用于更新money的方法</span><br><span class="line">  function updateMoney(value:number)&#123;</span><br><span class="line">    money.value += value</span><br><span class="line">  &#125;</span><br><span class="line">  // 提供数据</span><br><span class="line">  provide(&#x27;moneyContext&#x27;,&#123;money,updateMoney&#125;)</span><br><span class="line">  provide(&#x27;car&#x27;,car)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意：子组件中不用编写任何东西，是不受到任何打扰的</p></blockquote><p>【第二步】孙组件中使用<code>inject</code>配置项接受数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   &lt;template&gt;</span><br><span class="line">     &lt;div class=&quot;grand-child&quot;&gt;</span><br><span class="line">       &lt;h3&gt;我是孙组件&lt;/h3&gt;</span><br><span class="line">       &lt;h4&gt;资产：&#123;&#123; money &#125;&#125;&lt;/h4&gt;</span><br><span class="line">       &lt;h4&gt;汽车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;</span><br><span class="line">       &lt;button @click=&quot;updateMoney(6)&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line">   &lt;/template&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;script setup lang=&quot;ts&quot; name=&quot;GrandChild&quot;&gt;</span><br><span class="line">     import &#123; inject &#125; from &#x27;vue&#x27;;</span><br><span class="line">     // 注入数据</span><br><span class="line">    let &#123;money,updateMoney&#125; = inject(&#x27;moneyContext&#x27;,&#123;money:0,updateMoney:(x:number)=&gt;&#123;&#125;&#125;)</span><br><span class="line">     let car = inject(&#x27;car&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-8-【pinia】">6.8. 【pinia】</h2><p>参考之前<code>pinia</code>部分的讲解</p><h2 id="6-9-【slot】">6.9. 【slot】</h2><h3 id="1-默认插槽">1. 默认插槽</h3><p><img src="http://49.232.112.44/images/default_slot.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category title=&quot;今日热门游戏&quot;&gt;</span><br><span class="line">          &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">          &lt;/ul&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">          &lt;div class=&quot;item&quot;&gt;</span><br><span class="line">            &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;</span><br><span class="line">            &lt;!-- 默认插槽 --&gt;</span><br><span class="line">            &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="2-具名插槽">2. 具名插槽</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category title=&quot;今日热门游戏&quot;&gt;</span><br><span class="line">          &lt;template v-slot:s1&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">              &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">          &lt;template #s2&gt;</span><br><span class="line">            &lt;a href=&quot;&quot;&gt;更多&lt;/a&gt;</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">          &lt;div class=&quot;item&quot;&gt;</span><br><span class="line">            &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;</span><br><span class="line">            &lt;slot name=&quot;s1&quot;&gt;&lt;/slot&gt;</span><br><span class="line">            &lt;slot name=&quot;s2&quot;&gt;&lt;/slot&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="3-作用域插槽">3. 作用域插槽</h3><ol><li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（新闻数据在<code>News</code>组件中，但使用数据所遍历出来的结构由<code>App</code>组件决定）</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">      &lt;Game v-slot=&quot;params&quot;&gt;</span><br><span class="line">      &lt;!-- &lt;Game v-slot:default=&quot;params&quot;&gt; --&gt;</span><br><span class="line">      &lt;!-- &lt;Game #default=&quot;params&quot;&gt; --&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &lt;li v-for=&quot;g in params.games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/Game&gt;</span><br><span class="line"></span><br><span class="line">子组件中：</span><br><span class="line">      &lt;template&gt;</span><br><span class="line">        &lt;div class=&quot;category&quot;&gt;</span><br><span class="line">          &lt;h2&gt;今日游戏榜单&lt;/h2&gt;</span><br><span class="line">          &lt;slot :games=&quot;games&quot; a=&quot;哈哈&quot;&gt;&lt;/slot&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">      &lt;script setup lang=&quot;ts&quot; name=&quot;Category&quot;&gt;</span><br><span class="line">        import &#123;reactive&#125; from &#x27;vue&#x27;</span><br><span class="line">        let games = reactive([</span><br><span class="line">          &#123;id:&#x27;asgdytsa01&#x27;,name:&#x27;英雄联盟&#x27;&#125;,</span><br><span class="line">          &#123;id:&#x27;asgdytsa02&#x27;,name:&#x27;王者荣耀&#x27;&#125;,</span><br><span class="line">          &#123;id:&#x27;asgdytsa03&#x27;,name:&#x27;红色警戒&#x27;&#125;,</span><br><span class="line">          &#123;id:&#x27;asgdytsa04&#x27;,name:&#x27;斗罗大陆&#x27;&#125;</span><br><span class="line">        ])</span><br><span class="line">      &lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><h1>7. 其它 API</h1><h2 id="7-1-【shallowRef-与-shallowReactive-】">7.1.【shallowRef 与 shallowReactive 】</h2><h3 id="shallowRef"><code>shallowRef</code></h3><ol><li><p>作用：创建一个响应式数据，但只对顶层属性进行响应式处理。</p></li><li><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myVar = <span class="title function_">shallowRef</span>(initialValue);</span><br></pre></td></tr></table></figure></li><li><p>特点：只跟踪引用值的变化，不关心值内部的属性变化。</p></li></ol><h3 id="shallowReactive"><code>shallowReactive</code></h3><ol><li><p>作用：创建一个浅层响应式对象，只会使对象的最顶层属性变成响应式的，对象内部的嵌套属性则不会变成响应式的</p></li><li><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = <span class="title function_">shallowReactive</span>(&#123; ... &#125;);</span><br></pre></td></tr></table></figure></li><li><p>特点：对象的顶层属性是响应式的，但嵌套对象的属性不是。</p></li></ol><h3 id="总结">总结</h3><blockquote><p>通过使用 <a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowref"><code>shallowRef()</code></a> 和 <a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive"><code>shallowReactive()</code></a> 来绕开深度响应。浅层式 <code>API</code> 创建的状态只在其顶层是响应式的，对所有深层的对象不会做任何处理，避免了对每一个内部属性做响应式所带来的性能成本，这使得属性的访问变得更快，可提升性能。</p></blockquote><h2 id="7-2-【readonly-与-shallowReadonly】">7.2.【readonly 与 shallowReadonly】</h2><h3 id="readonly"><strong><code>readonly</code></strong></h3><ol><li><p>作用：用于创建一个对象的深只读副本。</p></li><li><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = <span class="title function_">reactive</span>(&#123; ... &#125;);</span><br><span class="line"><span class="keyword">const</span> readOnlyCopy = <span class="title function_">readonly</span>(original);</span><br></pre></td></tr></table></figure></li><li><p>特点：</p><ul><li>对象的所有嵌套属性都将变为只读。</li><li>任何尝试修改这个对象的操作都会被阻止（在开发模式下，还会在控制台中发出警告）。</li></ul></li><li><p>应用场景：</p><ul><li>创建不可变的状态快照。</li><li>保护全局状态或配置不被修改。</li></ul></li></ol><h3 id="shallowReadonly"><strong><code>shallowReadonly</code></strong></h3><ol><li><p>作用：与 <code>readonly</code> 类似，但只作用于对象的顶层属性。</p></li><li><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = <span class="title function_">reactive</span>(&#123; ... &#125;);</span><br><span class="line"><span class="keyword">const</span> shallowReadOnlyCopy = <span class="title function_">shallowReadonly</span>(original);</span><br></pre></td></tr></table></figure></li><li><p>特点：</p><ul><li><p>只将对象的顶层属性设置为只读，对象内部的嵌套属性仍然是可变的。</p></li><li><p>适用于只需保护对象顶层属性的场景。</p></li></ul></li></ol><h2 id="7-3-【toRaw-与-markRaw】">7.3.【toRaw 与 markRaw】</h2><h3 id="toRaw"><code>toRaw</code></h3><ol><li><p>作用：用于获取一个响应式对象的原始对象， <code>toRaw</code> 返回的对象不再是响应式的，不会触发视图更新。</p><blockquote><p>官网描述：这是一个可以用于临时读取而不引起代理访问/跟踪开销，或是写入而不触发更改的特殊方法。不建议保存对原始对象的持久引用，请谨慎使用。</p></blockquote><blockquote><p>何时使用？ —— 在需要将响应式对象传递给非 <code>Vue</code> 的库或外部系统时，使用 <code>toRaw</code> 可以确保它们收到的是普通对象</p></blockquote></li><li><p>具体编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive,toRaw,markRaw,isReactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* toRaw */</span></span><br><span class="line"><span class="comment">// 响应式对象</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;tony&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">// 原始对象</span></span><br><span class="line"><span class="keyword">let</span> rawPerson = <span class="title function_">toRaw</span>(person)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* markRaw */</span></span><br><span class="line"><span class="keyword">let</span> citysd = <span class="title function_">markRaw</span>([</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda01&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;北京&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda02&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;上海&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda03&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;天津&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda04&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;重庆&#x27;</span>&#125;</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了</span></span><br><span class="line"><span class="keyword">let</span> citys2 = <span class="title function_">reactive</span>(citys)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(person))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(rawPerson))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(citys))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(citys2))</span><br></pre></td></tr></table></figure></li></ol><h3 id="markRaw"><code>markRaw</code></h3><ol><li><p>作用：标记一个对象，使其<strong>永远不会</strong>变成响应式的。</p><blockquote><p>例如使用<code>mockjs</code>时，为了防止误把<code>mockjs</code>变为响应式对象，可以使用 <code>markRaw</code> 去标记<code>mockjs</code></p></blockquote></li><li><p>编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* markRaw */</span></span><br><span class="line"><span class="keyword">let</span> citys = <span class="title function_">markRaw</span>([</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda01&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;北京&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda02&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;上海&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda03&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;天津&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda04&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;重庆&#x27;</span>&#125;</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了</span></span><br><span class="line"><span class="keyword">let</span> citys2 = <span class="title function_">reactive</span>(citys)</span><br></pre></td></tr></table></figure></li></ol><h2 id="7-4-【customRef】">7.4.【customRef】</h2><p>作用：创建一个自定义的<code>ref</code>，并对其依赖项跟踪和更新触发进行逻辑控制。</p><p>实现防抖效果（<code>useSumRef.ts</code>）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;customRef &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">initValue:<span class="built_in">string</span>,delay:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = <span class="title function_">customRef</span>(<span class="function">(<span class="params">track,trigger</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">timer</span>:<span class="built_in">number</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">track</span>() <span class="comment">// 告诉Vue数据msg很重要，要对msg持续关注，一旦变化就更新</span></span><br><span class="line">        <span class="keyword">return</span> initValue</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          initValue = value</span><br><span class="line">          <span class="title function_">trigger</span>() <span class="comment">//通知Vue数据msg变化了</span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;) </span><br><span class="line">  <span class="keyword">return</span> &#123;msg&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件中使用：</p><h1>8. Vue3新组件</h1><h2 id="8-1-【Teleport】">8.1. 【Teleport】</h2><ul><li>什么是Teleport？—— Teleport 是一种能够将我们的<strong>组件html结构</strong>移动到指定位置的技术。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&#x27;body&#x27;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是一个弹窗<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是弹窗中的一些内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;isShow = false&quot;</span>&gt;</span>关闭弹窗<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="8-2-【Suspense】">8.2. 【Suspense】</h2><ul><li>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</li><li>使用步骤：<ul><li>异步引入组件</li><li>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></li></ul></li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent,<span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;./Child.vue&#x27;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">        &lt;h3&gt;我是App组件&lt;/h3&gt;</span><br><span class="line">        &lt;Suspense&gt;</span><br><span class="line">          &lt;template v-slot:default&gt;</span><br><span class="line">            &lt;Child/&gt;</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">          &lt;template v-slot:fallback&gt;</span><br><span class="line">            &lt;h3&gt;加载中.......&lt;/h3&gt;</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">        &lt;/Suspense&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="8-3-【全局API转移到应用对象】">8.3.【全局API转移到应用对象】</h2><ul><li><code>app.component</code></li><li><code>app.config</code></li><li><code>app.directive</code></li><li><code>app.mount</code></li><li><code>app.unmount</code></li><li><code>app.use</code></li></ul><h2 id="8-4-【其他】">8.4.【其他】</h2><ul><li><p>过渡类名 <code>v-enter</code> 修改为 <code>v-enter-from</code>、过渡类名 <code>v-leave</code> 修改为 <code>v-leave-from</code>。</p></li><li><p><code>keyCode</code> 作为 <code>v-on</code> 修饰符的支持。</p></li><li><p><code>v-model</code> 指令在组件上的使用已经被重新设计，替换掉了 <code>v-bind.sync。</code></p></li><li><p><code>v-if</code> 和 <code>v-for</code> 在同一个元素身上使用时的优先级发生了变化。</p></li><li><p>移除了<code>$on</code>、<code>$off</code> 和 <code>$once</code> 实例方法。</p></li><li><p>移除了过滤器 <code>filter</code>。</p></li><li><p>移除了<code>$children</code> 实例 <code>propert</code>。</p><p>…</p></li></ul>]]></content>
    
    
    <summary type="html">🍗本文汇总Vue3.0笔记基础教程 ，可作为文档进行查询</summary>
    
    
    
    <category term="前端笔记" scheme="https://www.cameliia.top/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Vue3" scheme="https://www.cameliia.top/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs基础教程</title>
    <link href="https://www.cameliia.top/posts/302.html"/>
    <id>https://www.cameliia.top/posts/302.html</id>
    <published>2023-03-20T10:19:03.000Z</published>
    <updated>2023-03-20T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Nodejs</h1><h2 id="介绍">介绍</h2><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，是一个应用程序。</p><p>官方网址 <a href="https://nodejs.org/en/">https://nodejs.org/en/</a>，中文站 <a href="http://nodejs.cn/">http://nodejs.cn/</a></p><h2 id="作用">作用</h2><ul><li>解析运行 JS 代码</li><li>操作系统资源，如内存、硬盘、网络</li></ul><h2 id="应用场景">应用场景</h2><ul><li>APP 接口服务</li><li>网页聊天室</li><li>动态网站, 个人博客, 论坛, 商城等</li><li>后端的Web服务，例如服务器端的请求（爬虫），代理请求（跨域）</li><li>前端项目打包(webpack, gulp)</li></ul><h2 id="使用">使用</h2><h3 id="下载安装">下载安装</h3><p>工具一定要到官方下载，历史版本下载 <a href="https://npm.taobao.org/mirrors/node/">https://npm.taobao.org/mirrors/node/</a></p><p>![img](file://D:/project/git/h5200622-code/day09/%E8%AF%BE%E5%A0%82/1-NodeJS/%E8%AF%BE%E4%BB%B6/nodejs/assets/20190329115938531.png?lastModify=1599473396)</p><p>Nodejs 的版本号奇数为开发版本，偶数为发布版本，<span style="color:red">我们选择偶数号的 LTS 版本（长期维护版本 long term service）</span></p><p>![1572676490692](file://D:/project/git/h5200622-code/day09/%E8%AF%BE%E5%A0%82/1-NodeJS/%E8%AF%BE%E4%BB%B6/nodejs/assets/1572676490692.png?lastModify=1599473415)</p><p>双击打开安装文件，一路下一步即可😎，默认的安装路径是 <code>C:\Program Files\nodejs</code></p><p>安装完成后，在 CMD 命令行窗口下运行 <code>node -v</code>，如显示版本号则证明安装成功，反之安装失败，重新安装。</p><p>![1572678177784](file://D:/project/git/h5200622-code/day09/%E8%AF%BE%E5%A0%82/1-NodeJS/%E8%AF%BE%E4%BB%B6/nodejs/assets/1572678177784.png?lastModify=1599473424)</p><h3 id="初体验">初体验</h3><h4 id="交互模式">交互模式</h4><p>在命令行下输入命令 <code>node</code>，这时进入 nodejs 的交互模式</p><p>![1572678681282](file://D:/project/git/h5200622-code/day09/%E8%AF%BE%E5%A0%82/1-NodeJS/%E8%AF%BE%E4%BB%B6/nodejs/assets/1572678681282.png?lastModify=1599473439)</p><h4 id="文件执行">文件执行</h4><p>创建文件 hello.js ，并写入代码 console.log(‘hello world’)，命令行运行 <code>node hello.js</code></p><p>快速启动命令行的方法</p><ul><li>在文件夹上方的路径中，直接输入 cmd 即可</li><li>使用 webstorm 和 vscode 自带的命令行窗口</li></ul><p>![1572680753835](file://D:/project/git/h5200622-code/day09/%E8%AF%BE%E5%A0%82/1-NodeJS/%E8%AF%BE%E4%BB%B6/nodejs/assets/1572680753835.png?lastModify=1599473449)</p><h4 id="VScode-插件运行">VScode 插件运行</h4><p>安装插件 『code Runner』, 文件右键 -&gt; run code</p><p>![1593782861500](file://D:/project/git/h5200622-code/day09/%E8%AF%BE%E5%A0%82/1-NodeJS/%E8%AF%BE%E4%BB%B6/nodejs/assets/1593782861500.png?lastModify=1599473460)</p><h4 id="注意">注意</h4><p><span style="color:red">在 nodejs 环境下，不能使用 BOM 和 DOM ，也没有全局对象 window和docu，全局对象的名字叫 global</span></p><h3 id="Buffer-缓冲器">Buffer(缓冲器)</h3><h4 id="介绍-2">介绍</h4><p>Buffer 是一个和数组类似的对象，不同是 Buffer 是专门用来保存二进制数据的</p><h4 id="特点">特点</h4><ul><li>大小固定：在创建时就确定了，且无法调整</li><li>性能较好：直接对计算机的内存进行操作</li><li>每个元素大小为 1 字节（byte）</li></ul><h4 id="操作">操作</h4><h5 id="创建-Buffer">创建 Buffer</h5><ul><li>直接创建 Buffer.alloc</li><li>不安全创建 Buffer.allocUnsafe</li><li>通过数组和字符串创建 Buffer.from</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个长度为10字节的Buffer</span></span><br><span class="line"><span class="keyword">let</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buf2 = <span class="title class_">Buffer</span>.<span class="title function_">allocUnsafe</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buf3 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&quot;iloveyou&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="Buffer-读取和写入">Buffer 读取和写入</h5><p>可以直接通过 <code>[]</code> 的方式对数据进行处理，可以使用 toString 方法将 Buffer 输出为字符串</p><ul><li>==[ ]== 对 buffer 进行读取和设置</li><li>==toString== 将 Buffer 转化为字符串</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buffer内容的读取和设置</span></span><br><span class="line"><span class="keyword">let</span> res = buf3[<span class="number">1</span>]; <span class="comment">// 结果为10进制的数字</span></span><br><span class="line"><span class="comment">// 获取字符串形式</span></span><br><span class="line"><span class="keyword">let</span> res2 = buf3.<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置内容</span></span><br><span class="line">buf3[<span class="number">0</span>] = <span class="number">120</span>;</span><br></pre></td></tr></table></figure><h5 id="关于溢出">关于溢出</h5><p>溢出的高位数据会舍弃</p><h5 id="关于中文">关于中文</h5><p>一个 UTF-8 的中文字符==大多数情况都是占 3 个字节==</p><h5 id="关于单位换算">关于单位换算</h5><p>1Bit 对应的是 1 个二进制位</p><p>8 Bit = 1 字节（Byte）</p><p>1024Byte = 1KB</p><p>1024KB = 1MB</p><p>1024MB = 1GB</p><p>1024GB = 1TB</p><p>平时所说的网速 10M 20M 100M 这里指的是 Bit ，所以理论下载速度 除以 8 才是正常的理解的下载速度</p><h3 id="文件系统-fs">文件系统 fs</h3><p>fs 全称为 file system，是 NodeJS 中的内置模块，可以对计算机中的文件进行增删改查等操作。</p><h5 id="文件写入">文件写入</h5><ul><li>简单写入<ul><li>==（引入模块）const fs = require(“fs”);==</li><li>fs.writeFile(filePath, data, [,options], callback);</li><li>fs.writeFileSync(file, data);</li><li>options 选项<ul><li><code>encoding</code> <strong>默认值:</strong> <code>'utf8'</code></li><li><code>mode</code><strong>默认值:</strong> <code>0o666</code></li><li><code>flag</code> <strong>默认值:</strong> <code>'w'</code></li></ul></li></ul></li><li>流式写入<ul><li>fs.createWriteStream(path[, options])<ul><li>path</li><li>options<ul><li>==flags==   <strong>默认值:</strong> <code>'w'</code></li><li><code>encoding </code><strong>默认值:</strong> <code>'utf8'</code></li><li><code>mode</code>   <strong>默认值:</strong> <code>0o666</code></li></ul></li><li>事件监听 open  close  eg:  ws.on(‘open’, function(){});</li></ul></li></ul></li></ul><h5 id="文件读取">文件读取</h5><ul><li><p>简单读取</p><ul><li>fs.readFile(file, function(err, data){})</li><li>fs.readFileSync(file)</li></ul></li><li><p>流式读取</p><ul><li>fs.createReadStream();</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定事件</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&quot;index.html&quot;</span>);</span><br><span class="line"><span class="comment">// 绑定事件,data是确定好的，不能更改</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>,<span class="function">(<span class="params">chunk</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(chunk.<span class="title function_">toString</span>());</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 关于小文件的读取-------readFile</span></span><br><span class="line"><span class="comment">// 关于大文件的读取-------createReadStream</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制文件</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&quot;index.html&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> ws = fs.<span class="title function_">createWriteStream</span>(<span class="string">&quot;index-副本.html&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种方法</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>,<span class="function"><span class="params">chunk</span>=&gt;</span>&#123;</span><br><span class="line">    ws.<span class="title function_">write</span>(chunk);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 第二种方法</span></span><br><span class="line">rs.<span class="title function_">pipe</span>(ws);</span><br></pre></td></tr></table></figure></li></ul><h5 id="文件删除">文件删除</h5><ul><li>fs.unlink(‘./test.log’, function(err){});</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs.unlink(路径,fun)</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line">fs.<span class="title function_">unlink</span>(<span class="string">&quot;bak.ini&quot;</span>,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;删除文件&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>fs.unlinkSync(‘./move.txt’);</li></ul><h5 id="移动文件-重命名">移动文件 + 重命名</h5><ul><li>fs.rename(‘./1.log’, ‘2.log’, function(err){})</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs.rename(oldname,newname,fun);</span></span><br><span class="line"><span class="comment">// 改名命令只能执行一次，再次执行时会报错 （no such file or directory）</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line">fs.<span class="title function_">rename</span>(<span class="string">&quot;index,html&quot;</span>,<span class="string">&quot;home.html&quot;</span>,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;改名成功&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动文件</span></span><br><span class="line">fs.<span class="title function_">rename</span>(<span class="string">&quot;index.html&quot;</span>,<span class="string">&quot;./file/home.html&quot;</span>,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;移动成功&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>fs.renameSync(‘1.log’,‘2.log’)</li></ul><h5 id="文件夹操作">文件夹操作</h5><ul><li>mkdir  创建文件夹<ul><li>path</li><li>options<ul><li>recursive 是否递归调用</li><li>mode  权限 默认为 0o777</li></ul></li><li>callback</li></ul></li><li>rmdir 删除文件夹</li><li>readdir  读取文件夹</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs.mkdir(path,[,option],callback)</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line">fs.<span class="title function_">mkdir</span>(<span class="string">&quot;./project&quot;</span>,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;创建文件夹成功&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除文件夹,如果文件夹非空，使用recursive来一步清空</span></span><br><span class="line">fs.<span class="title function_">rmdir</span>(<span class="string">&quot;./project&quot;</span>,&#123;<span class="attr">recursive</span>:<span class="literal">true</span>&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;删除文件夹成功&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件夹</span></span><br><span class="line">fs.<span class="title function_">readdir</span>(<span class="string">&quot;d:/&quot;</span>,<span class="function">(<span class="params">err,files</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(files);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="关于路径">关于路径</h5><ul><li>相对路径<ul><li>./index.html</li><li>…/images/logo.png</li><li>index.html</li></ul></li><li>绝对路径<ul><li>D:/www/share/day10/index.html (windows)</li><li>/home/root/index.html</li></ul></li></ul><p>fs模块中，参数路径如果为<strong>相对路径</strong>的话，参照物是==执行命令时所在的工作目录==</p><p>__dirname 全局变量，始终保存的是==当前文件所在目录的绝对路径==</p><h5 id="查看文件的状态-fs-stat">查看文件的状态( fs.stat() )</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line">fs.<span class="title function_">stat</span>(__dirname+<span class="string">&quot;index.html&quot;</span>,<span class="function">(<span class="params">err,stats</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(stats);</span><br><span class="line">   <span class="comment">// 检查目标资源是否为文件夹</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(stats.<span class="title function_">isDirectory</span>());</span><br><span class="line">   <span class="comment">// 检查目标资源是否为文件</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(stats.<span class="title function_">isFile</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="附录">附录</h2><h3 id="unicode-字符集">unicode 字符集</h3><ul><li><p><a href="https://www.tamasoft.co.jp/en/general-info/unicode.html">https://www.tamasoft.co.jp/en/general-info/unicode.html</a></p></li><li><p><a href="https://www.cnblogs.com/whiteyun/archive/2010/07/06/1772218.html">https://www.cnblogs.com/whiteyun/archive/2010/07/06/1772218.html</a></p></li></ul>]]></content>
    
    
    <summary type="html">🌮本文汇总Nodejs基础教程 ，可作为文档进行查询</summary>
    
    
    
    <category term="前端笔记" scheme="https://www.cameliia.top/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Nodejs" scheme="https://www.cameliia.top/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>React全家桶</title>
    <link href="https://www.cameliia.top/posts/400.html"/>
    <id>https://www.cameliia.top/posts/400.html</id>
    <published>2023-03-20T10:19:03.000Z</published>
    <updated>2023-03-20T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>React全家桶(技术栈)</h1><p>英文官网:<a href="https://reactjs.org">https://reactjs.org</a></p><h3 id="一、简介">一、简介</h3><h4 id="1-介绍描述">1.介绍描述</h4><p>​    ① 用于动态构建用户界面的 JavaScript 库(只关注于视图)</p><p>​    ②由Facebook开源</p><h4 id="2-特点">2.特点</h4><ul><li>声明式编码</li><li>组件化编码</li><li>React Native 编写原生应用</li><li>高效（优秀的Diffing算法）</li></ul><h4 id="3-高效原因">3.高效原因</h4><p>使用虚拟(virtual)DOM, 不总是直接操作页面真实DOM</p><p>DOM Diffing算法, 最小化页面重绘</p><h3 id="二、基本使用">二、基本使用</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 准备好一个容器，用于让react渲染用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入react核心库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入react-dom，用于支持react操作DOM --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入babel，用于将jsx转为js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下面一定要将javascript改为babel，含义是：让babel翻译script标签中的代码。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//1.创建虚拟DOM</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="variable constant_">VDOM</span> = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello,React<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span> <span class="comment">//此处一定不要写引号，因为VDOM不是字符串！！！</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//2.利用ReactDOM.render(虚拟DOM,容器) 方法将虚拟DOM插入指定容器</span></span></span><br><span class="line"><span class="language-javascript"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="variable constant_">VDOM</span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>))</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-创建虚拟DOM的两种方式">1.创建虚拟DOM的两种方式</h4><p>==①==</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">VDOM</span> = (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello,React<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>②（不推荐）</p><p>-----------------------React.createElement(标签名,{标签属性},标签体内容)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">VDOM</span> = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>,&#123;<span class="attr">id</span>:<span class="string">&#x27;title&#x27;</span>&#125;,<span class="string">&#x27;Hello,React&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-虚拟DOM与真实DOM">2.虚拟DOM与真实DOM</h4><ul><li>虚拟DOM的本质就是Object类型的一般对象。</li><li>虚拟DOM比较“轻”，真实DOM比较“重”，因为虚拟DOM是给react用的,无需那么多的属性。</li><li>我们编码时基本只需要操作react的虚拟DOM相关数据，虚拟DOM对象最终都会被React转换为真实的DOM。</li></ul><h4 id="span-style-color-red-3-jsx的语法规则-span"><span style='color:red'>3.jsx的语法规则</span></h4><ul><li><pre><code>    **&lt;span style='color:red'&gt;创建虚拟DOM时，不要用引号&lt;/span&gt;。**</code></pre></li><li><pre><code>   **标签中想混入js表达式，需要用&lt;span style='color:red'&gt; &#123;&#125;&lt;/span&gt;包裹。**</code></pre></li><li><pre><code>        **&lt;span style='color:red'&gt;根标签&lt;/span&gt;必须只有&lt;span style='color:red'&gt;一个&lt;/span&gt;**</code></pre></li><li><pre><code>        **标签必须&lt;span style='color:red'&gt;闭合&lt;/span&gt;**</code></pre></li><li><pre><code>        **&lt;span style='color:red'&gt;样式的类名&lt;/span&gt;，不要用class，必须用&lt;span style='color:red'&gt;className&lt;/span&gt;**</code></pre></li><li><pre><code>         **&lt;span style='color:red'&gt;内联的样式&lt;/span&gt;要用 &lt;span style='color:red'&gt;style=&#123;&#123;&#125;&#125;&lt;/span&gt;形式去写**</code></pre></li><li><pre><code>         **标签可以随意的编写：**</code></pre></li></ul><p>​                  <strong>(1).若标签首字母是【小写】的，则react会尝试将当前的jsx标签对应成一个html标签</strong></p><p>​                          <strong>若对应成了，直接渲染，展示。</strong></p><p>​                          <strong>若无法对应，直接报错！</strong></p><p>​                  <strong>(2).若标签首字母是【大写】的，则react会查找Haha组件的定义的位置</strong></p><p>​                          <strong>若找见了，直接渲染Haha组件</strong></p><p>​                          <strong>若未找见，报错(Haha is not defined)</strong></p><h4 id="4-区分js语句与js表达式">4.区分js语句与js表达式</h4><p>​       ①表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方下面这些都是表达式：<br>​(1). a<br>​(2). a+b<br>​(3). demo(1)<br>​(4). arr.map()<br>​(5). function test () {}<br>​        ②语句(代码)：下面这些都是语句(代码)：<br>​(1).if(){}<br>​(2).for(){}<br>​(3).switch(){case:xxxx}</p><h4 id="备注：">备注：</h4><p>==①数组（Array）.map( )方法==：</p><p>​                   用来生成 / 创建一个新数组。<br>​                           其结果是 该数组中的每个元素 调用一次提供的函数后的返回值。<br>​                           map 不修改原数组本身</p><p>​                   所以map方法必须有返回值，如果没有return，那么新数组的每一项都为undefined，数组的个数与原数组一样</p><p><span style='color:red; font-size:18px; font-weight:700'> ②react可以自动遍历数组，但是不可以遍历对象</span></p><h3 id="三、模块与组件、模块化与组件化">三、模块与组件、模块化与组件化</h3><h4 id="1-模块与模块化">1.模块与模块化</h4><ul><li><p>理解：向外提供特定功能的js程序, 一般就是一个js文件</p></li><li><p>为什么要拆成模块：随着业务逻辑增加，代码越来越多且复杂。</p></li><li><p>作用：复用js, 简化js的编写, 提高js运行效率</p><p>==当应用的js都以模块来编写的, 这个应用就是一个模块化的应用==</p></li></ul><h4 id="2-组件与组件化">2.组件与组件化</h4><ul><li><p>理解：用来实现局部功能效果的代码和资源的集合(html/css/js/image等等)</p></li><li><p>为什么要用组件： 一个界面的功能更复杂</p></li><li><p>作用：复用编码, 简化项目编码, 提高运行效率</p><p>==当应用是以多组件的方式实现, 这个应用就是一个组件化的应用==</p></li></ul><h4 id="3-组件">3.组件</h4><p><span style='color:red'><strong>①函数式组件</strong></span></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/babel&quot;</span>&gt; </span><br><span class="line"><span class="comment">//1.定义组件(函数式组件)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>)&#123;<span class="comment">//函数式组件 函数名字开头大写</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">//此处的this是undefined，因为经过babel的编译后，开启了严格模式。</span></span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是用函数定义的组件（适用于【简单组件】的定义）<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.渲染组件到页面 </span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">MyComponent</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>))</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  执行了ReactDOM.render后，发生了什么？</span></span><br><span class="line"><span class="comment">  1.React发现了&lt;MyComponent/&gt;标签，去寻找MyComponent组件定义的位置，发现MyComponent是用函数定义的。</span></span><br><span class="line"><span class="comment">  2.React调用MyComponent并获取MyComponent返回的虚拟DOM，随后转为真实DOM，随后渲染到页面。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><span style='color:red'><strong>②类式组件</strong></span></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/babel&quot;</span>&gt; </span><br><span class="line"><span class="comment">//定义组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line"><span class="comment">//render是放在哪里的？ —————— MyComponent的原型对象上，是给MyComponent的实例对象用的。</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">//MyComponent的实例对象 &lt;==&gt; MyComponent组件实例对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是用类定义的组件（适用于【复杂组件】的定义）<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//渲染组件到页面</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">MyComponent</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>))</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  执行了ReactDOM.render后，发生了什么？</span></span><br><span class="line"><span class="comment">  1.React发现了&lt;MyComponent/&gt;标签，去寻找MyComponent组件定义的位置，发现MyComponent是用类定义的。</span></span><br><span class="line"><span class="comment">  2.React new了一个MyComponent实例对象--m</span></span><br><span class="line"><span class="comment">  3.通过m调用到了MyComponent原型上的render方法，并获取到了返回的虚拟DOM，随后转为真实DOM，放在页面。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="4-组件实例的三大核心属性">4.组件实例的三大核心属性</h4><p>①state：</p><p>state是组件对象最重要的属性, 值是对象(可以包含多个key-value的组合)</p><p>state(状态机)通过更新组件的state来更新对应的页面显示(重新渲染组件)。</p><p>基本使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/babel&quot;</span>&gt; </span><br><span class="line"><span class="comment">//1.定义组件----类式组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weather</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line"><span class="comment">//构造器调用几次？-------- 看你组件用几次</span></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line"><span class="variable language_">super</span>(props)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">isHot</span>:<span class="literal">true</span>,<span class="attr">wind</span>:<span class="string">&#x27;微风&#x27;</span>&#125; <span class="comment">//初始化状态,isHot用于标识天气热不热</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">changeWeather</span> = <span class="variable language_">this</span>.<span class="property">changeWeather</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>) <span class="comment">//解决this指向问题</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//changeWeather调用几次？-------- 看你点几次</span></span><br><span class="line"><span class="title function_">changeWeather</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">//若构造器中不做处理，那么下面的this是undefined，因为changeWeather不是通过实例调用的，而是作为点击的回调去使用，且类中的方法自动开启了严格模式。</span></span><br><span class="line"><span class="comment">//console.log(&#x27;changeWeather的this是&#x27;,this); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//严重注意：状态(state)中的值是不能直接修改的！！！！下面这一行就是直接修改</span></span><br><span class="line"><span class="comment">//this.state.isHot = true</span></span><br><span class="line">                    </span><br><span class="line"><span class="comment">//获取原来的state中的isHot值</span></span><br><span class="line"><span class="keyword">const</span> &#123;isHot&#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line"><span class="comment">//更新状态</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">isHot</span>:!isHot&#125;) <span class="comment">//此处更新状态是一个合并的动作，不是替换</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//render调几次？--------- 1+n次（n是更新状态的次数）</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">                    <span class="comment">//React中的绑定单击事件是onClick其中C大写</span></span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span>今天天气很&#123;this.state.isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;，&#123;this.state.wind&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.渲染组件</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Weather</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>==简写模式==</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/babel&quot;</span>&gt; </span><br><span class="line"><span class="comment">//1.定义组件----类式组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weather</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">state = &#123;<span class="attr">isHot</span>:<span class="literal">true</span>,<span class="attr">wind</span>:<span class="string">&#x27;微风23&#x27;</span>&#125; <span class="comment">//初始化状态</span></span><br><span class="line"><span class="comment">//事件的回调都需要写成赋值语句+箭头函数的形式</span></span><br><span class="line">changeWeather = <span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;changeWeather&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;isHot&#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">isHot</span>:!isHot&#125;)</span><br><span class="line">&#125;</span><br><span class="line">render ()&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">今天天气很&#123;this.state.isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;，&#123;this.state.wind&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.渲染组件</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Weather</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="注意">注意:</h5><p>​                          <span style='color:red'> 组件中render方法中的this为组件实例对象</span></p><p>​                           <span style='color:red'>  组件自定义的方法中this为undefined，如何解决？</span><br>​                                     <span style='color:red'>a)强制绑定this: 通过函数对象的bind()</span><br>​                                     <span style='color:red'>b)箭头函数:通过箭头函数的this由外层作用域的this决定这一特性</span></p><p>​                             <span style='color:red'>状态数据，不能直接修改或更新 需要通过setState({})</span></p><p>②props：</p><p>​     每个组件对象都会有props(properties的简写)属性，值是对象(包括函数式组件)</p><p>​     组件标签的所有属性都保存在props中</p><p>​     ==通过标签属性从组件外向组件内传递变化的数据==</p><p>基本使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/babel&quot;</span>&gt; </span><br><span class="line"><span class="comment">//定义组件(类)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">const</span> &#123;name,age,sex&#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>年龄：&#123;age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//渲染组件</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&quot;tom&quot;</span> <span class="attr">sex</span>=<span class="string">&quot;女&quot;</span> <span class="attr">age</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>))</span><br><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;程老师&#x27;</span>,</span><br><span class="line"><span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>,</span><br><span class="line"><span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面的...p1，并不是原生js里的&#123;...p1&#125;,babel+react环境就可以让展开运算符展开一个对象，但是仅仅适用于传递标签属性！！</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> &#123;<span class="attr">...p1</span>&#125;/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test2&#x27;</span>))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>对props中的属性值进行类型限制和必要性限制:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入prop-types，用于制定对props限制的具体规则 </span></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;../js/prop-types.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//定义组件(类)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//对传给Person组件的props进行类型的限制</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">static</span> propTypes = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">name</span>:<span class="title class_">PropTypes</span>.<span class="property">string</span>, <span class="comment">//限制name必须为字符串类型</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">sex</span>:<span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,<span class="comment">//限制sex必须为字符串类型，且是必要属性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">age</span>:<span class="title class_">PropTypes</span>.<span class="property">number</span>,<span class="comment">//限制age必须为数值类型</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">address</span>:<span class="title class_">PropTypes</span>.<span class="property">string</span>, <span class="comment">//限制address必须为字符串类型</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//对传给Person组件的props进行默认值的设置</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">static</span> defaultProps = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">address</span>:<span class="string">&#x27;中国&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>函数组件的props属性（了解）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/babel&quot;</span>&gt; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">props</span>)&#123;</span><br><span class="line"><span class="keyword">const</span> &#123;name,age,sex,address&#125; = props</span><br><span class="line"><span class="comment">//对传给Person组件的props进行类型的限制</span></span><br><span class="line"><span class="keyword">return</span>(</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>年龄：&#123;age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>地址：&#123;address&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line"><span class="attr">name</span>:<span class="title class_">PropTypes</span>.<span class="property">string</span>, <span class="comment">//限制name必须为字符串类型</span></span><br><span class="line"><span class="attr">sex</span>:<span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,<span class="comment">//限制sex必须为字符串类型，且是必要属性</span></span><br><span class="line"><span class="attr">age</span>:<span class="title class_">PropTypes</span>.<span class="property">number</span>,<span class="comment">//限制age必须为数值类型</span></span><br><span class="line"><span class="attr">address</span>:<span class="title class_">PropTypes</span>.<span class="property">string</span>, <span class="comment">//限制address必须为字符串类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对传给Person组件的props进行默认值的设置</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">defaultProps</span> = &#123;</span><br><span class="line"><span class="attr">address</span>:<span class="string">&#x27;中国&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="备注：-2">备注：</h4><p>​     ①script type=“text/babel” 经过==babel==编译的 开启严格模式 ==普通函数内部的this指向由window变为undefined==</p><p>​     ② ES6==类(class)==中所有方法自动开启了严格模式 ==普通函数内部的this指向由window变为undefined==</p><p>​     ③扩展运算符(…)无法展开一个对象，但可以通过 const newObject ={…object} 进行对象复制</p>]]></content>
    
    
    <summary type="html">🥙本文汇总React全家桶 ，可作为文档进行查询</summary>
    
    
    
    <category term="前端笔记" scheme="https://www.cameliia.top/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="React" scheme="https://www.cameliia.top/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Promise基础教程</title>
    <link href="https://www.cameliia.top/posts/303.html"/>
    <id>https://www.cameliia.top/posts/303.html</id>
    <published>2023-03-20T10:19:03.000Z</published>
    <updated>2023-03-20T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Promise</h1><h2 id="1-Promise的介绍">1. Promise的介绍</h2><ul><li><p>它是一门新的技术（ES6中引入），是JS中进行异步编程的新解决方法，解决了就方案中的回调地狱问题。</p></li><li><p>在promise的语法上来看，<strong>它是一个构造函数</strong>；promise对象用来封装一个异步操作并可以获取成功或失败的结果值。</p></li><li><p>状态改变上分为两种情况：且一个promise对象的状态只能改变一次</p><p>​pending ----&gt; resolved</p><p>​pending ----&gt; rejected</p></li><li><p>promise的基本流程：如下图所示</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200915182146260.png" alt="image-20200915182146260"></p></li></ul><h2 id="2-Promise的基本使用">2. Promise的基本使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建promise对象，刚创建的对象状态为pending，指定执行器函数</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 在执行器函数中启动异步任务</span></span><br><span class="line">    fs.<span class="title function_">readFile</span>(<span class="string">&quot;./index.html&quot;</span>,<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 如果状态为失败，就调用reject()</span></span><br><span class="line">        <span class="keyword">if</span> (err) <span class="title function_">reject</span>(err);</span><br><span class="line">        <span class="comment">// 如果状态为成功，就调用resolve()</span></span><br><span class="line">        <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// promise对象的状态改变后，就调用then方法</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-Promise中的API">3. Promise中的API</h2><h3 id="1-实例对象的方法">1. 实例对象的方法</h3><ul><li><p>Promise构造函数，new Promise（excutor{ }），执行器函数（同步）</p></li><li><p>Promise.prototype.then(onResolved, onRejected) ------ 成功的回调函数，失败的回调函数（异步）</p></li><li><p>Promise.prototype.catch(onRejected），专门用来解决失败的回调函数（异步）</p><p>.then()方法中可以只传入成功的回调函数，失败的回调都交给catch来解决</p></li></ul><h3 id="2-函数对象的方法">2.   函数对象的方法</h3><ul><li>Promise.resolve() 接收一个参数，返回Promise对象<ol><li>如果传入的参数是非Promise类型的数据，那么返回的这个promise对象的状态是resolve，值就是传入的参数的值</li><li>如果传入的参数是一个Promise对象，那么传入的promise对象的状态就决定了返回的这个promise对象的状态，值就是里面的promise对象中的值</li><li>作用：快速对数据进行包裹，进行promise的转换，方便后面的操作。</li></ol></li><li>Promise.reject()接收一个参数，始终是返回一个失败的promise对象<br>1. 无论传入的参数是什么，结果都是一个失败状态的Promise对象，且失败的值就是传入的参数的值。</li><li>Promise.all()，接收的参数是一个数组，且每个值都是一个Promise对象，返回的结果也是一个promise对象<ol><li>如果数组中所有对象的状态都为成功，那么返回的promise对象的状态为成功，成功的值和数组中的顺序一一对应；如果有一个为失败，那么返回的promise对象的状态就为失败，且失败的值就是那么失败的对象的值，如果几个值都失败了，那么谁先失败谁就决定结果。</li></ol></li><li>Promise.race() 接收的参数是一个数组，且每个值都是一个Promise对象，返回的结果也是一个promise对象 ，结果由最先改变状态的那个promise决定。</li></ul><h2 id="4-async-await-（回调地狱的终极解决方案）">4. async / await （回调地狱的终极解决方案）</h2><p>async函数是Generator函数的语法糖。但是相比Generator而言，async不需要调用next方法才能执行，它自带执行器（await）。</p><ul><li><p>语义</p><p>async表示函数里有异步操作，await表示紧跟在后的表达式需要<strong>等待结果</strong></p></li><li><p>await的返回值</p><p>await后面，可以跟Promise对象（异步）或原始类型的值（Number，String，Boolean）（同步）; 如果它的返回值是Promise对象，就可以使用then指定下一步的操作；如果是非Promise对象，就返回相应的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>; <span class="comment">// 相当于return 123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function"><span class="params">v</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(v)); <span class="comment">// 123</span></span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果await后面的Promise是reject状态，整个async函数会中断执行。这时需要catch来接收reject的参数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">v</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(v)&#125;)</span><br><span class="line">   .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(e)&#125;) <span class="comment">//出错了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ********************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不希望第一异步操作失败去影响第二个异步操作，可以使用try...catch..来处理</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;成功执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function"><span class="params">v</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(v)&#125;) <span class="comment">// 成功执行了</span></span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(e)&#125;);</span><br></pre></td></tr></table></figure></li><li><p>async函数内部如果有return的值，会成为then方法的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello async&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function"><span class="params">v</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(v)&#125;); <span class="comment">// hello async</span></span><br></pre></td></tr></table></figure></li><li><p>async后面的Promise对象的状态变化</p><p>由于async函数返回的都是Promise对象，因此，必须等到async内部所有的await命令后面的Promise对象都执行完，才会发生状态变化；除非遇到return语句或者抛出错误。（也就是说，只有当async函数内部的异步操作都执行完，才会执行then方法的回调函数）。</p></li></ul><h2 id="5-promise中的几个关键问题">5. promise中的几个关键问题</h2><ol><li><p>如何改变promise的状态</p><ul><li>resolve 函数pending ----&gt; resolve</li><li>reject 函数       pending ----&gt; reject</li><li>抛出异常 throw   pending ----&gt; reject</li></ul><ol start="2"><li>一个promise指定多个回调函数（也就是调用多个then或catch方法），都会调用吗？</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;成功&quot;</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">alert</span>(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>只要promise的状态改变了，那么<strong>对应的回调都会运行</strong></li></ul><ol start="3"><li>改变promise的状态和指定回调函数那个先执行? (都有可能)</li></ol><p>这两个的执行顺序主要是由执行器函数内部封装的任务决定的，如果封装的是同步任务，那么promise对象的状态先改变，指定回调后执行；如果封装的是异步任务，那么情况就反过来了；</p><p>大多数情况下，都是指定回调在前（then调用），改变状态在后（resolve，reject）；</p><ol start="4"><li>promise.then()的返回的新promise对象的结果由什么决定？</li></ol><p>由then指定的回调函数执行的结果决定</p><ul><li>抛出异常，新promise的状态变为rejected，reason为抛出的异常</li><li>返回的是非promise的任意数据，新promise的状态变为resolved，value为返回的值</li><li>返回的是另一个新的promise，这个promise的状态就会成为then返回的那个promise对象的状态</li></ul><ol start="5"><li>使用then方法的链式调用来串联多个操作任务，当使用了then的链式调用，可以在最后再进行失败的回调，这时利用了promise的异常穿透原理；想要中断链式调用时，就在回调函数中返回一个pending状态的promise对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;Ok&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value,<span class="number">1111</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value,<span class="number">2222</span>);</span><br><span class="line">    <span class="comment">// 如果不想执行到3333，就返回一个pending状态的promise对象</span></span><br><span class="line">    <span class="comment">// return new Promise(()=&gt;&#123;&#125;);</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value,<span class="number">3333</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason,<span class="number">4444</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为:</span></span><br><span class="line"><span class="comment"> ok 1111</span></span><br><span class="line"><span class="comment"> undefined 222   结果为undefined是因为前一个then没有返回值，默认为undefined</span></span><br><span class="line"><span class="comment"> undefined 333 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="6-JS异步之红队列和微队列">6. JS异步之红队列和微队列</h2><h3 id="1-原理图">1. 原理图</h3><p><img src="https://img-blog.csdnimg.cn/20191111155015676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDAxMzgxNw==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="2-JS中用来存储待执行回调函数的队列包含2个：">2. JS中用来存储待执行回调函数的队列包含2个：</h3><p>宏队列：用来保存待执行的宏任务（回调）</p><pre><code>* 定时器的回调* DOM事件回调* AJAX回调</code></pre><p>微队列：用来保存待执行的微任务（回调）</p><ul><li>promise回调</li><li>MutationObserver回调</li></ul><p>JS的执行顺序：先执行同步任务，碰到异步任务就将其放入对应的异步任务队列中（宏队列&amp;微队列）；同步任务执行完成后，每次准备执行宏队列之前，先检查微队列中是否有任务在等待执行，有就先执行微队列的任务；最后再执行宏队列中的待执行任务。</p><h2 id="7-promise的相关题目">7. promise的相关题目</h2><ul><li><p>第一题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 3 2 4 1</span></span><br></pre></td></tr></table></figure></li><li><p>第二题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 2 5 3 4 1</span></span><br></pre></td></tr></table></figure></li><li><p>第三题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">first</span> = (<span class="params"></span>) =&gt; (<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>)</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">6</span>)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line">    p.<span class="title function_">then</span>(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(arg)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;))</span><br><span class="line"><span class="title function_">first</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 3 7 4 1 2 5</span></span><br></pre></td></tr></table></figure></li><li><p>第四题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;        </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">      <span class="title function_">resolve</span>()</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;      </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;       </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;6&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;7&quot;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;         </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;8&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// 1 7 2 3 8 4 6 5 0</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">🥪本文汇总Promise基础教程 ，可作为文档进行查询</summary>
    
    
    
    <category term="前端笔记" scheme="https://www.cameliia.top/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Promise" scheme="https://www.cameliia.top/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>webpack配置教程</title>
    <link href="https://www.cameliia.top/posts/309.html"/>
    <id>https://www.cameliia.top/posts/309.html</id>
    <published>2023-03-20T10:19:03.000Z</published>
    <updated>2023-03-20T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="webpack快速入门教程">webpack快速入门教程</h2><h3 id="1、webpack-介绍">1、webpack 介绍</h3><ul><li>什么是webpack<a href="https://www.webpackjs.com/">https://www.webpackjs.com/</a><ul><li>Webpack是一个模块打包器(bundler)。</li><li>在Webpack看来, 前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理</li><li>它将根据模块的依赖关系进行静态分析，生成对应的静态资源</li></ul></li><li>五个核心概念<ul><li>Entry：入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始</li><li>Output：output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件</li><li>Loader：loader 让 webpack 能够去处理那些非 JavaScript 文件</li><li>Plugins：插件则可以用于执行范围更广的任务。例如：打包优化、压缩，</li><li>Mode：模式，有生产模式 production 和开发模式 development</li></ul></li><li>理解 Loader<ul><li>Webpack 本身只能加载 JS/JSON 模块，如果要加载其他类型的文件(模块)，就需要使用对应的loader 进行转换/加载</li><li>Loader 本身也是运行在 node.js 环境中的 JavaScript 模块</li><li>loader 一般以 xxx-loader 的方式命名，xxx 代表了这个 loader 要做的转换功能，比如 less-loader。</li></ul></li><li>理解 Plugins<ul><li>插件可以完成一些loader不能完成的功能。</li><li>插件的使用一般是在 webpack 的配置信息 plugins 选项中指定。</li></ul></li><li>配置文件(默认)<ul><li>webpack.config.js : 是一个node模块，返回一个 json 格式的配置信息对象</li></ul></li></ul><h3 id="2、webpack-安装">2、webpack 安装</h3><ul><li>npm 初始化</li><li>安装 webpack<ul><li>npm install webpack webpack-cli -g  //全局安装,作为指令使用</li><li>npm install webpack webpack-cli -D //本地安装,作为本地依赖使用</li></ul></li></ul><h3 id="3、编译打包应用">3、编译打包应用</h3><ul><li><p>创建js文件</p><ul><li>src/js/app.js</li><li>src/js/module1.js</li><li>src/js/module2.js</li><li>src/js/module3.js</li></ul></li><li><p>创建json文件</p><ul><li>src/json/data.json</li></ul></li><li><p>创建主页面:</p><ul><li>src/index.html</li></ul></li><li><p>运行指令</p><ul><li><p>开发配置指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack src/js/app.js -o build/js/app.js --mode=development</span><br></pre></td></tr></table></figure><blockquote><p>webpack 能够编译打包 js 和 json 文件，并且能将 es6 的模块化语法转换成浏览器能识别的语法</p></blockquote></li><li><p>生产配置指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack src/js/app.js -o build/js/app.js --mode=production</span><br></pre></td></tr></table></figure><blockquote><p>production 配置能够压缩代码</p></blockquote></li></ul></li><li><p>结论：</p><ul><li>webpack能够编译打包 js 和 json 文件</li><li>能将 es6 的模块化语法进行代码打包</li><li>能压缩代码</li></ul></li><li><p>缺点：</p><ul><li>不能编译打包 css、img 等文件</li><li>不能将 js 的 es6 基本语法转化为 es5 语法</li><li>打包命令复杂</li></ul></li></ul><h3 id="4、使用-webpack-配置文件">4、使用 webpack 配置文件</h3><ul><li>目的：在项目根目录定义配置文件，通过自定义配置文件，还原以上功能</li><li>文件名称：webpack.config.js</li><li>文件内容：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//node内置核心模块，用来设置路径。</span></span><br><span class="line">   <span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line">   <span class="comment">//只能使用 CommonJS 规范暴露</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 入口文件配置</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/js/app.js&#x27;</span>,   </span><br><span class="line">  <span class="comment">// 输出配置</span></span><br><span class="line">  <span class="attr">output</span>: &#123;         </span><br><span class="line">       <span class="comment">// 输出文件名</span></span><br><span class="line">       <span class="attr">filename</span>: <span class="string">&#x27;./js/built.js&#x27;</span>,    </span><br><span class="line">       <span class="comment">//输出文件路径配置</span></span><br><span class="line">       <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>)   </span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="comment">// development 与 production 开发环境(二选一)</span></span><br><span class="line">     <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>   </span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure></li><li>运行指令： webpack</li></ul><h3 id="5、打包-less-资源">5、打包 less 资源</h3><p>less 文件 webpack 不能解析，需要借助 loader 编译解析，使用步骤如下：</p><ol><li>创建less文件</li></ol><ul><li>src/css/test1.less</li><li>src/css/test2.less</li></ul><ol start="2"><li>入口app.js文件</li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入两个 less 文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../css/test1.less&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../css/test2.less&#x27;</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>安装 loader</li></ol>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-loader style-loader less-loader less --save-dev </span><br></pre></td></tr></table></figure><ol start="4"><li><p>webpack.config.js 配置 loader</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="attr">module</span>:&#123;</span><br><span class="line">        <span class="attr">rules</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/\.less$/</span>,  <span class="comment">// 检查文件是否以.less结尾（检查是否是less文件）</span></span><br><span class="line">                   <span class="attr">use</span>:[<span class="comment">// 数组中loader执行是从下到上，从右到左顺序执行</span></span><br><span class="line">                       <span class="string">&#x27;style-loader&#x27;</span>, <span class="comment">// 创建style标签，添加上js中的css代码</span></span><br><span class="line">                       <span class="string">&#x27;css-loader&#x27;</span>, <span class="comment">// 将css以commonjs方式整合到js文件中</span></span><br><span class="line">                       <span class="string">&#x27;less-loader&#x27;</span> <span class="comment">// 将less文件解析成css文件</span></span><br><span class="line">                   ]</span><br><span class="line">               &#125;</span><br><span class="line">           ]</span><br><span class="line">       &#125;,</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>运行指令</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">webpack</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="6、JS-语法检查">6、JS 语法检查</h3><p>ESLint（<a href="https://eslint.bootcss.com/">https://eslint.bootcss.com/</a>） 能对 JS 基本语法错误/隐患进行提前检查，使用步骤</p><ol><li><p>安装loader</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint-loader eslint --save-dev</span><br></pre></td></tr></table></figure><blockquote><p>eslint 是语法检查的包</p><p>eslint-loader 是 eslint 在 webpack 中的 loader 包</p></blockquote></li><li><p>webpack.config.js 配置 loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,                  <span class="comment">//只检测js文件</span></span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,        <span class="comment">//排除node_modules文件夹</span></span><br><span class="line">                <span class="attr">enforce</span>: <span class="string">&quot;pre&quot;</span>,                 <span class="comment">//提前加载使用</span></span><br><span class="line">                <span class="attr">use</span>: &#123;                          </span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&quot;eslint-loader&quot;</span><span class="comment">//使用eslint-loader解析</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建 <code>.eslintrc.js</code> 文件</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="string">&quot;parserOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;ecmaVersion&quot;</span>: <span class="number">6</span>, <span class="comment">// 支持es6</span></span><br><span class="line">        <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;module&quot;</span><span class="comment">// 使用es6模块化</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;env&quot;</span>: &#123; <span class="comment">// 设置环境</span></span><br><span class="line">        <span class="string">&quot;browser&quot;</span>: <span class="literal">true</span>,   <span class="comment">// 支持浏览器环境： 能够使用window上的全局变量</span></span><br><span class="line">        <span class="string">&quot;node&quot;</span>: <span class="literal">true</span>       <span class="comment">// 支持服务器环境:  能够使用node上global的全局变量</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;globals&quot;</span>: &#123;<span class="comment">// 声明使用的全局变量, 这样即使没有定义也不会报错了</span></span><br><span class="line">        <span class="string">&quot;$&quot;</span>: <span class="string">&quot;readonly&quot;</span><span class="comment">// $ 不允许重写变量</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;rules&quot;</span>: &#123;  <span class="comment">// eslint检查的规则  0 忽略 1 警告 2 错误</span></span><br><span class="line">        <span class="string">&quot;no-console&quot;</span>: <span class="number">0</span>, <span class="comment">// 不允许出现 console</span></span><br><span class="line">        <span class="string">&quot;eqeqeq&quot;</span>: <span class="number">0</span>,<span class="comment">// 必须使用 === </span></span><br><span class="line">        <span class="string">&quot;no-alert&quot;</span>: <span class="number">0</span> <span class="comment">// 不能使用 alert</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;extends&quot;</span>: <span class="string">&quot;eslint:recommended&quot;</span> <span class="comment">// 使用eslint推荐的默认规则</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">webpack</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="7、JS-语法转换">7、JS 语法转换</h3><p>借助 Babel 可以将浏览器不能识别的新语法（ES6, ES7）转换成原来识别的旧语法（ES5），浏览器兼容性处理</p><ol><li><p>安装loader</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm install babel-loader @babel/core @babel/preset-env --save-dev</span></span><br></pre></td></tr></table></figure><blockquote><p>@babel/core  是 babel 的核心库</p><p>@babel/preset-env  是 babel 的预设的工具包，默认可以将所有最新的语法转为为 ES5</p><p>babel-loader   是 babel 在 webpack 中的 loader 包</p></blockquote></li><li><p>配置loader</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      <span class="attr">use</span>: &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行指令</p></li></ol>  <figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">webpack</span></span><br></pre></td></tr></table></figure><h3 id="8、JS-兼容性处理">8、JS 兼容性处理</h3><p>Polyfill 是一块代码（通常是 Web 上的 JavaScript），用来为旧浏览器提供它没有原生支持的较新的功能</p><ol><li><p>安装 polyfill</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm install @babel/polyfill</span></span><br></pre></td></tr></table></figure></li><li><p>app.js（入口文件）引入</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@babel/polyfill&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>解决 babel 只能转换语法的问题(如：let/const/解构赋值…)，引入polyfill可以转换高级语法(如:Promise…)</p></blockquote><h3 id="9、打包样式文件中的图片资源">9、打包样式文件中的图片资源</h3><p>图片文件 webpack 不能解析，需要借助 url-loader编译解析</p><ol><li>两张资源图片:</li></ol><ul><li>小图, 小于8kb: src/images/vue.png</li><li>大图, 大于8kb: src/images/react.jpg</li></ul><ol start="2"><li><p>在 less 文件中通过背景图的方式引入图片</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.react</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;../images/react.png&#x27;</span>) no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.vue</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;../images/vue.png&#x27;</span>) no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>安装 loader</p></li></ol>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm install file-loader url-loader --save-dev</span> </span><br></pre></td></tr></table></figure><blockquote><p>补充：url-loader是对象file-loader的上层封装，使用时需配合file-loader使用。</p></blockquote><ol start="4"><li><p>webpack.config.js 配置 loader</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            .</span><br><span class="line">            .</span><br><span class="line">    .</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">                <span class="attr">use</span>: &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="attr">limit</span>: <span class="number">8192</span>,               <span class="comment">// 8kb以下的图片会 base64 处理</span></span><br><span class="line">                        <span class="attr">outputPath</span>: <span class="string">&#x27;images&#x27;</span>,           <span class="comment">// 文件本地输出路径</span></span><br><span class="line">                        <span class="attr">publicPath</span>: <span class="string">&#x27;../build/images&#x27;</span>,   <span class="comment">// 图片的url路径</span></span><br><span class="line">                        <span class="attr">name</span>: <span class="string">&#x27;[hash:8].[ext]&#x27;</span>,         <span class="comment">// 修改文件名称和后缀 </span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行指令</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">webpack</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="10、打包-HTML-文件">10、打包 HTML 文件</h3><p>HTML 文件不能直接被 webpack 解析，需要借助 <code>HtmlWebpackPlugin</code> 插件编译解析</p><ol><li><p>在 src 目录下创建 index.html 文件，==注意不要在 HTML 中引入任何 CSS 和  JS  文件==</p></li><li><p>安装插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm install html-webpack-plugin --save-dev</span> </span><br></pre></td></tr></table></figure></li><li><p>webpack.config.js 修改配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插件都需要手动引入</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>, <span class="comment">// 设置要编译的 HTML 源文件路径</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行指令</p> <figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">webpack</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>src 目录就是源文件目录，所有的代码和资源都保存在该目录，index.html 也是如此</p></blockquote><h3 id="11、打包-HTML-中图片资源">11、打包 HTML 中图片资源</h3><p>url-loader 只能处理 JS 和 CSS 中引入的图片，无法处理 HTML 中的 img 图片，需要 html-loader 处理。</p><ol><li>src/index.html 添加 img 标签</li></ol>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../social/images/sun.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>安装loader</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm install html-loader --save-dev</span> </span><br></pre></td></tr></table></figure></li><li><p>配置loader</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            .</span><br><span class="line">            .</span><br><span class="line">            .</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.(html)$/</span>,</span><br><span class="line">                <span class="attr">use</span>: &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&#x27;html-loader&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行指令</p> <figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">webpack</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="12、打包字体资源">12、打包字体资源</h3><p>字体文件需要借助 file-loader 编译解析，以 iconfont 为例，下载一个项目</p><ol><li>将字体文件保存在 <code>src/fonts</code> 目录下</li></ol><ul><li>src/fonts/iconfont.eot</li><li>src/fonts/iconfont.svg</li><li>src/fonts/iconfont.ttf</li><li>src/fonts/iconfont.woff</li><li>src/fonts/iconfont.woff2</li></ul><ol start="2"><li><p>创建 src/css/iconfont.less 并将 iconfont 的 css 样式粘到 less 文件中，并修改字体路径</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;iconfont&#x27;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;../fonts/iconfont.eot&#x27;</span>);</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;../fonts/iconfont.eot?#iefix&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;embedded-opentype&#x27;</span>),</span><br><span class="line">      <span class="built_in">url</span>(<span class="string">&#x27;../fonts/iconfont.woff2&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>),</span><br><span class="line">      <span class="built_in">url</span>(<span class="string">&#x27;../fonts/iconfont.woff&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>),</span><br><span class="line">      <span class="built_in">url</span>(<span class="string">&#x27;../fonts/iconfont.ttf&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>),</span><br><span class="line">      <span class="built_in">url</span>(<span class="string">&#x27;../fonts/iconfont.svg#iconfont&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;svg&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.iconfont</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;iconfont&quot;</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">  -webkit-<span class="attribute">font-smoothing</span>: antialiased;</span><br><span class="line">  -moz-osx-<span class="attribute">font-smoothing</span>: grayscale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改 <code>src/index.html</code></p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span>&gt;</span><span class="symbol">&amp;#xe8ab;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置 loader</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            .</span><br><span class="line">            .</span><br><span class="line">               .</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="attr">test</span>: <span class="regexp">/\.(eot|svg|woff|woff2|ttf|mp3|mp4|avi)$/</span>,  <span class="comment">// 处理字体文件</span></span><br><span class="line">                   <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">                   <span class="attr">options</span>: &#123;</span><br><span class="line">                     <span class="attr">outputPath</span>: <span class="string">&#x27;fonts&#x27;</span>,</span><br><span class="line">                     <span class="attr">name</span>: <span class="string">&#x27;[hash:8].[ext]&#x27;</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           ]</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>运行指令</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">webpack</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="13、自动编译打包运行">13、自动编译打包运行</h3><p>之前的操作，每次修改代码都需要重新执行 webpack 命令，可以使用 webpack-dev-server 自动打包运行</p><ol><li><p>安装 loader</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm install webpack-dev-server -g</span></span><br></pre></td></tr></table></figure></li><li><p>详细配置见官网  <a href="https://www.webpackjs.com/configuration/dev-server/">https://www.webpackjs.com/configuration/dev-server/</a></p></li><li><p>修改 webpack.config.js</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">   .</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">       .</span><br><span class="line">       <span class="attr">output</span>: &#123;</span><br><span class="line">           <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">           <span class="attr">filename</span>: <span class="string">&#x27;js/app.js&#x27;</span>,</span><br><span class="line">           <span class="comment">//1. 添加 devServer 服务后需要调整输出的路径</span></span><br><span class="line">           <span class="attr">publicPath</span>: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="attr">module</span>: &#123;</span><br><span class="line">           <span class="attr">rules</span>: [</span><br><span class="line">               .</span><br><span class="line">               .</span><br><span class="line">               .</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">                   <span class="attr">use</span>: &#123;</span><br><span class="line">                       <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">                       <span class="attr">options</span>: &#123;</span><br><span class="line">                           <span class="attr">limit</span>: <span class="number">8192</span>,               </span><br><span class="line">                           <span class="attr">outputPath</span>: <span class="string">&#x27;images&#x27;</span>,           </span><br><span class="line">                           <span class="attr">name</span>: <span class="string">&#x27;[hash:8].[ext]&#x27;</span>,       </span><br><span class="line">               <span class="comment">//2. 删除 publicPath 配置</span></span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;,</span><br><span class="line">               </span><br><span class="line">   </span><br><span class="line">           ]</span><br><span class="line">       &#125;,</span><br><span class="line">       .</span><br><span class="line">       .</span><br><span class="line">       <span class="comment">//3. 增加 devServer 配置</span></span><br><span class="line">       <span class="attr">devServer</span>: &#123;</span><br><span class="line">           <span class="attr">open</span>: <span class="literal">true</span>, <span class="comment">// 自动打开浏览器</span></span><br><span class="line">           <span class="attr">compress</span>: <span class="literal">true</span>, <span class="comment">// 启动gzip压缩</span></span><br><span class="line">           <span class="attr">port</span>: <span class="number">3000</span>, <span class="comment">// 端口号</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>现在就可以启动服务</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">webpack-dev-server</span></span><br></pre></td></tr></table></figure></li><li><p>配置 package.json 中 scripts 指令。增加 server 配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack-dev-server&quot;</span> </span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line"> <span class="punctuation">&#125;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>运行指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm run server</span> </span><br></pre></td></tr></table></figure></li></ol><h3 id="14、热模替换功能">14、热模替换功能</h3><p>模块热替换 (HMR - Hot Module Replacement) 功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面，详细配置地址（<a href="https://www.webpackjs.com/guides/hot-module-replacement/">https://www.webpackjs.com/guides/hot-module-replacement/</a>）</p><p>修改 webpack.config.js 的 devServer 配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//index.html 不能自动刷新的解决方法</span></span><br><span class="line">    <span class="comment">//新增一个入口，解决开启热模块替换后首页无法刷新的问题</span></span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">main</span>:[<span class="string">&#x27;./src/js/app.js&#x27;</span>,<span class="string">&#x27;./src/index.html&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>, </span><br><span class="line">        <span class="attr">compress</span>: <span class="literal">true</span>, </span><br><span class="line">        <span class="attr">port</span>: <span class="number">3000</span>, </span><br><span class="line">        <span class="attr">hot</span>: <span class="literal">true</span><span class="comment">// 开启热模块替换功能</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15、devtool">15、devtool</h3><p>devtool 配置控制 source-map 的生成 , 可以将压缩/编译文件中的代码映射回源文件中的原始位置，便于调试代码</p><p>详细配置官网地址 <a href="https://www.webpackjs.com/configuration/devtool/">https://www.webpackjs.com/configuration/devtool/</a></p><p>配置 webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="attr">devtool</span>:  <span class="string">&#x27;cheap-module-eval-source-map&#x27;</span>, <span class="comment">//设置 devtool 策略</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐使用：</p><ul><li>开发环境： cheap-module-eval-source-map</li><li>生产环境： none   source-map</li></ul><h3 id="16、准备生产环境">16、准备生产环境</h3><p>webpack 可以使用不同的配置文件，进行不同的编译。</p><ol><li><p>创建文件夹 config，将 webpack.config.js 复制两份</p><ul><li>./config/webpack.dev.js</li><li>./config/webpack.prod.js</li></ul></li><li><p>修改 webpack.prod.js 配置，删除 webpack-dev-server 配置</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">main</span>:[<span class="string">&#x27;./src/js/app.js&#x27;</span>,<span class="string">&#x27;./src/index.html&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="comment">//1. 设置 devtool</span></span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">    <span class="comment">//2. 设置 mode</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span></span><br><span class="line">    <span class="comment">//3. 删除 devServer 配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改 package.json 的指令</p></li></ol>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack-dev-server --config ./config/webpack.dev.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack --config ./config/webpack.prod.js&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>开发环境指令</li></ol><ul><li>npm run dev   用于开发环境   不打包文件</li><li>npm run build        用于生产环境    打包文件 （==打包后的index.html不能直接双击打开，需要启动服务==）</li></ul><h3 id="17、清除打包文件目录">17、清除打包文件目录</h3><p>每次打包生成了文件，都需要手动删除，引入插件 <code>clean-webpack-plugin</code> 帮助我们自动删除上一次生成的文件</p><ol><li><p>安装插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm install clean-webpack-plugin --save-dev</span></span><br></pre></td></tr></table></figure></li><li><p><code>webpack.prod.js</code> 引入插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 引入插件</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanWebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>); </span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>, </span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="comment">//2. 配置插件</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>() </span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm run build</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="18、提取-CSS-成单独文件">18、提取 CSS 成单独文件</h3><p>前面的 CSS 样式代码都是放在 style 标签中，这里可以借助 mini-css-extract-plugin 抽离 CSS 文件</p><ol><li><p>安装插件</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm install mini-css-extract-plugin --save-dev</span> </span><br></pre></td></tr></table></figure></li><li><p>配置 webpack.prod.js</p></li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="comment">// 1. 引入插件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/.less$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,   <span class="comment">// 2. 修改配置 loader</span></span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;<span class="comment">// 3. 配置插件</span></span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&quot;css/[hash:8].css&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>运行指令 <figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">webpack</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="19、添加-CSS-兼容">19、添加 CSS 兼容</h3><ul><li><p>安装 loader</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm install postcss-loader autoprefixer --save-dev</span> </span><br></pre></td></tr></table></figure></li><li><p>配置 loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">   .</span><br><span class="line">    .</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.less$/</span>, </span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">loader</span>: <span class="string">&#x27;postcss-loader&#x27;</span>,      <span class="comment">// 1. 设置 postcss-loader</span></span><br><span class="line">                        <span class="attr">options</span>: &#123;</span><br><span class="line">                            <span class="attr">plugins</span>: [</span><br><span class="line">                                <span class="built_in">require</span>(<span class="string">&quot;autoprefixer&quot;</span>) <span class="comment">// 2. 配置插件</span></span><br><span class="line">                            ]</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">&#x27;less-loader&#x27;</span>,</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            .</span><br><span class="line">            .</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在项目目录下创建 <code>.browserslistrc</code>  ==这里一要加目标浏览器设置==</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chrome 50</span><br><span class="line">last 1 versions</span><br><span class="line">ie 10</span><br><span class="line">iOS 7</span><br></pre></td></tr></table></figure></li><li><p>运行指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm run build</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="20、压缩-CSS">20、压缩 CSS</h3><ol><li><p>安装插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm install optimize-css-assets-webpack-plugin --save-dev</span> </span><br></pre></td></tr></table></figure></li><li><p>引入插件，配置插件</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 引入插件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OptimizeCssAssetsPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        <span class="comment">//2. 配置插件</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">OptimizeCssAssetsPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">cssProcessorPluginOptions</span>: &#123;</span><br><span class="line">        <span class="comment">//移除所有的注释</span></span><br><span class="line">                <span class="attr">preset</span>: [<span class="string">&#x27;default&#x27;</span>, &#123;<span class="attr">discardComments</span>: &#123;<span class="attr">removeAll</span>: <span class="literal">true</span>&#125;&#125;],</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 解决没有source map问题</span></span><br><span class="line">            <span class="attr">cssProcessorOptions</span>: &#123;                  </span><br><span class="line">                <span class="attr">map</span>: &#123;</span><br><span class="line">                    <span class="comment">// 不生成内联映射,这样配置就会生成一个source-map文件</span></span><br><span class="line">                    <span class="attr">inline</span>: <span class="literal">false</span>,</span><br><span class="line">                    <span class="comment">// 向css文件添加source-map路径注释</span></span><br><span class="line">                    <span class="comment">// 如果没有此项压缩后的css会去除source-map路径注释</span></span><br><span class="line">                    <span class="attr">annotation</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm run build</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="附录">附录</h2><h3 id="browserslist">browserslist</h3><p>browserslist 目标浏览器配置表，可以针对目标浏览器进行编译处理，避免不必要的兼容代码</p><p>配置的方法有两种，一种是在 package.json 中，一种是创建 <code>.browserslistrc</code></p><p>package.json 形式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="attr">&quot;browserslist&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;&gt; 1%&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;last 2 versions&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>.browserslistrc</code> 形式</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript"><span class="number">1</span>%</span></span><br><span class="line">last 2 versions</span><br></pre></td></tr></table></figure><p>配置规则介绍</p><table><thead><tr><th>规则</th><th>介绍</th></tr></thead><tbody><tr><td>&gt; 1%</td><td>全球超过1%人使用的浏览器</td></tr><tr><td>&gt; 5% in US</td><td>指定国家使用率覆盖</td></tr><tr><td>last 2 versions</td><td>所有浏览器兼容到最后两个版本根据CanIUse.com追踪的版本</td></tr><tr><td>Firefox &gt; 20</td><td>指定浏览器的版本范围</td></tr><tr><td>not ie &lt;=8</td><td>排除 ie8 及以下</td></tr><tr><td>Firefox 12.1</td><td>指定浏览器的兼容到指定版本</td></tr><tr><td>since 2013</td><td>2013年之后发布的所有版本</td></tr><tr><td>not dead with &gt; 0.2%</td><td>仍然还在使用且使用率大于 0.2%</td></tr><tr><td>last 2 Chrome versions</td><td>最新的两个 Chrome 配置</td></tr><tr><td>cover 99.5%</td><td>99.5% 的浏览器都是目标</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">🍛本文汇总webpack配置教程 ，可作为文档进行查询</summary>
    
    
    
    <category term="前端笔记" scheme="https://www.cameliia.top/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="webpack" scheme="https://www.cameliia.top/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>字符串（String）的常用方法</title>
    <link href="https://www.cameliia.top/posts/310.html"/>
    <id>https://www.cameliia.top/posts/310.html</id>
    <published>2023-03-20T10:19:03.000Z</published>
    <updated>2023-03-20T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>字符串（String）的常用方法</h1><h3 id="1-str-charAt-index）动态方法">1. str.charAt(index）动态方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回子字符串</span></span><br></pre></td></tr></table></figure><h3 id="2-str-charCodeAt-index-动态方法">2. str.charCodeAt(index) 动态方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回子字符串的Unicode编码</span></span><br></pre></td></tr></table></figure><h3 id="3-String-fromCharCode-num1-num2-…">3. String.fromCharCode(num1,num2,…)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据Unicode编码返回字符串</span></span><br></pre></td></tr></table></figure><h3 id="4-str-indexOf-searchString-startIndex">4. str.indexOf(searchString,startIndex)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回子字符串第一次出现的位置，从startIndex开始查找，找不到返回-1</span></span><br></pre></td></tr></table></figure><h3 id="5-str-lastIndexOf-searchString-startIndex">5. str.lastIndexOf(searchString,startIndex)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从右往左开始查找，找不到返回-1</span></span><br></pre></td></tr></table></figure><h3 id="6-截取字符串">6. 截取字符串</h3><h4 id="1-str-substring-start-end">1) str.substring(start,end)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个参数都为正数，返回值就是[start,end-1]这段的字符串</span></span><br></pre></td></tr></table></figure><h4 id="2-str-slice-start-end">2) str.slice(start,end)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个参数可正可负，返回值就是[start,end-1]这段的字符串</span></span><br></pre></td></tr></table></figure><h3 id="7-str-split-separator-limit">7. str.split(separator,limit)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1指定字符串或正则，参数2指定数组的最大长度</span></span><br><span class="line"><span class="comment">// 字符串变数组</span></span><br><span class="line">str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// 每个字符被分割[&quot;&quot;,&quot;&quot;,&quot;&quot;]；</span></span><br><span class="line"><span class="comment">// 数组变成字符串</span></span><br><span class="line">arr.<span class="title function_">join</span>(分隔符)</span><br></pre></td></tr></table></figure><h3 id="8-str-replace-rgExp-substr-replaceText">8. str.replace(rgExp/substr,replaceText)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回替换后的字符串</span></span><br></pre></td></tr></table></figure><h3 id="9-str-match-rgExp">9. str.match(rgExp)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正则匹配</span></span><br></pre></td></tr></table></figure><h1>JS中获取数据类型的四种方法</h1><p>JS中获取数据类型常用的方法有四种：</p><h3 id="1-typeof">1. typeof</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断js中基本数据类型，但是无法判断对象的具体类型</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a:&quot;</span>+<span class="title function_">typeof</span>(a)); <span class="comment">// a: object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b:&quot;</span>+<span class="title function_">typeof</span>(b)); <span class="comment">// b: object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arr:&quot;</span>+<span class="title function_">typeof</span>(arr)); <span class="comment">// arr: object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arr1:&quot;</span>+<span class="title function_">typeof</span>(arr1)); <span class="comment">// arr1: object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：当使用基本包装类型创建字符串、数组或者布尔值时，使用typeof返回的是Object</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> s); <span class="comment">// Object</span></span><br></pre></td></tr></table></figure><h3 id="2-Object-prototype-toString-call">2. Object.prototype.toString.call( )</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以判断具体的对象类型，包括正则等，但是无法判断自定义对象类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a:&quot;</span>+<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(a)); <span class="comment">// [object Null]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b:&quot;</span>+<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(b)); <span class="comment">// [object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arr:&quot;</span>+<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr)); <span class="comment">// [object Array]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arr1:&quot;</span>+<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr1)); <span class="comment">// [object Array]</span></span><br><span class="line"><span class="comment">// 对于自定义的对象类型，无法判断</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(x)); <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure><h3 id="3-instanceof">3. instanceof</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量 instanceof对象，返回值为boolean,用来判断一个变量是否为某个对象的实例</span></span><br><span class="line"><span class="comment">// 仅能判断对象的具体类型，但可以拥有判断自定义对象类型</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a <span class="keyword">instanceof</span> <span class="title class_">Number</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="keyword">if</span>(x <span class="keyword">instanceof</span> A)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;x is A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x is A</span></span><br></pre></td></tr></table></figure><h3 id="4-constructor">4. constructor</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看对象对应的构造函数</span></span><br><span class="line"><span class="comment">// object的每个实例都具有属性constructor，保存着用于创建当前对象的函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">constructor</span>); <span class="comment">// f A()&#123;this.a = 1&#125;</span></span><br><span class="line"><span class="keyword">if</span>(x.<span class="property">constructor</span> === A)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;x is A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x is A</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是， undefined和Null类型不能判断</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥯本文汇总字符串（String）的常用方法，可作为文档进行查询</summary>
    
    
    
    <category term="前端笔记" scheme="https://www.cameliia.top/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="字符串（String）的常用方法" scheme="https://www.cameliia.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组Array的常用方法</title>
    <link href="https://www.cameliia.top/posts/311.html"/>
    <id>https://www.cameliia.top/posts/311.html</id>
    <published>2023-03-20T10:19:03.000Z</published>
    <updated>2023-03-20T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>数组Array的常用方法（22种）</h1><h2 id="关于数组的判断（1）isArray">关于数组的判断（1）isArray</h2><p><strong>Array.isArray()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于判断一个对象是否为数组</span></span><br><span class="line"><span class="keyword">var</span> f = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(f)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="关于这个方法的实现">关于这个方法的实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property">myIsArray</span> = <span class="keyword">function</span>(<span class="params">o</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Object</span>(o) === <span class="string">&#x27;[Object Array]&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="关于类数组对象转成数组（1）from">关于类数组对象转成数组（1）from</h2><p><strong>Array.from()</strong> 用于通过拥有length属性的对象或可迭代的对象来返回一个数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回新的数组实例，对于原始解构不影响</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// [&quot;f&quot;,&quot;o&quot;,&quot;o&quot;];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法有三个参数：</span></span><br><span class="line"><span class="comment">// 1. 接受一个类数组或可迭代对象</span></span><br><span class="line"><span class="comment">// 2. 新数组中每个元素都会执行的回调函数</span></span><br><span class="line"><span class="comment">// 3. 指定第二个参数的this对象</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="function"><span class="params">x</span>=&gt;</span>x*<span class="number">10</span>);</span><br><span class="line"><span class="comment">// arr[0] = 10;</span></span><br><span class="line"><span class="comment">// arr[1] = 20;</span></span><br><span class="line"><span class="comment">// arr[2] = 30;</span></span><br></pre></td></tr></table></figure><h2 id="关于多个数组的连接-数组转换成字符串（2）concat-join">关于多个数组的连接 &amp; 数组转换成字符串（2）concat/join</h2><p><strong>Array.prototype.concat()</strong>  用于连接两个或多个数组，且不会改变现有数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">&quot;苹果&quot;</span>,<span class="string">&quot;香蕉&quot;</span>,<span class="string">&quot;橘子&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">&quot;梨&quot;</span>,<span class="string">&quot;西瓜&quot;</span>,<span class="string">&quot;火龙果&quot;</span>]；</span><br><span class="line"><span class="keyword">var</span> arr = arr1.<span class="title function_">concat</span>(arr2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [&quot;苹果&quot;,&quot;香蕉&quot;,&quot;橘子&quot;,&quot;梨&quot;,&quot;西瓜&quot;,&quot;火龙果&quot;]</span></span><br></pre></td></tr></table></figure><p><strong>Array.prototype.join()</strong> 把数组的所有元素转换成一个字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">&quot;西瓜&quot;</span>,<span class="string">&quot;哈密瓜&quot;</span>,<span class="string">&quot;榴莲&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits.<span class="title function_">join</span>()); <span class="comment">// 西瓜,哈密瓜,榴莲</span></span><br></pre></td></tr></table></figure><h2 id="关于查找符合条件的数组（5）every-some-filter-find-includes">关于查找符合条件的数组（5）every/some/filter/find/includes</h2><p><strong>Array.prototype.every()</strong> 用于检测数值元素的每个元素是否都符合条件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果数组中检测到一个元素不满足条件，则整个返回false，剩余元素就不会再进行检测</span></span><br><span class="line"><span class="comment">// 不会对空数组进行检测，也不会改变原始数组</span></span><br><span class="line"><span class="keyword">var</span> ages = [<span class="number">33</span>,<span class="number">20</span>,<span class="number">16</span>,<span class="number">50</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkAdult</span>(<span class="params">age</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> age &gt;= <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line">ages.<span class="title function_">every</span>(checkAdult); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>Array.prototype.some()</strong> 检测数组元素中是否有元素符合指定条件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不会对空数组进行检测，也不会改变原始数组</span></span><br><span class="line"><span class="comment">// 如果有一个元素满足条件，就返回true，剩余的元素不会再进行检测</span></span><br><span class="line"><span class="keyword">var</span> ages = [<span class="number">33</span>,<span class="number">20</span>,<span class="number">16</span>,<span class="number">50</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkAdult</span>(<span class="params">age</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> age &gt;= <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line">ages.<span class="title function_">some</span>(checkAdult); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>Array.prototype.filter()</strong> 用于检测数值元素，并返回符合条件的所有元素的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不会对空数组进行检测，也不会改变原始数组</span></span><br><span class="line"><span class="keyword">var</span> ages = [<span class="number">33</span>,<span class="number">20</span>,<span class="number">16</span>,<span class="number">50</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkAdult</span>(<span class="params">age</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> age &gt;= <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line">ages.<span class="title function_">filter</span>(checkAdult); <span class="comment">// [33,20,50]</span></span><br></pre></td></tr></table></figure><p><strong>Array.prototype.find()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不会对空数组进行检测，也不会改变原始数组</span></span><br><span class="line"><span class="comment">// 返回符合传入测试（函数）条件的第一个元素的值，之后的值就不会再检测了</span></span><br><span class="line"><span class="comment">// 没有符合条件的值就返回undefined</span></span><br><span class="line"><span class="keyword">var</span> ages = [<span class="number">10</span>,<span class="number">15</span>,<span class="number">18</span>,<span class="number">50</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkAdult</span>(<span class="params">age</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> age &gt;= <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line">ages.<span class="title function_">filter</span>(checkAdult); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p><strong>Array.prototype.includes(searchElement,fromIndex)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断一个数组是否包含一个指定的值,有就返回true，否则返回false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">2</span>,<span class="number">1</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="关于数组的遍历（1）forEach">关于数组的遍历（1）forEach</h2><p><strong>Array.prototype.forEach()</strong> 遍历方法，对数组中的每个元素都执行一次回调函数</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于空数组不会执行回调函数</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>];</span><br><span class="line">arr.forEach(<span class="keyword">function</span>(<span class="params">item,index</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(item)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="关于数组index的查找（2）indexOf-lastIndexOf">关于数组index的查找（2）indexOf/lastIndexOf</h2><p><strong>Array.prototype.indexOf()</strong> 搜素数组中的元素，返回它所在的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从头开始检索，找到item第一次出现的位置，返回它的索引值</span></span><br><span class="line"><span class="comment">// 没有就返回-1</span></span><br><span class="line"><span class="keyword">var</span> fruits = [<span class="string">&quot;西瓜&quot;</span>,<span class="string">&quot;哈密瓜&quot;</span>,<span class="string">&quot;榴莲&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits.<span class="title function_">indexOf</span>(<span class="string">&quot;哈密瓜&quot;</span>));<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p><strong>Array.prototype.lastIndexOf()</strong> 返回指定内容最后出现的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从后向前进行检索，找到item第一次出现的位置，返回它的索引值</span></span><br><span class="line"><span class="comment">// 没有就返回-1</span></span><br><span class="line"><span class="keyword">var</span> fruits = [<span class="string">&quot;西瓜&quot;</span>,<span class="string">&quot;哈密瓜&quot;</span>,<span class="string">&quot;榴莲&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits.<span class="title function_">indexOf</span>(<span class="string">&quot;哈密瓜&quot;</span>)); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h2 id="关于数组的增删改（7）pop-shift-push-unshift-reverse-slice-splice">关于数组的增删改（7）pop/shift/push/unshift/reverse/slice/splice</h2><p><strong>Array.prototype.pop()</strong> 删除数组的最后一个元素并返回删除的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法会改变数组的长度</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1.<span class="title function_">pop</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// [10,20,30]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// 40</span></span><br></pre></td></tr></table></figure><p><strong>Array.prototype.shift()</strong> 删除并返回数组的第一个元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法会改变数组的长度</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1.<span class="title function_">shift</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// [20,30，40]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p><strong>Array.prototype.push()</strong> 向数组末尾添加一个或多个元素，并返回新的长度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法会改变数组的长度</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1.<span class="title function_">push</span>(<span class="number">50</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// [10,20,30，40,50]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p><strong>Array.prototype.unshift()</strong> 向数组开头添加一个或多个元素，并返回新的长度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法会改变数组的长度</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1.<span class="title function_">unshift</span>(<span class="number">50</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// [50,10,20,30，40]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p><strong>Array.prototype.reverse()</strong> 反转数组的元素顺序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&quot;小明&quot;</span>,<span class="string">&quot;小红&quot;</span>,<span class="string">&quot;小黄&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(names.<span class="title function_">reverse</span>()); <span class="comment">// [&quot;小黄&quot;,&quot;小红&quot;,&quot;小明&quot;]</span></span><br></pre></td></tr></table></figure><p><strong>Array.prototype.slice(start,end)</strong> 选取数组的一部分，并返回一个新数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不会改变原始数组</span></span><br><span class="line"><span class="keyword">var</span> fruits = [<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Lemon&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> re = fruits.<span class="title function_">slice</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re); <span class="comment">// [&quot;Orange&quot;,&quot;Lemon&quot;]</span></span><br></pre></td></tr></table></figure><p><strong>Array.prototype.splice(index，num)</strong> 从数组中添加或删除元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法会改变原始数组</span></span><br><span class="line"><span class="comment">// 删除元素时,参数为开始索引和要删除元素的长度</span></span><br><span class="line"><span class="keyword">var</span> sites = [<span class="string">&quot;Runoob&quot;</span>,<span class="string">&quot;Google&quot;</span>,<span class="string">&quot;Taobao&quot;</span>];</span><br><span class="line"><span class="comment">// 该方法返回的是被删除元素组成的数组</span></span><br><span class="line"><span class="keyword">var</span> re = sites.<span class="title function_">splice</span>(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&quot;GGGGG&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sites); <span class="comment">//[&quot;Runoob&quot;,&quot;Google&quot;,&quot;GGGGG&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re); <span class="comment">// [&quot;Taobao&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="关于数组的回调处理和排序（3）sort-reduce-map">关于数组的回调处理和排序（3）sort/reduce/map</h2><p><strong>Array.prototype.sort()</strong> 对数组的元素进行排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法将改变原始数组</span></span><br><span class="line"><span class="keyword">var</span> points = [<span class="number">40</span>,<span class="number">100</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">25</span>,<span class="number">10</span>];</span><br><span class="line">points.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> a-b;</span><br><span class="line">&#125;); <span class="comment">// 1，5，10，25，40，100 （升序排列）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以给字母排序</span></span><br><span class="line"><span class="keyword">var</span> fruits = [<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span>];</span><br><span class="line">fruits.<span class="title function_">sort</span>(); <span class="comment">// [&quot;Apple&quot;,&quot;Banana&quot;,&quot;Mango&quot;,&quot;Orange&quot;];</span></span><br></pre></td></tr></table></figure><p><strong>Array.prototype.reduce()</strong> 将数组元素计算为一个值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于空数组不会执行回调函数的</span></span><br><span class="line"><span class="comment">// 接收一个函数作为累加器，对数组中的每个值进行累加计算</span></span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>];</span><br><span class="line"><span class="keyword">var</span> result = num.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">pre,cur</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> pre + cur;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 150</span></span><br></pre></td></tr></table></figure><h3 id="关于这个方法的实现-2">关于这个方法的实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myReduce</span> = <span class="keyword">function</span>(<span class="params">callback, initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> accumulator = initialValue ? initialValue : <span class="variable language_">this</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = initialValue ? <span class="number">0</span> : <span class="number">1</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">    accumulator = <span class="title function_">callback</span>(accumulator, <span class="variable language_">this</span>[i], i, _this);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Array.prototype.map(callback,[thisObject])</strong> 通过指定函数处理数组的每个元素，并返回处理后的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个新数组，新数组中的元素都是原始数组处理后的值</span></span><br><span class="line"><span class="comment">// 不会对空数组进行检测，也不会改变原始数组</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">36</span>];</span><br><span class="line"><span class="keyword">var</span> newNum = numbers.<span class="title function_">map</span>(<span class="title class_">Math</span>.<span class="property">sqrt</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNum); <span class="comment">// [2,3,4,5,6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>];</span><br><span class="line"><span class="keyword">const</span> map1 = arr1.<span class="title function_">map</span>(<span class="function"><span class="params">x</span>=&gt;</span>&#123;</span><br><span class="line"><span class="comment">// 只有当x=4时，才进行操作</span></span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> x*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他值时，就直接返回</span></span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map1); <span class="comment">// [1,8,9,16]</span></span><br></pre></td></tr></table></figure><h3 id="关于这个方法的实现-3">关于这个方法的实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myMap</span> = <span class="keyword">function</span>(<span class="params">callback, thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    arr.<span class="title function_">push</span>(callback.<span class="title function_">call</span>(thisArg, <span class="variable language_">this</span>[i], i, <span class="variable language_">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥨本文汇总数组Array的常用方法 ，可作为文档进行查询</summary>
    
    
    
    <category term="前端笔记" scheme="https://www.cameliia.top/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数组Array的常用方法" scheme="https://www.cameliia.top/tags/%E6%95%B0%E7%BB%84Array%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>webpack基础教程</title>
    <link href="https://www.cameliia.top/posts/308.html"/>
    <id>https://www.cameliia.top/posts/308.html</id>
    <published>2023-03-20T10:19:03.000Z</published>
    <updated>2023-03-20T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>webpack基础配置教程</h1><h3 id="1-初识Webpack">1. 初识Webpack</h3><ul><li>什么是webpack？<ul><li>Webpack是一个模块打包器。</li><li>在Webpack会将前端的所有资源文件（js/json/css/img/less/…）都作为模块处理。</li><li>它将根据模块的依赖关系进行分析，生成对应的资源</li></ul></li><li>五个核心概念：<ol><li>【入口(entry)】：指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。</li><li>【输出(output)】：在哪里输出文件，以及如何命名这些文件。</li><li>【Loader】：处理那些非 JavaScript 文件（webpack 自身只能解析 JavaScript和json）。</li><li>【插件(plugins)】执行范围更广的任务，从打包到优化都可以实现。</li><li>【模式(mode)】，有生产模式production和开发模式development</li></ol></li><li>对loader的理解<ul><li>webpack 本身只能处理JS、JSON模块，如果要加载其他类型的文件(模块)，就需要使用对应的loader 。</li><li>它本身是一个函数，接受源文件作为参数，返回转换的结果。</li><li>loader 一般以 xxx-loader 的方式命名，xxx 代表了这个 loader 要做的转换功能，比如 css-loader。</li></ul></li><li>对plugins的理解<ul><li>插件可以完成一些loader不能完成的功能。</li></ul></li><li>配置文件<ul><li>webpack.config.js : 用于存储webpack配置信息。</li></ul></li></ul><h3 id="2-开启项目">2. 开启项目</h3><ul><li>初始化项目：<ul><li>使用<code>npm init</code>或<code>yarn init</code>生成一个package.json文件  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack_test&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span> </span><br></pre></td></tr></table></figure></li></ul></li><li>安装webpack<ul><li>npm install webpack@4 webpack-cli@3 -g  //全局安装,作为指令使用</li><li>npm install webpack@4 webpack-cli@3 -D //本地安装,作为本地依赖使用</li></ul></li></ul><h3 id="3-处理js和json文件">3. 处理js和json文件</h3><ul><li><p>创建js文件</p><ul><li>src/js/app.js</li><li>src/js/module1.js</li><li>src/js/module2.js</li></ul></li><li><p>创建json文件</p><ul><li>src/json/data.json</li></ul></li><li><p>创建主页面:</p><ul><li>src/index.html</li></ul></li><li><p>运行指令</p><ul><li><p>打包指令（开发）：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack .<span class="regexp">/src/</span>js<span class="regexp">/app.js -o ./</span>build<span class="regexp">/js/</span>app.js --mode=development</span><br></pre></td></tr></table></figure><ul><li>功能: webpack能够打包js和json文件，并且能将es6的模块化语法转换成浏览器能识别的语法</li></ul></li><li><p>打包指令（生产）：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack .<span class="regexp">/src/</span>js<span class="regexp">/app.js -o ./</span>build<span class="regexp">/js/</span>app.js --mode=production</span><br></pre></td></tr></table></figure><ul><li>功能: 在开发配置功能上加上一个压缩代码的功能</li></ul></li><li><p>index.html页面中引入：build/js/app.js</p></li></ul></li><li><p>结论：</p><ul><li>webpack能够编译打包js和json文件</li><li>能将es6的模块化语法转换成浏览器能识别的语法</li><li>能压缩代码</li></ul></li><li><p>缺点：</p><ul><li>不能编译打包css、img等文件</li><li>不能将js的es6基本语法转化为es5以下语法</li></ul></li><li><p>改善：使用webpack配置文件解决，自定义功能</p></li></ul><h3 id="4-webpack配置文件">4. webpack配置文件</h3><ul><li>目的：在项目根目录定义配置文件，通过自定义配置文件，还原以上功能</li><li>文件名称：webpack.config.js</li><li>文件内容：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>); <span class="comment">//node内置核心模块，用来设置路径。</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/js/app.js&#x27;</span>, <span class="comment">// 入口文件配置（精简写法）</span></span><br><span class="line">    <span class="comment">/*完整写法：</span></span><br><span class="line"><span class="comment">entry:&#123;</span></span><br><span class="line"><span class="comment">main:&#x27;./src/js/app.js&#x27;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="attr">output</span>: &#123; <span class="comment">//输出配置</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;./js/app.js&#x27;</span>,<span class="comment">//输出文件名</span></span><br><span class="line">        <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>)<span class="comment">//输出文件路径(绝对路径)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>   <span class="comment">//开发环境(二选一)</span></span><br><span class="line">    <span class="comment">//mode: &#x27;production&#x27;   //生产环境(二选一)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>运行指令： webpack</li></ul><h3 id="5-打包less、css资源">5. 打包less、css资源</h3><ul><li><p>概述：less、css文件webpack不能解析，需要借助loader编译解析</p></li><li><p>创建less文件</p><ul><li>src/css/demo1.less</li><li>src/css/demo2.css</li></ul></li><li><p>入口app.js文件</p><ul><li>引入less、css资源</li></ul></li><li><p>安装loader</p><ul><li>npm install css-loader style-loader less-loader less -D</li></ul></li><li><p>配置loader</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 处理less资源</span></span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line"><span class="attr">use</span>: [</span><br><span class="line"><span class="string">&#x27;style-loader&#x27;</span>, <span class="comment">//创建style标签，将js中的样式资源插入进行，添加到head中生效</span></span><br><span class="line"><span class="string">&#x27;css-loader&#x27;</span>, <span class="comment">//将css文件变成commonjs模块加载js中，里面内容是样式字符串</span></span><br><span class="line"><span class="string">&#x27;less-loader&#x27;</span> <span class="comment">//将less文件编译成css文件</span></span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 处理css资源</span></span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line"><span class="attr">use</span>: [ <span class="comment">// use数组中loader执行顺序：从右到左，从下到上 依次执行</span></span><br><span class="line"><span class="string">&#x27;style-loader&#x27;</span>,<span class="comment">// 创建style标签，将js中的样式资源插入进行，添加到head中生效</span></span><br><span class="line"><span class="string">&#x27;css-loader&#x27;</span><span class="comment">// 将css文件变成commonjs模块加载js中，里面内容是样式字符串</span></span><br><span class="line">]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>运行指令：webpack</p></li></ul><h3 id="6-打包html文件">6. 打包html文件</h3><ul><li><p>概述：借助html-webpack-plugin插件打包html资源</p></li><li><p>创建html文件</p><ul><li>src/index.html</li><li>注意：不要在该html中引入任何css和js文件</li></ul></li><li><p>安装插件：html-webpack-plugin</p><ul><li>npm install html-webpack-plugin -D</li></ul></li><li><p>在webpack.config.js中引入插件（插件都需要手动引入，而loader会自动加载）</p><ul><li>const HtmlWebpackPlugin = require(‘html-webpack-plugin’)</li></ul></li><li><p>配置插件Plugins</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line"><span class="comment">// 以当前文件为模板创建新的HtML(1. 结构和原来一样 2. 会自动引入打包的资源)</span></span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>, </span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></li><li><p>运行指令：webpack</p></li></ul><h3 id="7-打包样式中的图片">7. 打包样式中的图片</h3><ul><li>概述：图片文件webpack不能解析，需要借助loader编译解析</li><li>添加2张图片:<ul><li>小图, 小于8kb: src/images/vue.png</li><li>大图, 大于8kb: src/images/react.jpg</li></ul></li><li>在less文件中通过背景图的方式引入两个图片</li><li>安装loader<ul><li>npm install file-loader url-loader file-loader -D</li><li>补充：url-loader是对象file-loader的上层封装，使用时需配合file-loader使用。</li></ul></li><li>配置loader  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 处理图片资源</span></span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line"><span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>, <span class="comment">//url-loader是对file-loader的上层封装</span></span><br><span class="line"><span class="attr">options</span>: &#123;</span><br><span class="line"><span class="attr">limit</span>: <span class="number">8</span> * <span class="number">1024</span>, <span class="comment">//临界值为8KB，小于8KB的图片会被转为base64编码</span></span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;[hash:10].[ext]&#x27;</span>, <span class="comment">//加工后图片的名字</span></span><br><span class="line"><span class="attr">outputPath</span>: <span class="string">&#x27;imgs&#x27;</span> <span class="comment">//输出路径</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-打包html中的图片">8. 打包html中的图片</h3><ul><li><p>概述：html中的<code>&lt;img&gt;</code>标签url-loader没法处理，需要引入其他loader处理。</p></li><li><p>添加图片</p><ul><li>在src/index.html添加一个img标签，src/images/angular.png</li></ul></li><li><p>安装loader</p><ul><li>npm install html-loader --save-dev</li></ul></li><li><p>配置loader</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   &#123;</span><br><span class="line"><span class="comment">// 处理html中&lt;img&gt;资源</span></span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line"><span class="attr">loader</span>: <span class="string">&#x27;html-loader&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>可能出现的坑：打包后html文件中的图片的src变成了：[object Module],</p></li><li><p>解决办法：url-loader中加入一个配置：esModule:false即可</p></li></ul><h3 id="9-打包其他资源">9. 打包其他资源</h3><ul><li>概述：其他资源（字体、音视频等）webpack不能解析，需要借助loader编译解析</li><li>以处理几个字体图标的字体为例，font下添加几个下载好的字体文件：<ul><li>src/font/iconfont.eot</li><li>src/font/iconfont.svg</li><li>src/font/iconfont.ttf</li><li>src/font/iconfont.woff</li><li>src/font/iconfont.woff2</li></ul></li><li>修改incofont.css中字体的url  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;iconfont&#x27;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;../media/iconfont.eot&#x27;</span>);</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;../media/iconfont.eot?#iefix&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;embedded-opentype&#x27;</span>),</span><br><span class="line">  <span class="built_in">url</span>(<span class="string">&#x27;../media/iconfont.woff2&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>),</span><br><span class="line">  <span class="built_in">url</span>(<span class="string">&#x27;../media/iconfont.woff&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>),</span><br><span class="line">  <span class="built_in">url</span>(<span class="string">&#x27;../media/iconfont.ttf&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>),</span><br><span class="line">  <span class="built_in">url</span>(<span class="string">&#x27;../media/iconfont.svg#iconfont&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;svg&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.iconfont</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;iconfont&quot;</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">  -webkit-<span class="attribute">font-smoothing</span>: antialiased;</span><br><span class="line">  -moz-osx-<span class="attribute">font-smoothing</span>: grayscale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>修改html，添加字体图标，例如：<code>&lt;span class=&quot;iconfont icon-icon-test&quot;&gt;&lt;/span&gt;</code></li><li>配置loader  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 处理其他资源(字体、音视频等等)</span></span><br><span class="line"><span class="attr">exclude</span>: <span class="regexp">/\.(html|js|css|less|jpg|png|gif)/</span>, <span class="comment">//排除的文件</span></span><br><span class="line"><span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line"><span class="attr">options</span>: &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;[hash:10].[ext]&#x27;</span>, <span class="comment">//命名</span></span><br><span class="line"><span class="attr">outputPath</span>: <span class="string">&#x27;media&#x27;</span> <span class="comment">//输出路径</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>运行指令：webpack</li></ul><h3 id="10-devServer">10. devServer</h3><ul><li><p>安装webpack-dev-server</p><ul><li>npm install webpack-dev-server --save-dev</li></ul></li><li><p>详细配置见官网：指南 -&gt; 开发环境 -&gt; 使用webpack-dev-server</p></li><li><p>修改webpack配置对象，追加devServer配置（注意不是loader中追加）</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//devServer配置(开发模式所特有的配置)</span></span><br><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line"><span class="attr">contentBase</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>),<span class="comment">//本地打包文件的位置</span></span><br><span class="line"><span class="attr">port</span>: <span class="number">3000</span>, <span class="comment">//端口号</span></span><br><span class="line"><span class="attr">open</span>: <span class="literal">true</span> <span class="comment">//自动打开浏览器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改package.json中scripts指令</p><ul><li><code>&quot;dev&quot;: &quot;webpack-dev-server&quot;</code>,</li></ul></li><li><p>运行指令：npm run dev 或者 yarn dev</p></li></ul><hr/><blockquote><p>至此，你已经完成了用webpack搭建一个简单的开发环境，但这套配置只适用于开发过程中调试代码，项目上线并不能运用这套配置，因为你还有很多的问题没有处理，比如：css还不是单独的文件，css、js还有很多兼容性问题等等，接下来我们开始去搭建生产环境。</p></blockquote><h3 id="生产环境准备：">生产环境准备：</h3><p>1.新建config文件夹，重命名webpack.config.js为webpack.dev.js，放入config文件夹<br>2.复制webpack.dev.js，重命名为webpack.prod.js,删除其中的devServer配置，因为这是开发环境特有的，生产环境是不需要的<br>3.修改package.json中scripts指令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack-dev-server --config ./config/webpack.dev.js&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack --config ./config/webpack.prod.js&quot;</span></span><br></pre></td></tr></table></figure><p>4.修改output中path为：<code>path: resolve(__dirname, '../build')</code></p><h3 id="1-提取css为单独文件">1. 提取css为单独文件</h3><ul><li><p>安装插件</p><ul><li>npm install mini-css-extract-plugin -D</li></ul></li><li><p>引入插件</p><ul><li>const MiniCssExtractPlugin = require(“mini-css-extract-plugin”);</li></ul></li><li><p>配置loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入mini-css-extract-plugin，用于提取css为单独文件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 处理less资源</span></span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    <span class="attr">use</span>: [</span><br><span class="line">      <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">      <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;less-loader&#x27;</span>,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 处理css资源</span></span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line"><span class="attr">use</span>: [</span><br><span class="line">      <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">      <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//提取css为单独文件</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line"><span class="comment">// 对输出的css文件进行重命名</span></span><br><span class="line"><span class="attr">filename</span>: <span class="string">&#x27;css/built.css&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>运行指令</p><ul><li>npm run build</li></ul></li><li><p>备注：由于在提取了独立的文件，要从外部引入，所以可能会有路径问题，解决方案是在output配置中，添加：<code>publicPath:'/'</code> publicPath根据实际情况自行调整,若上线运行值为：/imgs，若本地右键运行值为：/build/imgs</p></li></ul><h3 id="2-css兼容性处理">2. css兼容性处理</h3><ul><li>安装loader<ul><li>npm install postcss postcss-loader postcss-preset-env -D</li></ul></li><li>因为css和less样式文件都要进行兼容性处理，所以我们定义好一个通用的配置：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置一个commonCssLoader，处理less和css时都会使用</span></span><br><span class="line"><span class="keyword">const</span> commonCssLoader = [</span><br><span class="line"><span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>, <span class="comment">//提取css为单独的文件</span></span><br><span class="line"><span class="string">&#x27;css-loader&#x27;</span>, <span class="comment">//将css文件变成commonjs模块加载js中，里面内容是样式字符串</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//注意：想让postcss-loader工作，还需在package.json中定义browserslist配置兼容程度</span></span><br><span class="line"> <span class="attr">loader</span>: <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">ident</span>: <span class="string">&#x27;postcss&#x27;</span>,</span><br><span class="line">          <span class="attr">plugins</span>: <span class="function">() =&gt;</span> [<span class="built_in">require</span>(<span class="string">&#x27;postcss-preset-env&#x27;</span>)()]</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ul><li>修改css-loader和less-loader配置</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 处理css资源</span></span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line"><span class="attr">use</span>: [...commonCssLoader]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 处理less资源</span></span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line"><span class="attr">use</span>: [...commonCssLoader, <span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li><p>配置package.json，在其中追加browserslist配置，通过配置加载指定的css兼容性样式</p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;browserslist&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="comment">// 开发环境</span></span><br><span class="line"><span class="attr">&quot;development&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;last 1 chrome version&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;last 1 firefox version&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;last 1 safari version&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 生产环境：默认是生产环境</span></span><br><span class="line"><span class="attr">&quot;production&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;&gt;0.2%&quot;</span><span class="punctuation">,</span> <span class="comment">//兼容市面上99.8%的浏览器</span></span><br><span class="line"><span class="string">&quot;not dead&quot;</span><span class="punctuation">,</span> <span class="comment">//&quot;死去&quot;的浏览器不做兼容，例如IE8</span></span><br><span class="line"><span class="string">&quot;not op_mini all&quot;</span><span class="punctuation">,</span><span class="comment">//不做opera浏览器mini版的兼容</span></span><br><span class="line"><span class="string">&quot;ie 10&quot;</span> <span class="comment">//兼容IE10</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>备注1: browserslist 是一套描述产品目标运行环境的工具，它被广泛用在各种涉及浏览器/移动端的兼容性支持工具中，详细配置规则参考：<a href="https://github.com/browserslist/browserslist">https://github.com/browserslist/browserslist</a></p></li><li><p>备注2：若出现版本不兼容，或配置不正确的错误，那么需更换依赖包版本：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i less-<span class="symbol">loader@</span><span class="number">5</span> postcss-<span class="symbol">loader@</span><span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>运行指令：</p><ul><li>npm run build</li></ul></li></ul><h3 id="3-js语法检查">3. js语法检查</h3><ul><li><p>概述：对js基本语法错误/隐患，进行提前检查</p></li><li><p>安装loader</p><ul><li>npm install eslint-loader eslint</li></ul></li><li><p>安装检查规则库：</p><ul><li>npm install eslint-config-airbnb-base  eslint-plugin-import</li></ul></li><li><p>备注:eslint-config-airbnb-base定制了一套标准的、常用的js语法检查规则，推荐使用</p></li><li><p>配置loader</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="comment">// 对js进行语法检查</span></span><br><span class="line">       <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">       <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">       <span class="comment">// 优先执行</span></span><br><span class="line">       <span class="attr">enforce</span>: <span class="string">&#x27;pre&#x27;</span>,</span><br><span class="line">       <span class="attr">loader</span>: <span class="string">&#x27;eslint-loader&#x27;</span>,</span><br><span class="line">       <span class="attr">options</span>: &#123;</span><br><span class="line">         <span class="attr">fix</span>: <span class="literal">true</span> <span class="comment">//若有问题自动修复，重要！！！！</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;      </span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>修改package.json</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;eslintConfig&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;extends&quot;</span>: <span class="string">&quot;airbnb-base&quot;</span>, <span class="comment">//直接使用airbnb-base提供的规则</span></span><br><span class="line">  <span class="string">&quot;env&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;browser&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行指令：webpack</p></li><li><p>备注：若出现：warning  Unexpected console statement  no-console警告，意思是不应该在项目中写console.log(),若想忽略，就在要忽略检查代码的上方输入一行注释：// eslint-disable-next-line即可。</p></li></ul><h3 id="4-js语法转换">4. js语法转换</h3><ul><li><p>概述：将浏览器不能识别的新语法转换成原来识别的旧语法，做浏览器兼容性处理</p></li><li><p>安装loader</p><ul><li>npm install babel-loader @babel/core @babel/preset-env --save-dev</li></ul></li><li><p>配置loader</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      <span class="attr">use</span>: &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行指令：webpack</p></li></ul><h3 id="5-js兼容性处理">5. js兼容性处理</h3><ul><li><p>安装包</p><ul><li>npm install @babel/polyfill</li></ul></li><li><p>使用</p>  <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- app.js</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@babel/polyfill&#x27;</span>; <span class="comment">// 包含ES6的高级语法的转换</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-压缩html、压缩js">6. 压缩html、压缩js</h3><ul><li>直接修改webpack.prod.js中的model为production即可。</li><li>备注：若设置了模式为production，必须在new HtmlWebpackPlugin时添加配置minify: false：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">    <span class="comment">// 以当前文件为模板创建新的HtML(1. 结构和原来一样 2. 会自动引入打包的资源)</span></span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>, </span><br><span class="line">    <span class="attr">minify</span>: <span class="literal">false</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><h3 id="7-压缩css">7.压缩css</h3><ul><li><p>安装插件</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="built_in">optimize</span>-css-assets-webpack-plugin --<span class="built_in">save</span>-dev </span><br></pre></td></tr></table></figure></li><li><p>引入插件</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">const OptimizeCssAssetsPlugin</span> = require(<span class="string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>配置插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">OptimizeCssAssetsPlugin</span>(&#123;</span><br><span class="line">  <span class="attr">cssProcessorPluginOptions</span>: &#123;</span><br><span class="line">    <span class="attr">preset</span>: [<span class="string">&#x27;default&#x27;</span>, &#123; <span class="attr">discardComments</span>: &#123; <span class="attr">removeAll</span>: <span class="literal">true</span> &#125; &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>以上就是webpack生产环境的配置，可以生成打包后的文件。</p></blockquote></li></ul>]]></content>
    
    
    <summary type="html">🥐本文汇总webpack基础教程 ，可作为文档进行查询</summary>
    
    
    
    <category term="前端笔记" scheme="https://www.cameliia.top/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="webpack" scheme="https://www.cameliia.top/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Git命令</title>
    <link href="https://www.cameliia.top/posts/501.html"/>
    <id>https://www.cameliia.top/posts/501.html</id>
    <published>2023-03-13T02:00:00.000Z</published>
    <updated>2023-08-13T10:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git">git</h2><div class="note info no-icon flat"><p>Git是一个分布式的版本控制系统。<br>GitHub是一个基于Git做版本控制的代码托管平台。类似的还有Gitee, BitBucket等。</p></div><blockquote><p>在Windows上使用Git，需要下载 Git for windows 软件，在官网下载，速度比较慢，可以找相关资源网站去下载<br>MINGW32 / MINGW64<br>可以去下面的网站下载<br><a href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a></p></blockquote><h2 id="初次使用">初次使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line"><span class="comment"># 初始化git仓库。先进入到要初始化的仓库的文件夹，再执行此命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第一次使用时，需要配置 用户名和邮箱等：</span></span><br><span class="line">git config --global user.name <span class="string">&quot;填入自己的用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;填入自己的邮箱地址&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git reflog    用来记录你的每一次命令</span><br><span class="line">gitk [filename]查看特定文件的历史修改记录</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-git-config">1. git config</h2><blockquote><p>Git 一共有3个配置文件：</p><ul><li>仓库级的配置文件：在仓库的 <code>.git/.gitconfig</code>，该配置文件只对所在的仓库有效。</li><li>全局配置文件：Mac 系统在  <code>~/.gitconfig</code>，Windows 系统在 <code>C:\Users\&lt;用户名&gt;\.gitconfig</code>。</li><li>系统级的配置文件：在 Git的安装目录下（Mac 系统下安装目录在 <code>/usr/local/git</code>）的 etc 文件夹中的 <code>gitconfig</code>。</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">git config</span><br><span class="line"><span class="comment"># 查看当前git仓库的配置信息</span></span><br><span class="line">git config --get remote.origin.url</span><br><span class="line"><span class="comment"># 查看远程仓库地址</span></span><br><span class="line">git config -l</span><br><span class="line"><span class="comment"># 查看当前git环境详细配置</span></span><br><span class="line">git config --list</span><br><span class="line"><span class="comment"># 和上面的是一样的效果。</span></span><br><span class="line">git config &lt;key&gt;</span><br><span class="line"><span class="comment"># 检查Git的某一项设置，使用上面查出来的key</span></span><br><span class="line">git config --system --list</span><br><span class="line"><span class="comment"># 查看系统配置</span></span><br><span class="line">git config --global --list</span><br><span class="line"><span class="comment"># 查看当前用户global配置</span></span><br><span class="line"></span><br><span class="line">第一次使用时，需要配置 用户名和邮箱等：</span><br><span class="line">git config --global user.name <span class="string">&quot;填入自己的用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;填入自己的邮箱地址&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-git-clone">2. git clone</h2><p>从远程仓库克隆一个版本库到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定本地仓库的目录</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt; &lt;本地目录&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -b 指定要克隆的分支，默认是master分支</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt;</span><br></pre></td></tr></table></figure><h2 id="3-git-init">3. git init</h2><p>初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化本地仓库，在当前目录下生成 .git 文件夹</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-git-status">4. git status</h2><p>查看本地仓库的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地仓库的状态</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以简短模式查看本地仓库的状态</span></span><br><span class="line"><span class="comment"># 会显示两列，第一列是文件的状态，第二列是对应的文件</span></span><br><span class="line"><span class="comment"># 文件状态：A 新增，M 修改，D 删除，?? 未添加到Git中</span></span><br><span class="line">$ git status -s</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-git-add">5. git add</h2><p>把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把指定的文件添加到暂存区中</span></span><br><span class="line">$ git add &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有修改、已删除的文件到暂存区中</span></span><br><span class="line">$ git add -u [&lt;文件路径&gt;]</span><br><span class="line">$ git add --update [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有修改、已删除、新增的文件到暂存区中，省略 &lt;文件路径&gt; 即为当前目录</span></span><br><span class="line">$ git add -A [&lt;文件路径&gt;]</span><br><span class="line">$ git add --all [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有修改、已删除但没有提交的文件，进入一个子命令系统</span></span><br><span class="line">$ git add -i [&lt;文件路径&gt;]</span><br><span class="line">$ git add --interactive [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-git-commit">6. git commit</h2><p>将暂存区中的文件提交到本地仓库中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息</span></span><br><span class="line">$ git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把暂存区中的文件提交到本地仓库中并添加描述信息</span></span><br><span class="line">$ git commit -m <span class="string">&quot;&lt;提交的描述信息&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把所有修改、已删除的文件提交到本地仓库中</span></span><br><span class="line"><span class="comment"># 不包括未被版本库跟踪的文件，等同于先调用了 &quot;git add -u&quot;</span></span><br><span class="line">$ git commit -a -m <span class="string">&quot;&lt;提交的描述信息&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改上次提交的描述信息</span></span><br><span class="line">$ git commit --amend</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-git-remote">7. git remote</h2><p>操作远程库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出已经存在的远程仓库</span></span><br><span class="line">$ git remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出远程仓库的详细信息，在别名后面列出URL地址</span></span><br><span class="line">$ git remote -v</span><br><span class="line">$ git remote --verbose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加远程仓库</span></span><br><span class="line">$ git remote add origin  &lt;远程仓库的URL地址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改远程仓库的别名</span></span><br><span class="line">$ git remote rename &lt;原远程仓库的别名&gt; &lt;新的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定名称的远程仓库</span></span><br><span class="line">$ git remote remove &lt;远程仓库的别名&gt;</span><br><span class="line">$ git remote remove origin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改远程仓库的 URL 地址</span></span><br><span class="line">$ git remote set-url &lt;远程仓库的别名&gt; &lt;新的远程仓库URL地址&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8-git-pull">8. git pull</h2><p>从远程仓库获取最新版本并合并到本地。<br>首先会执行 git fetch，然后执行 git merge，把获取的分支的 HEAD 合并到当前分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从远程仓库获取最新版本。</span></span><br><span class="line">$ git pull</span><br><span class="line"><span class="comment">#  用master举例</span></span><br><span class="line">$ git pull origin master</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="9-git-push">9. git push</h2><p>把本地仓库的提交推送到远程仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把本地仓库的分支推送到远程仓库的指定分支</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line">$ git push origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的远程仓库的分支</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; :&lt;远程分支名&gt;</span><br><span class="line">$ git push &lt;远程仓库的别名&gt; --delete &lt;远程分支名&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="10-git-branch">10. git branch</h2><p>操作 Git 的分支命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本地的所有分支，当前所在分支以 &quot;*&quot; 标出</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本地的所有分支并显示最后一次提交，当前所在分支以 &quot;*&quot; 标出</span></span><br><span class="line">$ git branch -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新分支，新的分支基于上一次提交建立</span></span><br><span class="line">$ git branch &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改分支名称</span></span><br><span class="line"><span class="comment"># 如果不指定原分支名称则为当前所在分支</span></span><br><span class="line">$ git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class="line"><span class="comment"># 强制修改分支名称</span></span><br><span class="line">$ git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的本地分支</span></span><br><span class="line">$ git branch -d &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除指定的本地分支</span></span><br><span class="line">$ git branch -D &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11-git-checkout">11. git checkout</h2><p>检出命令，用于创建、切换分支等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到已存在的指定分支</span></span><br><span class="line">$ git checkout &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并切换到指定的分支，保留所有的提交记录</span></span><br><span class="line"><span class="comment"># 等同于 &quot;git branch&quot; 和 &quot;git checkout&quot; 两个命令合并</span></span><br><span class="line">$ git checkout -b &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并切换到指定的分支，删除所有的提交记录</span></span><br><span class="line">$ git checkout --orphan &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响</span></span><br><span class="line">$ git checkout &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🍞本文汇总Git命令教程，可作为文档进行查询</summary>
    
    
    
    <category term="Git" scheme="https://www.cameliia.top/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.cameliia.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>2023前端面试系列— HTML &amp;&amp; CSS篇</title>
    <link href="https://www.cameliia.top/posts/100.html"/>
    <id>https://www.cameliia.top/posts/100.html</id>
    <published>2023-03-08T02:00:00.000Z</published>
    <updated>2023-08-01T10:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><div class="note info no-icon flat"><p>本文是我的前端面试系列系列导航，其他章节内容可点击链接查看：</p><ol><li><a href="https://www.cameliia.top/posts/100.html">2023前端面试系列–HTML &amp; CSS 篇</a> ⇦当前位置🪂</li><li><a href="https://www.cameliia.top/posts/101.html">2023前端面试系列-- JS 篇</a></li><li><a href="https://www.cameliia.top/posts/102.html">2023前端面试系列–vue篇</a></li><li><a href="https://www.cameliia.top/posts/103.html">2023前端面试系列–TS篇</a></li><li><a href="https://www.cameliia.top/posts/104.html">2023前端面试系列–React篇</a></li><li><a href="https://www.cameliia.top/posts/105.html">2023前端面试系列–网络篇</a></li><li><a href="https://www.cameliia.top/posts/106.html">2023前端面试系列–浏览器篇</a></li></ol></div><h1>HTML</h1><h2 id="HTML5-新特性、语义化">HTML5 新特性、语义化</h2><ol><li><p><strong>概念</strong>：</p><p>HTML5的语义化指的是<code>合理正确的使用语义化的标签来创建页面结构</code>。【正确的标签做正确的事】</p></li><li><p><strong>语义化标签</strong>：</p><p>header nav main article section aside footer</p></li><li><p><strong>语义化的优点</strong>:</p><ul><li>在<code>没CSS样式的情况下，页面整体也会呈现很好的结构效果</code></li><li><code>代码结构清晰</code>，易于阅读，</li><li><code>利于开发和维护</code> 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。</li><li><code>有利于搜索引擎优化（SEO）</code>，搜索引擎爬虫会根据不同的标签来赋予不同的权重</li></ul></li></ol><h2 id="HTML5新特性有哪些">HTML5新特性有哪些</h2><ul><li>语义化标签: header、footer、section、nav、aside、article</li><li>增强型表单：input 的多个 type</li><li>表单控件，calendar、date、time、email、url、search</li><li>新增表单元素：datalist、keygen、output</li><li>新增表单属性：placehoder、required、min 和 max</li><li>音视频处理API(audio,video)</li><li>canvas / webGL</li><li>拖拽释放(Drag and drop)</li><li>history API</li><li>requestAnimationFrame</li><li>地理位置(Geolocation)API</li><li>webSocket</li><li>web存储 localStorage、SessionStorage</li><li>新事件：onresize、ondrag、onscroll、onmousewheel、onerror、onplay、onpause</li></ul><h1>CSS3</h1><h2 id="CSS3新特性">CSS3新特性</h2><ul><li>圆角 （border-radius:8px）</li><li>新增各种CSS选择器、伪类 （经常用到 :nth-child）</li><li>阴影<br>文字阴影: text-shadow: 2px 2px 2px #000;(水平阴影，垂直阴影，模糊距离，阴影颜色) 盒子阴影: box-shadow: 10px 10px 5px #999</li><li>边框 border-image: url(border.png);</li><li>文字渲染 （Text-decoration）<br>转化为简写属性，可设置text-decoration-color, text-decoration-style,<br>text-decoration-line三个属性，默认值为currentcolor solid none。</li><li>透明色 &amp; 透明度（opacity）</li><li>旋转 （transform）</li><li>旋转 rotate，缩放 scale，倾斜 skew，平移 translate</li><li>动画(animation) &amp; 过渡效果(transition)</li><li>新的布局方式，<br>如 多列布局 multi-columns 、 弹性布局 flexible box 与 网格布局 grid layouts</li><li>线性渐变（gradient）</li><li>多背景（background-image可以设置多个url或linear-gradient）</li><li>媒体查询(@media MDN) (可以看看这个)</li><li>边框可以设置图片（border-image）</li><li>过渡</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*所有属性从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒*/</span> </span><br><span class="line">transition：all,.5s</span><br></pre></td></tr></table></figure><ul><li>动画</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//animation：动画名称，一个周期花费时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），是否反向播放动画（默认normal），是否暂停动画（默认running）</span></span><br><span class="line"><span class="comment">/*执行一次logo2-line动画，运动时间2秒，运动曲线为 linear*/</span></span><br><span class="line"><span class="attr">animation</span>: logo2-line 2s linear;</span><br></pre></td></tr></table></figure><ul><li>形状转换</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//transform:适用于2D或3D转换的元素</span></span><br><span class="line"><span class="comment">//transform-origin：转换元素的位置（围绕那个点进行转换）。默认(x,y,z)：(50%,50%,0)</span></span><br><span class="line"><span class="attr">transform</span>:<span class="title function_">translate</span>(30px,30px);</span><br><span class="line"><span class="attr">transform</span>:<span class="title function_">rotate</span>(30deg);</span><br><span class="line"><span class="attr">transform</span>:<span class="title function_">scale</span>(<span class="number">.8</span>);</span><br></pre></td></tr></table></figure><ul><li>选择器:nth-of-type()</li></ul><h2 id="CSS-选择器及优先级">CSS 选择器及优先级</h2><p><strong>选择器</strong></p><ul><li>id选择器(#myid)</li><li>类选择器(.myclass)</li><li>属性选择器(a[rel=“external”])</li><li>伪类选择器(a:hover, li:nth-child)</li><li>标签选择器(div, h1,p)</li><li>相邻选择器（h1 + p）</li><li>子选择器(ul &gt; li)</li><li>后代选择器(li a)</li><li>通配符选择器(*)</li></ul><p><strong>优先级：</strong></p><ul><li><code>!important</code></li><li>内联样式（1000）</li><li>ID选择器（0100）</li><li>类选择器/属性选择器/伪类选择器（0010）</li><li>元素选择器/伪元素选择器（0001）</li><li>关系选择器/通配符选择器（0000）</li></ul><p>带!important 标记的样式属性优先级最高； 样式表的来源相同时：<br><code>!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</code></p><h2 id="渐进增强与优雅降级的理解及区别">渐进增强与优雅降级的理解及区别</h2><p><strong>渐进增强（Progressive Enhancement）：</strong><br>一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</p><p><strong>优雅降级（Graceful Degradation）：</strong><br>一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。<br><strong>两者区别</strong><br>1、广义：<br>其实要定义一个基准线，在此之上的增强叫做渐进增强，在此之下的兼容叫优雅降级<br>2、狭义：<br>渐进增强一般说的是使用CSS3技术，在不影响老浏览器的正常显示与使用情形下来增强体验，而优雅降级则是体现html标签的语义，以便在js/css的加载失败/被禁用时，也不影响用户的相应功能。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 例子 */</span></span><br><span class="line"><span class="selector-class">.transition</span> &#123; <span class="comment">/*渐进增强写法*/</span></span><br><span class="line">  -webkit-<span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">     -moz-<span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">       -o-<span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">          <span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.transition</span> &#123; <span class="comment">/*优雅降级写法*/</span></span><br><span class="line">          <span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">       -o-<span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">     -moz-<span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">  -webkit-<span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="常见的兼容性问题">常见的兼容性问题</h2><ol><li><p>不同浏览器的标签默认的margin和padding不一样。*{margin:0;padding:0;}</p></li><li><p>IE6双边距bug：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大。hack：display:inline;将其转化为行内属性。</p></li><li><p>设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度。hack：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。</p></li><li><p>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。</p></li><li><p>超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了。解决方法是改变CSS属性的排列顺序:L-V-H-A ( love hate ): a:link {} a:visited {} a:hover {} a:active {}</p></li></ol><h2 id="position-属性的值有哪些及其区别">position 属性的值有哪些及其区别</h2><p><strong>固定定位 <code>fixed</code></strong>： 元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定 位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重叠。</p><p><strong>相对定位 <code>relative</code></strong>： 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直 或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是 否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。</p><p><strong>绝对定位 <code>absolute</code></strong>： 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那 么它的位置相对于。absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。</p><p><strong>粘性定位 <code>sticky</code></strong>： 元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定 位，之后为固定定位。</p><p><strong>默认定位 <code>Static</code></strong>： 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声 明）。 inherit: 规定应该从父元素继承 position 属性的值。</p><h2 id="box-sizing属性">box-sizing属性</h2><p><strong><code>box-sizing</code></strong> 规定两个并排的带边框的框，语法为 box-sizing：content-box/border-box/inherit</p><p><strong><code>content-box</code></strong>：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框。【标准盒子模型】</p><p><strong><code>border-box</code></strong>：为元素设定的宽度和高度决定了元素的边框盒。【IE 盒子模型】</p><p><strong><code>inherit</code></strong>：继承父元素的 box-sizing 值。</p><h2 id="CSS-盒子模型">CSS 盒子模型</h2><p>CSS 盒模型本质上是一个盒子，它包括：边距，边框，填充和实际内容。CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。<br>在标准的盒子模型中，<code>width 指 content 部分的宽度</code>。<br>在 IE 盒子模型中，<code>width 表示 content+padding+border 这三个部分的宽度</code>。</p><p>故在计算盒子的宽度时存在差异：</p><p><strong>标准盒模型：</strong> 一个块的总宽度 = width+margin(左右)+padding(左右)+border(左右)</p><p><strong>怪异盒模型：</strong> 一个块的总宽度 = width+margin（左右）（既 width 已经包含了 padding 和 border 值）</p><h2 id="BFC（块级格式上下文）">BFC（块级格式上下文）</h2><p><strong>BFC的概念</strong></p><p><strong><code>BFC</code></strong> 是 <code>Block Formatting Context </code>的缩写，即块级格式化上下文。<code>BFC</code>是CSS布局的一个概念，是一个独立的渲染区域，规定了内部box如何布局， 并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有内部 box 垂直放置，计算 BFC 的高度的时候，浮动元素也参与计算。</p><p><strong>BFC的原理布局规则</strong></p><ul><li>内部的Box会在<code>垂直方向</code>，一个接一个地放置</li><li>Box<code>垂直方向的距离由margin决定</code>。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反</li><li>BFC的区域<code>不会与float box重叠</code></li><li>BFC是一个独立容器，容器里面的<code>子元素不会影响到外面的元素</code></li><li>计算BFC的高度时，<code>浮动元素也参与计算高度</code></li><li>元素的类型和<code>display属性，决定了这个Box的类型</code>。不同类型的Box会参与不同的<code>Formatting Context</code>。</li></ul><p><strong>如何创建BFC？</strong></p><ul><li>根元素，即HTML元素</li><li>float的值不为none</li><li>position为absolute或fixed</li><li>display的值为inline-block、table-cell、table-caption</li><li>overflow的值不为visible</li></ul><p><strong>BFC的使用场景</strong></p><ul><li>去除边距重叠现象</li><li>清除浮动（让父元素的高度包含子浮动元素）</li><li>避免某元素被浮动元素覆盖</li><li>避免多列布局由于宽度计算四舍五入而自动换行</li></ul><h2 id="让一个元素水平垂直居中">让一个元素水平垂直居中</h2><ul><li><p><strong>水平居中</strong></p><ul><li><p>对于 行内元素 : <code>text-align: center</code>;</p></li><li><p>对于确定宽度的块级元素：</p><p>（1）width和margin实现。<code>margin: 0 auto</code>;</p><p>（2）绝对定位和margin-left: margin-left: (父width - 子width）/2, 前提是父元素position: relative</p></li><li><p>对于宽度未知的块级元素</p><p>（1）<code>table标签配合margin左右auto实现水平居中</code>。使用table标签（或直接将块级元素设值为 display:table），再通过给该标签添加左右margin为auto。</p><p>（2）inline-block实现水平居中方法。display：inline-block和text-align:center实现水平居中。</p><p>（3）<code>绝对定位+transform</code>，translateX可以移动本身元素的50%。</p><p>（4）flex布局使用<code>justify-content:center</code></p></li></ul></li><li><p><strong>垂直居中</strong></p><ol><li>利用 <code>line-height</code> 实现居中，这种方法适合纯文字类</li><li>通过设置父容器 相对定位 ，子级设置 <code>绝对定位</code>，标签通过margin实现自适应居中</li><li>弹性布局 flex :父级设置display: flex; 子级设置margin为auto实现自适应居中</li><li>父级设置相对定位，子级设置绝对定位，并且通过位移 transform 实现</li><li><code>table 布局</code>，父级通过转换成表格形式，<code>然后子级设置 vertical-align 实现</code>。（需要注意的是：vertical-align: middle使用的前提条件是内联元素以及display值为table-cell的元素）。</li></ol></li></ul><h2 id="隐藏页面中某个元素的方法">隐藏页面中某个元素的方法</h2><p>1.<code>opacity：0</code>，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定 一些事件，如click 事件，那么点击该区域，也能触发点击事件的</p><p>2.<code>visibility：hidden</code>，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已 经绑定的事件 ，隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</p><p>3.<code>display：none</code>，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素。 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）</p><blockquote><p>该问题会引出 回流和重绘</p></blockquote><h2 id="用CSS实现三角符号">用CSS实现三角符号</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记忆口诀：盒子宽高均为零，三面边框皆透明。 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">100px</span> solid <span class="number">#ff0</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="页面布局">页面布局</h2><h3 id="1-Flex-布局">1.Flex 布局</h3><p>布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p><p>Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;,用来为盒状模型提供最大的灵活性。指定容器 display: flex 即可。 简单的分为容器属性和元素属性。</p><p>容器的属性：</p><ul><li>flex-direction：决定主轴的方向（即子 item 的排列方法）flex-direction: row | row-reverse | column | column-reverse;</li><li>flex-wrap：决定换行规则 flex-wrap: nowrap | wrap | wrap-reverse;</li><li>flex-flow： .box { flex-flow: || ; }</li><li>justify-content：对其方式，水平主轴对齐方式</li><li>align-items：对齐方式，竖直轴线方向</li><li>align-content</li></ul><p>项目的属性（元素的属性）：</p><ul><li>order 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0</li><li>flex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大</li><li>flex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果 定义个 item 的 flow-shrink 为 0，则为不缩小</li><li>flex-basis 属性：定义了在分配多余的空间，项目占据的空间。</li><li>flex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto。</li><li>align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖</li><li>align-items，默认属 性为 auto，表示继承父元素的 align-items 比如说，用 flex 实现圣杯布局</li></ul><h3 id="2-Rem-布局">2.Rem 布局</h3><p>首先 Rem 相对于根(html)的 font-size 大小来计算。简单的说它就是一个相对单例 如:font-size:10px;,那么（1rem = 10px）了解计算原理后首先解决怎么在不同设备上设置 html 的 font-size 大小。其实 rem 布局的本质是等比缩放，一般是基于宽度。</p><p><strong>优点</strong>：可以快速适用移动端布局，字体，图片高度<br><strong>缺点</strong>：</p><ul><li>目前 ie 不支持，对 pc 页面来讲使用次数不多；\</li><li>数据量大：所有的图片，盒子都需要我们去给一个准确的值；才能保证不同机型的适配；\</li><li>在响应式布局中，必须通过 js 来动态控制根元素 font-size 的大小。也就是说 css 样式和 js 代码有一定的耦合性。且必须将改变 font-size 的代码放在 css 样式之前。</li></ul><h3 id="3-百分比布局">3.百分比布局</h3><p>通过百分比单位 &quot; % &quot; 来实现响应式的效果。通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。 直观的理解，我们可能会认为子元素的百分比完全相对于直接父元素，height 百分比相 对于 height，width 百分比相对于 width。 padding、border、margin 等等不论是垂直方向还是水平方向，都相对于直接父元素的 width。 除了 border-radius 外，还有比如 translate、background-size 等都是相对于自身的。</p><p><strong>缺点</strong>：</p><ul><li>计算困难</li><li>各个属性中如果使用百分比，相对父元素的属性并不是唯一的。造成我们使用百分比单位容易使布局问题变得复杂。</li></ul><h3 id="4-浮动布局">4.浮动布局</h3><p>浮动布局:当元素浮动以后可以向左或向右移动，直到它的外边缘碰到包含它的框或者另外一个浮动元素的边框为止。元素浮动以后会脱离正常的文档流，所以文档的普通流中的框就变的好像浮动元素不存在一样。</p><p><strong>优点</strong></p><p>这样做的优点就是在图文混排的时候可以很好的使文字环绕在图片周围。另外当元素浮动了起来之后，它有着块级元素的一些性质例如可以设置宽高等，但它与inline-block还是有一些区别的，第一个就是关于横向排序的时候，float可以设置方向而inline-block方向是固定的；还有一个就是inline-block在使用时有时会有空白间隙的问题</p><p><strong>缺点</strong></p><p>最明显的缺点就是浮动元素一旦脱离了文档流，就无法撑起父元素，<code>会造成父级元素高度塌陷</code>。</p><h2 id="如何使用rem或viewport进行移动端适配">如何使用rem或viewport进行移动端适配</h2><p><strong>rem适配原理：</strong></p><p>改变了一个元素在不同设备上占据的css像素的个数</p><p>rem适配的优缺点</p><ul><li>优点：没有破坏完美视口</li><li>缺点：px值转换rem太过于复杂(下面我们使用less来解决这个问题)</li></ul><p><strong>viewport适配的原理</strong></p><p>viewport适配方案中，每一个元素在不同设备上占据的css像素的个数是一样的。但是css像素和物理像素的比例是不一样的，等比的</p><p>viewport适配的优缺点</p><ul><li>在我们设计图上所量取的大小即为我们可以设置的像素大小，即所量即所设</li><li>缺点破坏完美视口</li></ul><h2 id="清除浮动的方式">清除浮动的方式</h2><ul><li>添加额外标签</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    //添加额外标签并且添加clear属性</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear:both&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    //也可以加一个br标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>父级添加overflow属性，或者设置高度</li><li>建立伪类选择器清除浮动</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在css中添加:after伪元素</span></span><br><span class="line">.<span class="property">parent</span>:after&#123;</span><br><span class="line">    <span class="comment">/* 设置添加子元素的内容是空 */</span></span><br><span class="line">    <span class="attr">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">/* 设置添加子元素为块级元素 */</span></span><br><span class="line">    <span class="attr">display</span>: block;</span><br><span class="line">    <span class="comment">/* 设置添加的子元素的高度0 */</span></span><br><span class="line">    <span class="attr">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 设置添加子元素看不见 */</span></span><br><span class="line">    <span class="attr">visibility</span>: hidden;</span><br><span class="line">    <span class="comment">/* 设置clear：both */</span></span><br><span class="line">    <span class="attr">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS预处理器Sass、Less、Stylus的区别">CSS预处理器Sass、Less、Stylus的区别</h2><p>什么事CSS预处理器?</p><p>CSS预处理器是一种语言用来为CSS增加一些变成的特性，无需考虑浏览器兼容问题，例如你可以在CSS中使用变量，简单的程序逻辑、函数等在编程语言中的一些基本技巧，可以让CSS更加简洁，适应性更强，代码更直观等诸多好处<br>基本语法区别</p><p>**<code>Sass</code>**是以.sass为扩展名，<code>Less</code>是以.less为扩展名，<code>Stylus</code>是以.styl为扩展名<br>变量的区别</p><p><code>Sass</code> 变量必须是以<code>$</code>开头的，然后变量和值之间使用冒号（：）隔开，和css属性是一样的。<br><code>Less</code> 变量是以<code>@</code>开头的，其余sass都是一样的。<br><code>Stylus</code> 对变量是没有任何设定的，可以是以$开头或者任意字符，而且变量之间可以冒号，空格隔开，但是在stylus中不能用@开头<br>三种预处理器都有：嵌套、运算符、颜色函数、导入、继承、混入。Stylus还有一些高级特性。例如循环、判断等</p>]]></content>
    
    
    <summary type="html">🥬本文汇总HTML &amp;&amp; CSS，可作为文档进行查询</summary>
    
    
    
    <category term="面试题" scheme="https://www.cameliia.top/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面试题" scheme="https://www.cameliia.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2023前端面试系列— Vue篇</title>
    <link href="https://www.cameliia.top/posts/102.html"/>
    <id>https://www.cameliia.top/posts/102.html</id>
    <published>2023-03-08T02:00:00.000Z</published>
    <updated>2023-08-01T10:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info no-icon flat"><p>本文是我的前端面试系列系列导航，其他章节内容可点击链接查看：</p><ol><li><a href="https://www.cameliia.top/posts/100.html">2023前端面试系列–HTML &amp; CSS 篇</a> ⇦当前位置🪂</li><li><a href="https://www.cameliia.top/posts/101.html">2023前端面试系列-- JS 篇</a></li><li><a href="https://www.cameliia.top/posts/102.html">2023前端面试系列–vue篇</a></li><li><a href="https://www.cameliia.top/posts/103.html">2023前端面试系列–TS篇</a></li><li><a href="https://www.cameliia.top/posts/104.html">2023前端面试系列–React篇</a></li><li><a href="https://www.cameliia.top/posts/105.html">2023前端面试系列–网络篇</a></li><li><a href="https://www.cameliia.top/posts/106.html">2023前端面试系列–浏览器篇</a></li></ol></div><h1>Vue 面试专题</h1><h2 id="简述MVVM">简述MVVM</h2><p><strong>什么是MVVM？</strong></p><p><code>视图模型双向绑定</code>，是<code>Model-View-ViewModel</code>的缩写，也就是把<code>MVC</code>中的<code>Controller</code>演变成<code>ViewModel。Model</code>层代表数据模型，<code>View</code>代表UI组件，<code>ViewModel</code>是<code>View</code>和<code>Model</code>层的桥梁，数据会绑定到<code>viewModel</code>层并自动将数据渲染到页面中，视图变化的时候会通知<code>viewModel</code>层更新数据。以前是操作DOM结构更新视图，现在是<code>数据驱动视图</code>。</p><p><strong>MVVM的优点：</strong></p><p>1.<code>低耦合</code>。视图（View）可以独立于Model变化和修改，一个Model可以绑定到不同的View上，当View变化的时候Model可以不变化，当Model变化的时候View也可以不变；<br>2.<code>可重用性</code>。你可以把一些视图逻辑放在一个Model里面，让很多View重用这段视图逻辑。<br>3.<code>独立开发</code>。开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计。<br>4.<code>可测试</code>。</p><h2 id="Vue底层实现原理">Vue底层实现原理</h2><p>vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调<br>Vue是一个典型的MVVM框架，模型（Model）只是普通的javascript对象，修改它则试图（View）会自动更新。这种设计让状态管理变得非常简单而直观</p><p><strong>Observer（数据监听器）</strong> : Observer的核心是通过Object.defineProprtty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher</p><p><strong>Watcher（订阅者）</strong> : Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是：</p><ol><li>在自身实例化时往属性订阅器(dep)里面添加自己</li><li>自身必须有一个update()方法</li><li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调</li></ol><p><strong>Compile（指令解析器）</strong> : Compile主要做的事情是解析模板指令，将模板中变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加鉴定数据的订阅者，一旦数据有变动，收到通知，更新试图</p><h2 id="谈谈对vue生命周期的理解？">谈谈对vue生命周期的理解？</h2><p>每个<code>Vue</code>实例在创建时都会经过一系列的初始化过程，<code>vue</code>的生命周期钩子，就是说在达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件</p><ul><li><code>create阶段</code>：vue实例被创建<br><code>beforeCreate</code>: 最初调用触发，创建前，此时data和methods中的数据都还没有初始化，data和events都不能用<br><code>created</code>： 创建完毕，data中有值，未挂载，data和events已经初始化好，data已经具有响应式；在这里可以发送请求</li><li><code>mount阶段</code>： vue实例被挂载到真实DOM节点<br><code>beforeMount</code>：在模版编译之后，渲染之前触发，可以发起服务端请求，去数据，ssr中不可用，基本用不上这个hook<br><code>mounted</code>: 在渲染之后触发，此时可以操作DOM，并能访问组件中的DOM以及$ref,SSR中不可用</li><li><code>update阶段</code>：当vue实例里面的data数据变化时，触发组件的重新渲染<br><code>beforeUpdate</code> :更新前，在数据变化后，模版改变前触发，切勿使用它监听数据变化<br><code>updated</code>：更新后，在数据改变后，模版改变后触发，常用于重渲染案后的打点，性能检测或触发vue组件中非vue组件的更新</li><li><code>destroy阶段</code>：vue实例被销毁<br><code>beforeDestroy</code>：实例被销毁前，组件卸载前触发，此时可以手动销毁一些方法，可以在此时清理事件、计时器或者取消订阅操作<br><code>destroyed</code>:卸载完毕后触发，销毁后，可以做最后的打点或事件触发操作</li></ul><h3 id="组件生命周期">组件生命周期</h3><p>生命周期（父子组件） 父组件beforeCreate --&gt; 父组件created --&gt; 父组件beforeMount --&gt; 子组件beforeCreate --&gt; 子组件created --&gt; 子组件beforeMount --&gt; 子组件 mounted --&gt; 父组件mounted --&gt;父组件beforeUpdate --&gt;子组件beforeDestroy–&gt; 子组件destroyed --&gt; 父组件updated</p><p><strong>加载渲染过程</strong> 父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</p><p><strong>挂载阶段</strong> 父created-&gt;子created-&gt;子mounted-&gt;父mounted</p><p><strong>父组件更新阶段</strong> 父beforeUpdate-&gt;父updated</p><p><strong>子组件更新阶段</strong> 父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p><p><strong>销毁阶段</strong> 父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p><h2 id="computed与watch"><code>computed与watch</code></h2><p><code>computed</code>计算属性，依赖其它属性计算值，内部任一依赖项的变化都会重新执行该函数，计算属性有缓存，多次重复使用计算属性时会从缓存中获取返回值，计算属性必须要有<code>return</code>关键词。<br><code>watch</code>侦听到某一数据的变化从而触发函数。当数据为对象类型时，对象中的属性值变化时需要使用深度侦听<code>deep</code>属性，也可在页面第一次加载时使用立即侦听<code>immdiate</code>属性。</p><p><strong>使用场景</strong> <code>computed</code>：当一个属性受多个属性影响的时候使用，例：购物车商品结算功能 <code>watch</code>：当一条数据影响多条数据的时候使用，例：搜索数据</p><h2 id="Vue-的响应式原理">Vue 的响应式原理</h2><p>Vue 2 中的数据响应式会根据数据类型做不同的处理。如果是对象，则通过<code>Object.defineProperty(obj,key,descriptor)</code>拦截对象属性访问，当数据被访问或改变时，感知并作出反应；如果是数组，则通过覆盖数组原型的方法，扩展它的7个变更方法（push、pop、shift、unshift、splice、sort、reverse），使这些方法可以额外的做更新通知，从而做出响应。</p><p>缺点：</p><ul><li>初始化时的递归遍历会造成性能损失；</li><li>通知更新过程需要维护大量 <code>dep</code> 实例和 <code>watcher</code> 实例，额外占用内存较多；</li><li>新增或删除对象属性无法拦截，需要通过 <code>Vue.set</code> 及 <code>delete </code>这样的 API 才能生效；</li><li>对于ES6中新产生的Map、Set这些数据结构不支持。</li></ul><p>Vue 3 中利用ES6的<code>Proxy</code>机制代理需要响应化的数据。可以同时支持对象和数组，动态属性增、删都可以拦截，新增数据结构均支持，对象嵌套属性运行时递归，用到时才代理，也不需要维护特别多的依赖关系，性能取得很大进步。</p><h2 id="Vue中key的作用？">Vue中key的作用？</h2><p><code>key</code>的作用主要是<code>为了更加高效的更新虚拟 DOM</code>。<br>Vue 判断两个节点是否相同时，主要是判断两者的<code>key</code>和元素类型<code>tag</code>。因此，如果不设置key<br>，它的值就是<code>undefined</code>，则可能永远认为这是两个相同的节点，只能去做更新操作，将造成大量的 DOM 更新操作。</p><h2 id="组件中的data为什么是一个函数？">组件中的data为什么是一个函数？</h2><p>1.一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。<br>2.如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。</p><h2 id="为什么v-for和v-if不建议用在一起">为什么v-for和v-if不建议用在一起</h2><p>1.当 v-for 和 v-if 处于同一个节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费<br>2.这种场景建议使用 computed，先对数据进行过滤</p><p>注意：3.x 版本中 <code>v-if</code> 总是优先于 <code>v-for</code> 生效。由于语法上存在歧义，建议避免在同一元素上同时使用两者。比起在模板层面管理相关逻辑，更好的办法是通过创建计算属性筛选出列表，并以此创建可见元素。</p><h2 id="React-Vue-项目中-key-的作用">React/Vue 项目中 key 的作用</h2><ol><li><p>key的作用是为了在diff算法执行时更快的找到对应的节点，<code>提高diff速度，更高效的更新虚拟DOM</code>;</p><p>vue和react都是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。</p></li><li><p>为了在数据变化时强制更新组件，以避免<code>“就地复用”</code>带来的副作用。</p><p>当 Vue.js 用 <code>v-for</code> 更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。重复的key会造成渲染错误。</p></li></ol><h3 id="数组扁平化转换">数组扁平化转换</h3><p>在说到模版编译的时候，有可能会提到数组的转换，一般就用递归处理<br>将 [1,2,3,[4,5]] 转换成</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    children:[</span><br><span class="line">        &#123;</span><br><span class="line">            value:<span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            value:<span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            value:<span class="number">3</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            children:[</span><br><span class="line">                &#123;</span><br><span class="line">                    value:<span class="number">4</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    value:<span class="number">5</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试数组</span></span><br><span class="line"><span class="keyword">var</span> arr =[<span class="number">1</span>,<span class="number">2</span>，<span class="number">3</span>，[<span class="number">4</span>,<span class="number">5</span>]];</span><br><span class="line"><span class="comment">// 转换函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">convert</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="comment">//准备一个接收结果数组</span></span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="comment">// 遍历传入的 arr 的每一项</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//如果遍历到的数字是number，直接放进入</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> arr[i] == <span class="string">&#x27;number&#x27;</span>)&#123;</span><br><span class="line">            result.<span class="title function_">push</span>(&#123;</span><br><span class="line">                <span class="attr">value</span>:arr[i]</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr[i]))&#123;</span><br><span class="line">            <span class="comment">//如果遍历到这个项目是数组，那么就递归</span></span><br><span class="line">            result.<span class="title function_">push</span>(&#123;</span><br><span class="line">                <span class="attr">children</span>: <span class="title function_">convert</span>(arr[i])</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="title function_">convert</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o);</span><br></pre></td></tr></table></figure><h2 id="说说你对-SPA-单页面的理解，它的优缺点分别是什么？">说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h2><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 <code>HTML</code>、<code>JavaScript</code> 和 <code>CSS</code>。一旦页面加载完成，<code>SPA</code> 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p><ol><li>优点：</li></ol><ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li><li>基于上面一点，SPA 相对对服务器压力小；</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul><ol start="2"><li>缺点：</li></ol><ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 <code>JavaScript</code>、<code>CSS</code> 统一加载，部分页面按需加载；</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 <code>SEO</code> 上其有着天然的弱势。</li></ul><h2 id="vue组件的通信方式">vue组件的通信方式</h2><ol><li><p>父子组件通信：<br>父向子传递数据是通过<code>props</code>，子向父是通过<code>$emit</code>触发事件；通过父链/子链也可以通信（<code>$parent/$children</code>）；<br><code>ref</code>也可以访问组件实例；<code>provide/inject</code>；<code>$attrs/$listeners</code>。</p></li><li><p>兄弟组件通信：<br>全局事件总线<code>EventBus</code>、<code>Vuex</code>。<br><code>$emit</code>/<code>$on</code> 自定义事件 兄弟组件通信<br><code>Event Bus</code> 实现跨组件通信 <code>Vue.prototype.$bus = new Vue()</code> 自定义事件</p></li><li><p>跨层级组件通信：<br>全局事件总线<code>EventBus</code>、<code>Vuex</code>、<code>provide/inject。</code></p></li></ol><h2 id="emit-后面的两个参数是什么">$emit 后面的两个参数是什么</h2><p>1、父组件可以使用 props 把数据传给子组件。<br>2、子组件可以使用 $emit,让父组件监听到自定义事件 。</p><p><code>vm.$emit( event, arg );</code>//触发当前实例上的事件，要传递的参数<br><code>vm.$on( event, fn );</code>//监听event事件后运行 fn；</p><p>子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;train-city&quot;&gt;</span><br><span class="line">    &lt;h3&gt;父组件传给子组件的toCity:&#123;&#123;sendData&#125;&#125;&lt;/h3&gt; </span><br><span class="line">    &lt;br/&gt;&lt;button @click=&#x27;select(`大连`)&#x27;&gt;点击此处将‘大连’发射给父组件&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name:&#x27;trainCity&#x27;,</span><br><span class="line">    props:[&#x27;sendData&#x27;], // 用来接收父组件传给子组件的数据</span><br><span class="line">    methods:&#123;</span><br><span class="line">      select(val) &#123;</span><br><span class="line">        let data = &#123;</span><br><span class="line">          cityName: val</span><br><span class="line">        &#125;;</span><br><span class="line">        this.$emit(&#x27;showCityName&#x27;,data);//select事件触发后，自动触发showCityName事件</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div&gt;父组件的toCity&#123;&#123;toCity&#125;&#125;&lt;/div&gt;</span><br><span class="line">        &lt;train-city @showCityName=&quot;updateCity&quot; :sendData=&quot;toCity&quot;&gt;&lt;/train-city&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name:&#x27;index&#x27;,</span><br><span class="line">    components: &#123;&#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        toCity:&quot;北京&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      updateCity(data)&#123;//触发子组件城市选择-选择城市的事件</span><br><span class="line">        this.toCity = data.cityName;//改变了父组件的值</span><br><span class="line">        console.log(&#x27;toCity:&#x27;+this.toCity)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="nextTick的实现">nextTick的实现</h2><p><strong>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM</strong>。<br><code>nextTick</code>是 Vue 提供的一个全局 API，由于 Vue 的异步更新策略，导致我们对数据修改后不会直接体现在 DOM 上，此时如果想要立即获取更新后的 DOM 状态，就需要借助该方法。<br>Vue 在更新<code>DOM</code>时是异步执行的。当数据发生变化，Vue 将开启一个异步更新队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 <code>watcher</code> 被多次触发，只会被推入队列一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。<code>nextTick</code>方法会在队列中加入一个回调函数，确保该函数在前面的 DOM 操作完成后才调用。</p><h3 id="使用场景：">使用场景：</h3><ul><li>如果想要在修改数据后立刻得到更新后的DOM结构，可以使用<code>Vue.nextTick()</code></li><li>在<code>created</code>生命周期中进行<code>DOM</code>操作</li></ul><h2 id="使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽">使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽</h2><p>vue中的插槽是一个非常好用的东西slot说白了就是一个占位的 在vue当中插槽包含三种一种是默认插槽（匿名）一种是具名插槽还有一种就是作用域插槽 匿名插槽就是没有名字的只要默认的都填到这里具名插槽指的是具有名字的</p><h2 id="keep-alive的实现">keep-alive的实现</h2><p>keep-alive是Vue.js的一个内置组件。它能够不活动的组件实例保存在内存中，而不是直接将其销毁，它是一个抽象组件，不会被渲染到真实DOM中，也不会出现在父组件链中。</p><p>作用：实现组件缓存，保持这些组件的状态，以避免反复渲染导致的性能问题。 需要缓存组件 频繁切换，不需要重复渲染</p><p>场景：tabs标签页 后台导航，vue性能优化</p><p>原理：<code>Vue.js</code>内部将<code>DOM</code>节点抽象成了一个个的<code>VNode</code>节点，<code>keep-alive</code>组件的缓存也是基于<code>VNode</code>节点的而不是直接存储<code>DOM</code>结构。它将满足条件<code>（pruneCache与pruneCache）</code>的组件在<code>cache</code>对象中缓存起来，在需要重新渲染的时候再将<code>vnode</code>节点从<code>cache</code>对象中取出并渲染。</p><h2 id="keep-alive-的属性">keep-alive 的属性</h2><p>它提供了include与exclude两个属性，允许组件有条件地进行缓存。</p><p>include定义缓存白名单，keep-alive会缓存命中的组件；exclude定义缓存黑名单，被命中的组件将不会被缓存；max定义缓存组件上限，超出上限使用LRU的策略置换缓存数据。</p><p>在动态组件中的应用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive :include=<span class="string">&quot;whiteList&quot;</span> :exclude=<span class="string">&quot;blackList&quot;</span> :max=<span class="string">&quot;amount&quot;</span>&gt;</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;currentComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>在vue-router中的应用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive :include=<span class="string">&quot;whiteList&quot;</span> :exclude=<span class="string">&quot;blackList&quot;</span> :max=<span class="string">&quot;amount&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>vue 中完整示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">coma</span> <span class="attr">v-if</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">coma</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">comb</span> <span class="attr">v-else</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">comb</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;test=handleClick&quot;</span>&gt;</span>请点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        handleClick () &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">test</span> = !<span class="variable language_">this</span>.<span class="property">test</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考:<br><a href="https://cn.vuejs.org/v2/api/#keep-alive">keep-alive 官网</a></p><p><a href="https://www.jianshu.com/p/9523bb439950">keep-alive实现原理</a></p><p><a href="https://blog.csdn.net/weixin_38189842/article/details/103999989">Vue keep-alive的实现原理</a></p><h2 id="mixin">mixin</h2><p><code>mixin</code>（混入）， 它提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。<br>使用场景： 不同组件中经常会用到一些相同或相似的代码，这些代码的功能相对独立。可以通过mixin 将相同或相似的代码提出来。<br>缺点：<br>变量来源不明确<br>多 mixin 可能会造成命名冲突（解决方式：Vue 3的组合API）<br>mixin 和组件出现多对多的关系，使项目复杂度变高。<br>在Vue 中，修饰符处理了许多 DOM 事件的细节，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理。Vue中修饰符分为以下几种：</p><h2 id="Vue-中的修饰符有哪些">Vue 中的修饰符有哪些</h2><p>在Vue 中，修饰符处理了许多 DOM 事件的细节，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理。Vue中修饰符分为以下几种：</p><ol><li>表单修饰符<br><code>lazy</code> 填完信息，光标离开标签的时候，才会将值赋予给value，也就是在<code>change</code>事件之后再进行信息同步。<br><code>number</code> 自动将用户输入值转化为数值类型，但如果这个值无法被<code>parseFloat</code>解析，则会返回原来的值。<br><code>trim</code>自动过滤用户输入的首尾空格，而中间的空格不会被过滤。</li><li>事件修饰符<br><code>stop</code> 阻止了事件冒泡，相当于调用了<code>event.stopPropagation</code>方法。<br><code>prevent</code> 阻止了事件的默认行为，相当于调用了<code>event.preventDefault</code>方法。<br><code>self</code> 只当在 <code>event.target</code> 是当前元素自身时触发处理函数。<br><code>once</code> 绑定了事件以后只能触发一次，第二次就不会触发。<br><code>capture</code>使用事件捕获模式，即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理。<br><code>passive</code> 告诉浏览器你不想阻止事件的默认行为。<br><code>native</code> 让组件变成像html内置标签那样监听根元素的原生事件，否则组件上使用 <code>v-on</code> 只会监听自定义事件。</li><li>鼠标按键修饰符<br><code>left</code> 左键点击。<br><code>right</code> 右键点击。<br><code>middle</code> 中键点击。</li><li>键值修饰符<br>键盘修饰符是用来修饰键盘事件（<code>onkeyup</code>，<code>onkeydown</code>）的，有如下：<br><code>keyCode</code>存在很多，但vue为我们提供了别名，分为以下两种：</li></ol><p>普通键（enter、tab、delete、space、esc、up…）<br>系统修饰键（ctrl、alt、meta、shift…）</p><h2 id="如何实现-v-model-双向绑定">如何实现 v-model,双向绑定</h2><ol><li>概念：<br>Vue 中双向绑定是一个指令<code>v-model</code>，可以绑定一个响应式数据到视图，同时视图的变化能改变该值。<code>v-model</code>是语法糖，默认情况下相当于:<code>value</code>和<code>@input</code>，使用<code>v-model</code>可以减少大量繁琐的事件处理代码，提高开发效率。</li><li>使用：<br>通常在表单项上使用<code>v-model</code>，还可以在自定义组件上使用，表示某个值的输入和输出控制。</li><li>原理：<br><code>v-model</code>是一个指令，双向绑定实际上是Vue 的编译器完成的，通过输出包含<code>v-model</code>模版的组件渲染函数，实际上还是<code>value</code>属性的绑定及<code>input</code>事件监听，事件回调函数中会做相应变量的更新操作。</li></ol><h2 id="Vue-Router中的常用路由模式和原理？">Vue Router中的常用路由模式和原理？</h2><ol><li>hash 模式：<br><code>location.hash</code>的值就是url中 # 后面的东西。它的特点在于：hash虽然出现url中，但不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。<br>可以为hash的改变添加监听事件<code>window.addEventListener(&quot;hashchange&quot;, funcRef, false)</code>，每一次改变<code>hash (window.location.hash)</code>，都会在浏览器的访问历史中增加一个记录，利用hash的以上特点，就可以实现前端路由更新视图但不重新请求页面的功能了。<br>特点：兼容性好但是不美观</li><li>history 模式：<br>利用 HTML5 History Interface 中新增的<code>pushState()</code>和<code>replaceState()</code>方法。<br>这两个方法应用于浏览器的历史记录栈，在当前已有的<code>back</code>、<code>forward</code>、<code>go</code> 的基础上，他们提供了对历史记录进行修改的功能。<br>这两个方法有个共同点：当调用他们修改浏览器历史记录栈后，虽然当前url改变了，但浏览器不会刷新页面，这就为单页面应用前端路由“更新视图但不重新请求页面”提供了基础<br>特点：虽然美观，但是刷新会出现 404 需要后端进行配置。</li></ol><h3 id="动态路由？">动态路由？</h3><p>很多时候，我们需要将给定匹配模式的路由映射到同一个组件，这种情况就需要定义动态路由。例如，我们有一个 User组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用动态路径参数（dynamic segment）来达到这个效果：<code>&#123;path: '/user/:id', compenent: User&#125;</code>，其中:id就是动态路径参数。</p><h2 id="Vuex的理解及使用场景">Vuex的理解及使用场景</h2><p>Vuex 是一个专为 Vue 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。</p><ol><li>Vuex 的状态存储是响应式的；当 Vue 组件从 store 中读取状态的时候，</li></ol><p>若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新 2. 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation， 这样使得我们可以方便地跟踪每一个状态的变化 Vuex主要包括以下几个核心模块：</p><ol><li><code>State</code>：定义了应用的状态数据</li><li><code>Getter</code>：在 store 中定义“getter”（可以认为是 store 的计算属性）， getter 的返回值会根据它的依赖被缓存起来， 且只有当它的依赖值发生了改变才会被重新计算</li><li><code>Mutation</code>：是唯一更改 store 中状态的方法，且必须是同步函数</li><li><code>Action</code>：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作</li><li><code>Module</code>：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中</li></ol><h2 id="页面刷新后Vuex-状态丢失怎么解决？">页面刷新后Vuex 状态丢失怎么解决？</h2><p>Vuex 只是在内存中保存状态，刷新后就会丢失，如果要持久化就需要保存起来。</p><ol><li><code>localStorage</code>就很合适，提交<code>mutation</code>的时候同时存入<code>localStorage</code>，在<code>store</code>中把值取出来作为<code>state</code>的初始值即可。</li><li>也可以使用第三方插件，推荐使用<code>vuex-persist</code>插件，它是为 <code>Vuex</code> 持久化储存而生的一个插件，不需要你手动存取<code>storage</code>，而是直接将状态保存至 <code>cookie</code> 或者 <code>localStorage</code>中。</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7249773a1634f779c48f3f0ffabf968~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h2 id="了解哪些-Vue-的性能优化方法？">了解哪些 Vue 的性能优化方法？</h2><ol><li>路由懒加载。有效拆分应用大小，访问时才异步加载。</li><li>keep-alive缓存页面。避免重复创建组件实例，且能保留缓存组件状态。</li><li>v-for遍历避免同时使用v-if。实际上在 Vue 3 中已经是一个错误用法了。</li><li>长列表性能优化，可采用虚拟列表。</li><li>v-once。不再变化的数据使用v-once。</li><li>事件销毁。组件销毁后把全局变量和定时器销毁。</li><li>图片懒加载。</li><li>第三方插件按需引入。</li><li>子组件分割。较重的状态组件适合拆分。</li><li>服务端渲染。</li></ol>]]></content>
    
    
    <summary type="html">🍝本文汇总Vue，可作为文档进行查询</summary>
    
    
    
    <category term="面试题" scheme="https://www.cameliia.top/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面试题" scheme="https://www.cameliia.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2023前端面试系列— JavaScript篇</title>
    <link href="https://www.cameliia.top/posts/101.html"/>
    <id>https://www.cameliia.top/posts/101.html</id>
    <published>2023-03-08T02:00:00.000Z</published>
    <updated>2023-08-01T10:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info no-icon flat"><p>本文是我的前端面试系列系列导航，其他章节内容可点击链接查看：</p><ol><li><a href="https://www.cameliia.top/posts/100.html">2023前端面试系列–HTML &amp; CSS 篇</a> ⇦当前位置🪂</li><li><a href="https://www.cameliia.top/posts/101.html">2023前端面试系列-- JS 篇</a></li><li><a href="https://www.cameliia.top/posts/102.html">2023前端面试系列–vue篇</a></li><li><a href="https://www.cameliia.top/posts/103.html">2023前端面试系列–TS篇</a></li><li><a href="https://www.cameliia.top/posts/104.html">2023前端面试系列–React篇</a></li><li><a href="https://www.cameliia.top/posts/105.html">2023前端面试系列–网络篇</a></li><li><a href="https://www.cameliia.top/posts/106.html">2023前端面试系列–浏览器篇</a></li></ol></div><h1>JavaScript</h1><h2 id="JS中的8种数据类型及区别">JS中的8种数据类型及区别</h2><p>包括值类型(基本对象类型)和引用类型(复杂对象类型)</p><p><strong>基本类型(值类型)：</strong> <code>Number</code>(数字),<code>String</code>(字符串),<code>Boolean</code>(布尔),<code>Symbol</code>(符号),<code>null</code>(空),<code>undefined</code>(未定义)在内存中占据固定大小，保存在栈内存中</p><p><strong>引用类型(复杂数据类型)：</strong> <code>Object</code>(对象)、<code>Function</code>(函数)。其他还有<code>Array</code>(数组)、<code>Date</code>(日期)、<code>RegExp</code>(正则表达式)、特殊的基本包装类型(String、Number、Boolean) 以及单体内置对象(Global、Math)等 引用类型的值是对象 保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址。</p><p><strong>使用场景：</strong></p><p><code>Symbol</code>：使用Symbol来作为对象属性名(key)  利用该特性，把一些不需要对外操作和访问的属性使用Symbol来定义</p><p><code>BigInt</code>：由于在 Number 与 BigInt 之间进行转换会损失精度，因而建议仅在值可能大于253 时使用 BigInt 类型，并且不在两种类型之间进行相互转换。</p><h2 id="JS中的数据类型检测方案">JS中的数据类型检测方案</h2><h3 id="1-typeof">1.typeof</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">1</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;mc&#x27;</span>);            <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Symbol</span>)           <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="variable language_">console</span>.<span class="title function_">log</span>());   <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []);              <span class="comment">// object </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>优点：能够快速区分基本数据类型</p><p>缺点：不能将Object、Array和Null区分，都返回object</p><h3 id="2-instanceof">2.instanceof</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="title class_">String</span>);                <span class="comment">// false  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>);                   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象</p><p>缺点：Number，Boolean，String基本数据类型不能判断</p><h3 id="3-Object-prototype-toString-call">3.Object.prototype.toString.call()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="number">1</span>));      <span class="comment">//[object Number]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="literal">true</span>));   <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="string">&#x27;mc&#x27;</span>));   <span class="comment">//[object String]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>([]));     <span class="comment">//[object Array]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(&#123;&#125;));     <span class="comment">//[object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)); <span class="comment">//[object Function]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="literal">undefined</span>));  <span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="literal">null</span>)); <span class="comment">//[object Null]</span></span><br></pre></td></tr></table></figure><p>优点：精准判断数据类型</p><p>缺点：写法繁琐不容易记，推荐进行封装后使用</p><h3 id="instanceof-的作用">instanceof 的作用</h3><p>用于判断一个引用类型是否属于某构造函数；</p><p>还可以在继承关系中用来判断一个实例是否属于它的父类型。</p><h3 id="instanceof-和-typeof-的区别：">instanceof 和 typeof 的区别：</h3><p>typeof在对值类型number、string、boolean 、null 、 undefined、 以及引用类型的function的反应是精准的；但是，对于对象{ } 、数组[ ] 、null 都会返回object</p><p>为了弥补这一点，instanceof 从原型的角度，来判断某引用属于哪个构造函数，从而判定它的数据类型。</p><h2 id="ES6新增特性">ES6新增特性:</h2><ol><li>const let</li><li>箭头函数(没有this指向,会从作用域上一级继承this)</li><li>解构赋值</li><li>形参默认值</li><li>类 class(Es5之前用proptype代替class)</li><li>扩展运算符</li><li>模板字符串</li><li>promise(重点)</li></ol><h2 id="var-let-const">var &amp;&amp; let &amp;&amp; const</h2><p>ES6之前创建变量用的是var,之后创建变量用的是let/const</p><p><strong>三者区别</strong>：</p><ol><li>var定义的变量，<code>没有块的概念，可以跨块访问</code>, 不能跨函数访问。<br>let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。<br>const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，且不能修改。</li><li>var可以<code>先使用，后声明</code>，因为存在变量提升；let必须先声明后使用。</li><li>var是允许在相同作用域内<code>重复声明同一个变量</code>的，而let与const不允许这一现象。</li><li>在全局上下文中，基于let声明的全局变量和全局对象GO（window）没有任何关系 ;<br>var声明的变量会和GO有映射关系；</li><li><code>会产生暂时性死区</code>：</li></ol><blockquote><p>暂时性死区是浏览器的bug：检测一个未被声明的变量类型时，不会报错，会返回undefined<br>如：console.log(typeof a) //undefined<br>而：console.log(typeof a)//未声明之前不能使用<br>let a</p></blockquote><ol start="6"><li>let /const/function会把当前所在的大括号(除函数之外)作为一个全新的块级上下文，应用这个机制，在开发项目的时候，遇到循环事件绑定等类似的需求，无需再自己构建闭包来存储，只要基于let的块作用特征即可解决</li></ol><h2 id="作用域和作用域链">作用域和作用域链</h2><p>创建函数的时候，已经声明了当前函数的作用域==&gt;<code>当前创建函数所处的上下文</code>。如果是在全局下创建的函数就是<code>[[scope]]:EC(G)</code>，函数执行的时候，形成一个全新的私有上下文<code>EC(FN)</code>，供字符串代码执行(进栈执行)</p><p>定义：简单来说作用域就是变量与函数的可访问范围，<code>由当前环境与上层环境的一系列变量对象组成</code><br>1.全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。<br>2.函数作用域：在固定的代码片段才能被访问</p><p>作用：作用域最大的用处就是<code>隔离变量</code>，不同作用域下同名变量不会有冲突。</p><p><strong>作用域链参考链接</strong>一般情况下，变量到 创建该变量 的函数的作用域中取值。但是如果在当前作用域中没有查到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。</p><h2 id="闭包的两大作用：保存-保护">闭包的两大作用：保存/保护</h2><ul><li><p><strong>闭包的概念</strong></p><p>函数执行时形成的私有上下文EC(FN)，正常情况下，代码执行完会出栈后释放;但是特殊情况下，如果当前私有上下文中的某个东西被上下文以外的事物占用了，则上下文不会出栈释放，从而形成不销毁的上下文。 函数执行函数执行过程中，会形成一个全新的私有上下文，可能会被释放，可能不会被释放，不论释放与否，他的作用是：</p></li></ul><p>（1）保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，保护自己的私有变量不受外界干扰（操作自己的私有变量和外界没有关系）；</p><p>（2）保存：如果当前上下文不被释放【只要上下文中的某个东西被外部占用即可】，则存储的这些私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了；</p><p>我们把函数执行形成私有上下文，来保护和保存私有变量机制称为<code>闭包</code>。</p><blockquote><p>闭包是指有权访问另一个函数作用域中的变量的函数–《JavaScript高级程序设计》</p></blockquote><p><strong>稍全面的回答</strong>： 在js中变量的作用域属于函数作用域, 在函数执行完后,作用域就会被清理,内存也会随之被回收,但是由于闭包函数是建立在函数内部的子函数, 由于其可访问上级作用域,即使上级函数执行完, 作用域也不会随之销毁, 这时的子函数(也就是闭包),便拥有了访问上级作用域中变量的权限,即使上级函数执行完后作用域内的值也不会被销毁。</p><ul><li><p><strong>闭包的特性</strong>：</p><ul><li><p>1、内部函数可以访问定义他们外部函数的参数和变量。(作用域链的向上查找，把外围的作用域中的变量值存储在内存中而不是在函数调用完毕后销毁)设计私有的方法和变量，避免全局变量的污染。</p><p>1.1.闭包是密闭的容器，，类似于set、map容器，存储数据的</p><p>1.2.闭包是一个对象，存放数据的格式为 key-value 形式</p></li><li><p>2、函数嵌套函数</p></li><li><p>3、本质是将函数内部和外部连接起来。优点是可以读取函数内部的变量，让这些变量的值始终保存在内存中，不会在函数被调用之后自动清除</p></li></ul></li><li><p><strong>闭包形成的条件</strong>：</p><ol><li>函数的嵌套</li><li>内部函数引用外部函数的局部变量，延长外部函数的变量生命周期</li></ol></li><li><p><strong>闭包的用途</strong>：</p><ol><li>模仿块级作用域</li><li>保护外部函数的变量 能够访问函数定义时所在的词法作用域(阻止其被回收)</li><li>封装私有化变量</li><li>创建模块</li></ol></li><li><p><strong>闭包应用场景</strong></p></li></ul><blockquote><p>闭包的两个场景，闭包的两大作用：<code>保存/保护</code>。 在开发中, 其实我们随处可见闭包的身影, 即一个事件绑定的回调方法; 发送ajax请求成功|失败的回调;setTimeout的延时回调;或者一个函数内部返回另一个匿名函数,这些都是闭包的应用。</p></blockquote><ul><li><strong>闭包的优点</strong>：延长局部变量的生命周期</li><li><strong>闭包缺点</strong>：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</li></ul><h2 id="JS-中-this-的情况">JS 中 this 的情况</h2><ol><li>普通函数调用：通过函数名()直接调用：<code>this</code>指向<code>全局对象window</code>（注意let定义的变量不是window属性，只有window.xxx定义的才是。即let a =’aaa’; this.a是undefined）</li><li>构造函数调用：函数作为构造函数，用new关键字调用时：<code>this</code>指向<code>新new出的对象</code></li><li>对象函数调用：通过对象.函数名()调用的：<code>this</code>指向<code>这个对象</code></li><li>箭头函数调用：箭头函数里面没有 this ，所以<code>永远是上层作用域this</code>（上下文）</li><li>apply和call调用：函数体内 this 的指向的是 call/apply 方法<code>第一个参数</code>，若为空默认是指向全局对象window。</li><li>函数作为数组的一个元素，通过数组下标调用的：this指向这个数组</li><li>函数作为window内置函数的回调函数调用：this指向window（如setInterval setTimeout 等）</li></ol><h2 id="call-apply-bind-的区别">call/apply/bind 的区别</h2><p>相同：</p><p>1、都是用来改变函数的this对象的指向的。<br>2、第一个参数都是this要指向的对象。<br>3、都可以利用后续参数传参。</p><p>不同：</p><p>apply和call传入的参数列表形式不同。apply 接收 arguments，call接收一串参数列表</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fn</span>.call(obj, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="attribute">fn</span>.apply(obj,<span class="meta"> [1, 2]);</span></span><br></pre></td></tr></table></figure><p>bind：语法和call一模一样，区别在于立即执行还是等待执行，bind不兼容IE6~8<br>bind 主要就是将函数绑定到某个对象，bind()会创建一个函数，返回对应函数便于稍后调用；而apply、call则是立即调用。</p><p>总结：基于Function.prototype上的 <code>apply 、 call 和 bind </code>调用模式，这三个方法都可以显示的指定调用函数的 this 指向。<code>apply</code>接收参数的是数组，<code>call</code>接受参数列表，`` bind<code>方法通过传入一个对象，返回一个</code> this <code>绑定了传入对象的新函数。这个函数的 </code>this<code>指向除了使用</code>new `时会被改变，其他情况下都不会改变。若为空默认是指向全局对象window。</p><h2 id="箭头函数的特性">箭头函数的特性</h2><ol><li><code>箭头函数没有自己的this</code>，会捕获其所在的上下文的this值，作为自己的this值</li><li><code>箭头函数没有constructor</code>，是匿名函数，不能作为构造函数，不能通过new 调用；</li><li><code>没有new.target 属性</code>。在通过new运算符被初始化的函数或构造方法中，new.target返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是undefined</li><li><code>箭头函数不绑定Arguments 对象</code>。取而代之用rest参数…解决。由于 箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定this），他们的第一个参数会被忽略。（这种现象对于bind方法同样成立）</li><li>箭头函数通过 call()  或   apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。</li><li>箭头函数没有原型属性 Fn.prototype 值为 undefined</li><li>箭头函数不能当做Generator函数,不能使用yield关键字</li></ol><h2 id="原型-原型链">原型 &amp;&amp; 原型链</h2><p><strong>原型关系：</strong></p><ul><li>每个 class都有显示原型 prototype</li><li>每个实例都有隐式原型 <code>__proto__</code></li><li>实例的 <code>__proto__</code> 指向对应 class 的 prototype</li></ul><p>‌ <strong>原型:</strong>  在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一些预定义的属性。其中每个<code>函数对象</code>都有一个<code>prototype</code> 属性，这个属性指向函数的<code>原型对象</code>。</p><blockquote><p>原型链：每一个函数都有proptype属性,内部必有_proto_,当实例化对象访问一个属性的时候,首先会在 自身查找,如找不到,则会向_proto_指向的原型查找,如仍找不到,则会原型中的_proto_指向 上级的原型中查找,直到找到object.proptype._proto_为止(值为null),这种链状称为原型链</p></blockquote><p><strong>特点:</strong>  <code>JavaScript</code>对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p><h2 id="new运算符的实现机制">new运算符的实现机制</h2><ol><li>首先创建了一个新的<code>空对象</code></li><li><code>设置原型</code>，将对象的原型设置为函数的<code>prototype</code>对象。</li><li>让函数的<code>this</code>指向这个对象，执行构造函数的代码（为这个新对象添加属性）</li><li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li></ol><h2 id="介绍节流防抖原理、区别以及应用">介绍节流防抖原理、区别以及应用</h2><p><code>节流</code>：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次。</p><p><code>防抖</code>：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行！</p><p><code>使用场景</code>：<br>节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……<br>防抖：搜索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数 一个函数执行一次后，只有大于设定的执行周期才会执行第二次。有个需要频繁触发的函数，出于优化性能的角度，在规定时间内，只让函数触发的第一次生效，后面的不生效。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn要被节流的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay规定的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="comment">//记录上一次函数触发的时间</span></span><br><span class="line">    <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//记录当前函数触发的时间</span></span><br><span class="line">        <span class="keyword">var</span> nowTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">if</span>(nowTime - lastTime &gt; delay)&#123;</span><br><span class="line">            <span class="comment">//修正this指向问题</span></span><br><span class="line">            fn.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">            <span class="comment">//同步执行结束时间</span></span><br><span class="line">            lastTime = nowTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">onscroll</span> = <span class="title function_">throttle</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scllor事件被触发了&#x27;</span> + <span class="title class_">Date</span>.<span class="title function_">now</span>());</span><br><span class="line">&#125;, <span class="number">200</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数  一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn要被节流的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay规定的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="comment">//记录上一次的延时器</span></span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">       <span class="comment">//清除上一次的演示器</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        <span class="comment">//重新设置新的延时器</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="comment">//修正this指向问题</span></span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>);</span><br><span class="line">        &#125;, delay); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="property">onclick</span> = <span class="title function_">debounce</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;按钮被点击了&#x27;</span> + <span class="title class_">Date</span>.<span class="title function_">now</span>());</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h2 id="setTimeout、Promise、Async-Await-的区别">setTimeout、Promise、Async/Await 的区别</h2><ol><li><p>setTimeout</p><p>settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行。</p></li><li><p>Promise</p><p>Promise本身是<strong>同步的立即执行函数</strong>， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1 end&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;settimeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span></span><br></pre></td></tr></table></figure></li><li><p>async/await</p><p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Async-Await-如何通过同步的方式实现异步">Async/Await 如何通过同步的方式实现异步</h2><p>Async/Await就是一个<strong>自执行</strong>的generate函数。利用generate函数的特性把异步的代码写成“同步”的形式,第一个请求的返回值作为后面一个请求的参数,其中每一个参数都是一个promise对象.</p><h2 id="EventLoop-事件循环">EventLoop 事件循环</h2><p><code>JS</code>是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。微任务队列的代表就是，<code>Promise.then</code>，<code>MutationObserver</code>，宏任务的话就是<code>setImmediate setTimeout setInterval</code></p><p>JS运行的环境。一般为浏览器或者Node。 在浏览器环境中，有JS 引擎线程和渲染线程，且两个线程互斥。 Node环境中，只有JS 线程。 不同环境执行机制有差异，不同任务进入不同Event Queue队列。 当主程结束，先执行准备好微任务，然后再执行准备好的宏任务，一个轮询结束。</p><h3 id="浏览器中的事件环（Event-Loop"><strong>浏览器中的事件环（Event Loop)</strong></h3><p>事件环的运行机制是，先会执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后在取宏任务清微任务这样不停的循环。</p><ul><li><p>eventLoop 是由JS的宿主环境（浏览器）来实现的；</p></li><li><p>事件循环可以简单的描述为以下四个步骤:</p><ol><li>函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空；</li><li>此期间WebAPIs完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）</li><li>执行栈为空时，Event Loop把微任务队列执行清空；</li><li>微任务队列清空后，进入宏任务队列，取队列的第一项任务放入Stack(栈）中执行，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列。重复4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所有的任务。</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/342e581223d2471d9484fc48beb9f8e1~tplv-k3u1fbpfcp-zoom-1.image" alt="事件循环流程"></p></li><li><p>浏览器中的任务源(task):</p><ul><li><code>宏任务(macrotask)</code>：<br>宿主环境提供的，比如浏览器<br>ajax、setTimeout、setInterval、setTmmediate(只兼容ie)、script、requestAnimationFrame、messageChannel、UI渲染、一些浏览器api</li><li><code>微任务(microtask)</code>：<br>语言本身提供的，比如promise.then<br>then、queueMicrotask(基于then)、mutationObserver(浏览器提供)、messageChannel 、mutationObersve</li></ul></li></ul><h3 id="Node-环境中的事件环（Event-Loop"><strong>Node 环境中的事件环（Event Loop)</strong></h3><p><code>Node</code>是基于V8引擎的运行在服务端的<code>JavaScript</code>运行环境，在处理高并发、I/O密集(文件操作、网络操作、数据库操作等)场景有明显的优势。虽然用到也是V8引擎，但由于服务目的和环境不同，导致了它的API与原生JS有些区别，其Event Loop还要处理一些I/O，比如新的网络连接等，所以Node的Event Loop(事件环机制)与浏览器的是不太一样。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e362c1770f62428fbf3faabd99d2a64c~tplv-k3u1fbpfcp-zoom-1.image" alt="2020120317343116.png"> 执行顺序如下：</p><ul><li><code>timers</code>: 计时器，执行setTimeout和setInterval的回调</li><li><code>pending callbacks</code>: 执行延迟到下一个循环迭代的 I/O 回调</li><li><code>idle, prepare</code>: 队列的移动，仅系统内部使用</li><li><code>poll轮询</code>: 检索新的 I/O 事件;执行与 I/O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。</li><li><code>check</code>: 执行<code>setImmediate</code>回调，setImmediate在这里执行</li><li><code>close callbacks</code>: 执行<code>close</code>事件的<code>callback</code>，一些关闭的回调函数，如：socket.on(‘close’, …)</li></ul>]]></content>
    
    
    <summary type="html">🍒本文汇总JavaScript，可作为文档进行查询</summary>
    
    
    
    <category term="面试题" scheme="https://www.cameliia.top/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面试题" scheme="https://www.cameliia.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2023前端面试系列— TypeScript篇</title>
    <link href="https://www.cameliia.top/posts/103.html"/>
    <id>https://www.cameliia.top/posts/103.html</id>
    <published>2023-03-08T02:00:00.000Z</published>
    <updated>2023-08-01T10:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info no-icon flat"><p>本文是我的前端面试系列系列导航，其他章节内容可点击链接查看：</p><ol><li><a href="https://www.cameliia.top/posts/100.html">2023前端面试系列–HTML &amp; CSS 篇</a> ⇦当前位置🪂</li><li><a href="https://www.cameliia.top/posts/101.html">2023前端面试系列-- JS 篇</a></li><li><a href="https://www.cameliia.top/posts/102.html">2023前端面试系列–vue篇</a></li><li><a href="https://www.cameliia.top/posts/103.html">2023前端面试系列–TS篇</a></li><li><a href="https://www.cameliia.top/posts/104.html">2023前端面试系列–React篇</a></li><li><a href="https://www.cameliia.top/posts/105.html">2023前端面试系列–网络篇</a></li><li><a href="https://www.cameliia.top/posts/106.html">2023前端面试系列–浏览器篇</a></li></ol></div><h2 id="1、什么是TypeScript？">1、什么是TypeScript？</h2><p>TypeScript是JavaScript的加强版，它给JavaScript添加了可选的静态类型和基于类的面向对象编程，它拓展了JavaScript的语法。</p><p>而且TypeScript不存在跟浏览器不兼容的问题，因为在编译时，它产生的都是JavaScript代码。</p><h3 id="2、TypeScript-和-JavaScript-的区别是什么？">2、TypeScript 和 JavaScript 的区别是什么？</h3><p>Typescript 是 JavaScript 的超集，可以被编译成 JavaScript 代码。 用 JavaScript 编写的合法代码，在 TypeScript 中依然有效。Typescript 是纯面向对象的编程语言，包含类和接口的概念。 程序员可以用它来编写面向对象的服务端或客户端程序，并将它们编译成 JavaScript 代码。</p><p>TypeScript和 JavaScript的关系<br>TypeScript 引入了很多面向对象程序设计的特征，包括：</p><p>interfaces  接口<br>classes  类<br>enumerated types 枚举类型<br>generics 泛型<br>modules 模块<br>主要不同点如下：<br>TS 是一种面向对象编程语言，而 JS 是一种脚本语言（尽管 JS 是基于对象的）。<br>TS 支持可选参数， JS 则不支持该特性。<br>TS 支持静态类型，JS 不支持。<br>TS 支持接口，JS 不支持接口。</p><h3 id="3为什么要用-TypeScript-？">3为什么要用 TypeScript ？</h3><p>TS 在开发时就能给出编译错误， 而 JS 错误则需要在运行时才能暴露。<br>作为强类型语言，你可以明确知道数据的类型。代码可读性极强，几乎每个人都能理解。<br>TS 非常流行，被很多业界大佬使用。像 Asana、Circle CI 和 Slack 这些公司都在用 TS。</p><h3 id="4、TypeScript-和-JavaScript-哪个更好？">4、TypeScript 和 JavaScript 哪个更好？</h3><p>由于 TS 的先天优势，TS 越来越受欢迎。但是TS 最终不可能取代 JS，因为 JS 是 TS 的核心。</p><p>选择 TypeScript 还是 JavaScript 要由开发者自己去做决定。如果你喜欢类型安全的语言，那么推荐你选择 TS。 如果你已经用 JS 好久了，你可以选择走出舒适区学习 TS，也可以选择坚持自己的强项，继续使用 JS。</p><h3 id="5、什么是泛型？">5、什么是泛型？</h3><p>泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，使用时再去指定类型的一种特性。<br>可以把泛型理解为代表类型的参数<br>// 我们希望传入的值是什么类型，返回的值就是什么类型<br>// 传入的值可以是任意的类型，这时候就可以用到 泛型</p><p>// 如果使用 any 的话，就失去了类型检查的意义</p><p>function createArray1(length: any, value: any): Array<any> {<br>let result: any = [];<br>for (let i = 0; i &lt; length; i++) {<br>result[i] = value;<br>}<br>return result;<br>}</p><p>let result = createArray1(3, ‘x’);<br>console.log(result);</p><p>// 最傻的写法：每种类型都得定义一种函数<br>function createArray2(length: number, value: string): Array<string> {<br>let result: Array<string> = [];<br>for (let i = 0; i &lt; length; i++) {<br>result[i] = value;<br>}<br>return result;<br>}</p><p>function createArray3(length: number, value: number): Array<number> {<br>let result: Array<number> = [];<br>for (let i = 0; i &lt; length; i++) {<br>result[i] = value;<br>}<br>return result;<br>}<br>// 或者使用函数重载，写法有点麻烦<br>function createArray4(length: number, value: number): Array<number><br>function createArray4(length: number, value: string): Array<string><br>function createArray4(length: number, value: any): Array<any> {<br>let result: Array<number> = [];<br>for (let i = 0; i &lt; length; i++) {<br>result[i] = value;<br>}<br>return result;<br>}<br>createArray4(6, ‘666’);<br>//使用泛型<br>// 有关联的地方都改成 <T><br>function createArray<T>(length: number, value: T): Array<T> {<br>let result: T[] = [];<br>for (let i = 0; i &lt; length; i++) {<br>result[i] = value;<br>}<br>return result;<br>}<br>// 使用的时候再指定类型<br>let result = createArray<string>(3, ‘x’);<br>// 也可以不指定类型，TS 会自动类型推导<br>let result2 = createArray(3, ‘x’);<br>console.log(result);</p><h3 id="6、TS中的类">6、TS中的类</h3><p>TypeScript 是面向对象的 JavaScript。而其中的类描述了所创建的对象共同的属性和方法。</p><p>传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但这对于熟悉使用面向对象方式的程序员来说有些棘手，因为他们用的是基于类的继承并且对象是从类构建出来的。</p><p>从ECMAScript 2015，也就是ECMAScript 6，JavaScript程序将可以使用这种基于类的面向对象方法。在TypeScript里允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，</p><h3 id="7、什么是构造函数，构造函数作用是什么？">7、什么是构造函数，构造函数作用是什么？</h3><p>构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。而TypeScript的构造函数用关键字constructor来实现。可以通过this（和java/C#一样代表对象实例的成员访问）关键字来访问当前类体中的属性和方法。</p><h3 id="8、实例化是什么？">8、实例化是什么？</h3><p>一般情况下，创建一个类后并不能直接的对属性和方法进行引用，必须对类进行实例化，即创建一个对象。TypeScript中用new 关键字创建对象。实例化后通过“.”来访问属性和方法</p><h3 id="9、方法重写是什么？">9、方法重写是什么？</h3><p>子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写</p><p>重写的作用在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。</p><h3 id="10、什么是可索引类型接口？">10、什么是可索引类型接口？</h3><p>一般用来约束数组和对象</p><p>/ 数字索引——约束数组<br>// index 是随便取的名字，可以任意取名<br>// 只要 index 的类型是 number，那么值的类型必须是 string<br>interface StringArray {<br>// key 的类型为 number ，一般都代表是数组<br>// 限制 value 的类型为 string<br>[index:number]:string<br>}<br>let arr:StringArray = [‘aaa’,‘bbb’];<br>console.log(arr);</p><p>// 字符串索引——约束对象<br>// 只要 index 的类型是 string，那么值的类型必须是 string<br>interface StringObject {<br>// key 的类型为 string ，一般都代表是对象<br>// 限制 value 的类型为 string<br>[index:string]:string<br>}<br>let obj:StringObject = {name:‘ccc’};</p><h3 id="11、什么是函数类型接口？">11、什么是函数类型接口？</h3><p>对方法传入的参数和返回值进行约束<br>// 注意区别</p><p>// 普通的接口<br>interface discount1{<br>getNum : (price:number) =&gt; number<br>}</p><p>// 函数类型接口<br>interface discount2{<br>// 注意:<br>// “:” 前面的是函数的签名，用来约束函数的参数<br>// “:” 后面的用来约束函数的返回值<br>(price:number):number<br>}<br>let cost:discount2 = function(price:number):number{<br>return price * .8;<br>}</p><p>// 也可以使用类型别名<br>type Add = (x: number, y: number) =&gt; number<br>let add: Add = (a: number, b: number) =&gt; a + b</p><h3 id="12、什么是类类型接口？">12、什么是类类型接口？</h3><p>如果接口用于一个类的话，那么接口会表示“行为的抽象”<br>对类的约束，让类去实现接口，类可以实现多个接口<br>接口只能约束类的公有成员（实例属性/方法），无法约束私有成员、构造函数、静态属性/方法</p><p>// 接口可以在面向对象编程中表示为行为的抽象<br>interface Speakable {<br>name: string;</p><pre><code> // &quot;:&quot; 前面的是函数签名，用来约束函数的参数// &quot;:&quot; 后面的用来约束函数的返回值speak(words: string): void</code></pre><p>}</p><p>interface Speakable2 {<br>age: number;<br>}</p><p>class Dog implements Speakable, Speakable2 {<br>name!: string;<br>age = 18;</p><pre><code>speak(words: string) &#123;    console.log(words);&#125;</code></pre><p>}</p><p>let dog = new Dog();<br>dog.speak(‘汪汪汪’);</p><h3 id="13、什么是混合类型接口？">13、什么是混合类型接口？</h3><p>一个对象可以同时做为函数和对象使用</p><p>interface FnType {<br>(getName:string):string;<br>}</p><p>interface MixedType extends FnType{<br>name:string;<br>age:number;<br>}<br>interface Counter {<br>(start: number): string;<br>interval: number;<br>reset(): void;<br>}</p><p>function getCounter(): Counter {<br>let counter = <Counter>function (start: number) { };<br>counter.interval = 123;<br>counter.reset = function () { };<br>return counter;<br>}</p><p>let c = getCounter();<br>c(10);<br>c.reset();<br>c.interval = 5.0;</p><h3 id="14、never-和-void-的区别？">14、never 和 void 的区别？</h3><p>void 表示没有任何类型（可以被赋值为 null 和 undefined）。<br>never 表示一个不包含值的类型，即表示永远不存在的值。<br>拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。</p><h3 id="15、TS的学前基础？">15、TS的学前基础？</h3><p>因为 TypeScript 是对 JavaScript 的扩展，更准确的说是 ECMAScript。所以，我们学习我们这套 TypeScript 的课程，需要具备 ECMAScript 语言的基础：</p><p>熟悉语法基础（变量、语句、函数等基础概念）<br>掌握内置对象（Array、Date 等）的使用<br>面向对象基本概念（构造函数、原型、继承）</p>]]></content>
    
    
    <summary type="html">🍔本文汇总TypeScript，可作为文档进行查询</summary>
    
    
    
    <category term="面试题" scheme="https://www.cameliia.top/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面试题" scheme="https://www.cameliia.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2023前端面试系列— React篇</title>
    <link href="https://www.cameliia.top/posts/104.html"/>
    <id>https://www.cameliia.top/posts/104.html</id>
    <published>2023-03-08T02:00:00.000Z</published>
    <updated>2023-08-01T10:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info no-icon flat"><p>本文是我的前端面试系列系列导航，其他章节内容可点击链接查看：</p><ol><li><a href="https://www.cameliia.top/posts/100.html">2023前端面试系列–HTML &amp; CSS 篇</a> ⇦当前位置🪂</li><li><a href="https://www.cameliia.top/posts/101.html">2023前端面试系列-- JS 篇</a></li><li><a href="https://www.cameliia.top/posts/102.html">2023前端面试系列–vue篇</a></li><li><a href="https://www.cameliia.top/posts/103.html">2023前端面试系列–TS篇</a></li><li><a href="https://www.cameliia.top/posts/104.html">2023前端面试系列–React篇</a></li><li><a href="https://www.cameliia.top/posts/105.html">2023前端面试系列–网络篇</a></li><li><a href="https://www.cameliia.top/posts/106.html">2023前端面试系列–浏览器篇</a></li></ol></div><h2 id="React-面试专题">React 面试专题</h2><h3 id="React-js是-MVVM-框架吗">React.js是 MVVM 框架吗?</h3><p>React就是Facebook的一个开源JS框架，专注的层面为View层，不包括数据访问层或者那种Hash路由（不过React 有插件支持），与Angularjs，Emberjs等大而全的框架不同，React专注的中心是Component，即组件。React认为一切页面元 素都可以抽象成组件，比如一个表单，或者表单中的某一项。</p><p>React可以作为MVVM中第二个V，也就是View，但是并不是MVVM框架。MVVM一个最显著的特征：双向绑定。React没有这个，它是单向数据绑定的。React是一个单向数据流的库，状态驱动视图。react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流，推崇结合immutable来实现数据不可变。</p><h3 id="hooks用过吗？聊聊react中class组件和函数组件的区别">hooks用过吗？聊聊react中class组件和函数组件的区别</h3><p>类组件是使用ES6 的 class 来定义的组件。 函数组件是接收一个单一的 <code>props</code> 对象并返回一个React元素。</p><p>关于React的两套API（类（class）API 和基于函数的钩子（hooks） API）。官方推荐使用钩子（函数），而不是类。因为钩子更简洁，代码量少，用起来比较&quot;轻&quot;，而类比较&quot;重&quot;。而且，钩子是函数，更符合 React 函数式的本质。</p><p>函数一般来说，只应该做一件事，就是返回一个值。 如果你有多个操作，每个操作应该写成一个单独的函数。而且，数据的状态应该与操作方法分离。根据函数这种理念，React 的函数组件只应该做一件事情：返回组件的 HTML 代码，而没有其他的功能。函数的返回结果只依赖于它的参数。不改变函数体外部数据、函数执行过程里面没有副作用。</p><p>类（class）是数据和逻辑的封装。 也就是说，组件的状态和操作方法是封装在一起的。如果选择了类的写法，就应该把相关的数据和操作，都写在同一个 class 里面。</p><p><strong>类组件的缺点</strong> :</p><p>大型组件很难拆分和重构，也很难测试。<br>业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。<br>组件类引入了复杂的编程模式，比如 render props 和高阶组件。<br>难以理解的 class，理解 JavaScript 中 <code>this</code> 的工作方式。</p><p><strong>区别</strong>：</p><p>函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。</p><p>1.状态的有无<br>hooks出现之前，函数组件<code>没有实例</code>，<code>没有生命周期</code>，<code>没有state</code>，<code>没有this</code>，所以我们称函数组件为无状态组件。 hooks出现之前，react中的函数组件通常只考虑负责UI的渲染，没有自身的状态没有业务逻辑代码，是一个纯函数。它的输出只由参数props决定，不受其他任何因素影响。</p><p>2.调用方式的不同<br>函数组件重新渲染，将重新调用组件方法返回新的react元素。类组件重新渲染将new一个新的组件实例，然后调用render类方法返回react元素，这也说明为什么类组件中this是可变的。</p><p>3.因为调用方式不同，在函数组件使用中会出现问题<br>在操作中改变状态值，类组件可以获取最新的状态值，而函数组件则会按照顺序返回状态值</p><p><strong>React Hooks（钩子的作用）</strong></p><p><em>Hook</em> 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p><p>React Hooks的几个常用钩子:</p><ol><li><code>useState()</code> //状态钩子</li><li><code>useContext()</code> //共享状态钩子</li><li><code>useReducer()</code> //action 钩子</li><li><code>useEffect()</code> //副作用钩子</li></ol><p>还有几个不常见的大概的说下，后续会专门写篇文章描述下</p><ul><li><p>1.useCallback 记忆函数 一般把<strong>函数式组件理解为class组件render函数的语法糖</strong>，所以每次重新渲染的时候，函数式组件内部所有的代码都会重新执行一遍。而有了 useCallback 就不一样了，你可以通过 useCallback 获得一个记忆后的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> memoizedHandleClick = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Click happened&#x27;</span>)</span><br><span class="line">  &#125;, []); <span class="comment">// 空数组代表无论什么情况下该函数都不会发生改变</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SomeComponent</span> <span class="attr">onClick</span>=<span class="string">&#123;memoizedHandleClick&#125;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">SomeComponent</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个参数传入一个数组，数组中的每一项一旦值或者引用发生改变，useCallback 就会重新返回一个新的记忆函数提供给后面进行渲染。</p></li><li><p>2.useMemo 记忆组件 useCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。 唯一的区别是：<strong>useCallback 不会执行第一个参数函数，而是将它返回给你，而 useMemo 会执行第一个函数并且将函数执行结果返回给你</strong>。<br>所以 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。</p></li><li><p>3.useRef 保存引用值</p><p>useRef 跟 createRef 类似，都可以用来生成对 DOM 对象的引用。useRef 返回的值传递给组件或者 DOM 的 ref 属性，就可以通过 ref.current 值<strong>访问组件或真实的 DOM 节点，重点是组件也是可以访问到的</strong>，从而可以对 DOM 进行一些操作，比如监听事件等等。</p></li><li><p>4.useImperativeHandle 穿透 Ref</p><p>通过 useImperativeHandle 用于让父组件获取子组件内的索引</p></li><li><p>5.useLayoutEffect 同步执行副作用</p><p>大部分情况下，使用 useEffect 就可以帮我们处理组件的副作用，但是如果想要同步调用一些副作用，比如对 DOM 的操作，就需要使用 useLayoutEffect，useLayoutEffect 中的副作用会在 DOM 更新之后同步执行。</p><p><strong>useEffect和useLayoutEffect有什么区别</strong>：简单来说就是调用时机不同，useLayoutEffect和原来componentDidMount&amp;componentDidUpdate一致，在react完成DOM更新后马上同步调用的代码，会阻塞页面渲染。而useEffect是会在整个页面渲染完才会调用的代码。<code>官方建议优先使用useEffect</code></p></li></ul><h3 id="React-组件通信方式">React 组件通信方式</h3><p>react组件间通信常见的几种情况:</p><ul><li><ol><li>父组件向子组件通信</li></ol></li><li><ol start="2"><li>子组件向父组件通信</li></ol></li><li><ol start="3"><li>跨级组件通信</li></ol></li><li><ol start="4"><li>非嵌套关系的组件通信</li></ol></li></ul><h4 id="1）父组件向子组件通信">1）父组件向子组件通信</h4><p>父组件通过 props 向子组件传递需要的信息。父传子是在父组件中直接绑定一个正常的属性，这个属性就是指具体的值，在子组件中，用props就可以获取到这个值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件: Child</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Child</span> = props =&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;props.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件 Parent</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Parent</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">name</span>=<span class="string">&quot;京程一灯&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）子组件向父组件通信">2）子组件向父组件通信</h4><p>props+回调的方式，使用公共组件进行状态提升。子传父是先在父组件上绑定属性设置为一个函数，当子组件需要给父组件传值的时候，则通过props调用该函数将参数传入到该函数当中，此时就可以在父组件中的函数中接收到该参数了，这个参数则为子组件传过来的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件: Child</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Child</span> = props =&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">cb</span> = msg =&gt;&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">          props.<span class="title function_">callback</span>(msg)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;cb(</span>&quot;<span class="attr">京程一灯欢迎你</span>!&quot;)&#125;&gt;</span>京程一灯欢迎你<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件 Parent</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">callback</span>(<span class="params">msg</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">callback</span>=<span class="string">&#123;this.callback.bind(this)&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）跨级组件通信">3）跨级组件通信</h4><p>即父组件向子组件的子组件通信，向更深层子组件通信。</p><ul><li>使用props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递props，增加了复杂度，并且这些props并不是中间组件自己需要的。</li><li>使用context，context相当于一个大容器，我们可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用context实现。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context方式实现跨级组件通信 </span></span><br><span class="line"><span class="comment">// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BatteryContext</span> = <span class="title function_">createContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  子组件的子组件 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">BatteryContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;</span></span><br><span class="line"><span class="language-xml">                    color =&gt; <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span>&quot;<span class="attr">color</span>&quot;<span class="attr">:color</span>&#125;&#125;&gt;</span>我是红色的:&#123;color&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">BatteryContext.Consumer</span>&gt;</span></span></span><br><span class="line">        ) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  子组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Child</span> = (<span class="params"></span>) =&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">GrandChild</span>/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">      state = &#123;</span><br><span class="line">          <span class="attr">color</span>:<span class="string">&quot;red&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">          <span class="keyword">const</span> &#123;color&#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">          <span class="language-xml"><span class="tag">&lt;<span class="name">BatteryContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;color&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">Child</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">BatteryContext.Provider</span>&gt;</span></span> </span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4）非嵌套关系的组件通信">4）非嵌套关系的组件通信</h4><p>即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。</p><ul><li><ol><li>可以使用自定义事件通信（发布订阅模式），使用pubsub-js</li></ol></li><li><ol start="2"><li>可以通过redux等进行全局状态管理</li></ol></li><li><ol start="3"><li>如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。</li></ol></li><li><ol start="4"><li>也可以new一个 Vue 的 EventBus,进行事件监听，一边执行监听，一边执行新增 VUE的eventBus 就是发布订阅模式，是可以在React中使用的;</li></ol></li></ul><h3 id="setState-既存在异步情况也存在同步情况">setState 既存在异步情况也存在同步情况</h3><p>1.异步情况 在<code>React事件当中是异步操作</code></p><p>2.同步情况 如果是在<code>setTimeout事件或者自定义的dom事件</code>中，都是同步的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setTimeout事件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>,&#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Count</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">            <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>count:&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.btnAction&#125;</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    btnAction = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//不能直接修改state，需要通过setState进行修改</span></span><br><span class="line">        <span class="comment">//同步</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">                <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Count</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义dom事件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>,&#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Count</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">            <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>count:&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>绑定点击事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//自定义dom事件，也是同步修改</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#btn&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">                <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Count</span>;</span><br></pre></td></tr></table></figure><h3 id="生命周期">生命周期</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bae01e6eb804d849e5bb889f787707d~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">安装</span><br><span class="line">当组件的实例被创建并插入到 <span class="variable constant_">DOM</span> 中时，这些方法按以下顺序调用：</span><br><span class="line"></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)</span><br><span class="line"><span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>()</span><br><span class="line"><span class="title function_">render</span>()</span><br><span class="line"><span class="title function_">componentDidMount</span>()</span><br><span class="line"></span><br><span class="line">更新中</span><br><span class="line">更新可能由道具或状态的更改引起。当重新渲染组件时，这些方法按以下顺序调用：</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>()</span><br><span class="line"><span class="title function_">shouldComponentUpdate</span>()</span><br><span class="line"><span class="title function_">render</span>()</span><br><span class="line"><span class="title function_">getSnapshotBeforeUpdate</span>()</span><br><span class="line"><span class="title function_">componentDidUpdate</span>()</span><br><span class="line"></span><br><span class="line">卸载</span><br><span class="line">当组件从 <span class="variable constant_">DOM</span> 中移除时调用此方法：</span><br><span class="line"></span><br><span class="line"><span class="title function_">componentWillUnmount</span>()</span><br></pre></td></tr></table></figure><h3 id="说一下-react-fiber">说一下 react-fiber</h3><h4 id="1）背景">1）背景</h4><p>react-fiber 产生的根本原因，是<code>大量的同步计算任务阻塞了浏览器的 UI 渲染</code>。默认情况下，JS 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。如果 JS 运算持续占用主线程，页面就没法得到及时的更新。当我们调用<code>setState</code>更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI。如果页面元素很多，整个过程占用的时机就可能超过 16 毫秒，就容易出现掉帧的现象。</p><h4 id="2）实现原理">2）实现原理</h4><ul><li><p>react内部运转分三层：</p><ul><li>Virtual DOM 层，描述页面长什么样。</li><li>Reconciler 层，负责调用组件生命周期方法，进行 Diff 运算等。</li><li>Renderer 层，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。</li></ul></li></ul><p><code>Fiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fiber = &#123;</span><br><span class="line">    stateNode,    <span class="comment">// 节点实例</span></span><br><span class="line">    child,        <span class="comment">// 子节点</span></span><br><span class="line">    sibling,      <span class="comment">// 兄弟节点</span></span><br><span class="line">    <span class="keyword">return</span>,       <span class="comment">// 父节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>为了实现不卡顿，就需要有一个调度器 (Scheduler) 来进行任务分配。优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效。任务的优先级有六种：</p><ul><li>synchronous，与之前的Stack Reconciler操作一样，同步执行</li><li>task，在next tick之前执行</li><li>animation，下一帧之前执行</li><li>high，在不久的将来立即执行</li><li>low，稍微延迟执行也没关系</li><li>offscreen，下一次render时或scroll时才执行</li></ul></li><li><p>Fiber Reconciler（react ）执行过程分为2个阶段：</p><ul><li>阶段一，生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率。</li><li>阶段二，将需要更新的节点一次过批量更新，这个过程不能被打断。</li></ul></li><li><p>Fiber树：React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 Virtual DOM Tree，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 Fiber Tree。Fiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复。</p></li></ul><p>从Stack Reconciler到Fiber Reconciler，源码层面其实就是干了一件递归改循环的事情</p><p>传送门 ☞<a href="https://juejin.cn/post/7002250258826657799"># 深入了解 Fiber</a></p><h3 id="Portals">Portals</h3><p>Portals 提供了一种一流的方式来将子组件渲染到存在于父组件的 DOM 层次结构之外的 DOM 节点中。结构不受外界的控制的情况下就可以使用portals进行创建</p><h3 id="何时要使用异步组件？如和使用异步组件">何时要使用异步组件？如和使用异步组件</h3><ul><li>加载大组件的时候</li><li>路由异步加载的时候</li></ul><p>react 中要配合 Suspense 使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步懒加载</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Box</span> = <span class="title function_">lazy</span>(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;./components/Box&#x27;</span>));</span><br><span class="line"><span class="comment">// 使用组件的时候要用suspense进行包裹</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">    &#123;show &amp;&amp; <span class="tag">&lt;<span class="name">Box</span>/&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="React-事件绑定原理">React 事件绑定原理</h3><p>React并不是将click事件绑在该div的真实DOM上，而是<code>在document处监听所有支持的事件</code>，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。<br>另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 <code>event.preventDefault</code>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2089718f74b342869de15f01588f033f~tplv-k3u1fbpfcp-zoom-1.image" alt="react事件绑定原理"></p><h3 id="React-lazy-实现的原理">React.lazy() 实现的原理</h3><p>React的懒加载示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OtherComponent</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./OtherComponent&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">OtherComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>React.lazy 原理</strong></p><p>以下 React 源码基于 16.8.0 版本</p><p>React.lazy 的源码实现如下：</p><p>export function lazy&lt;T, R&gt;(ctor: () =&gt; Thenable&lt;T, R&gt;): LazyComponent<T> {<br>let lazyType = {<br>$$typeof: REACT_LAZY_TYPE,<br>_ctor: ctor,<br>// React uses these fields to store the result.<br>_status: -1,<br>_result: null,<br>};</p><p>return lazyType;<br>}<br>可以看到其返回了一个 LazyComponent 对象。</p><p>而对于 LazyComponent 对象的解析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title class_">LazyComponent</span>: &#123;</span><br><span class="line">  <span class="keyword">const</span> elementType = workInProgress.<span class="property">elementType</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mountLazyComponent</span>(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    elementType,</span><br><span class="line">    updateExpirationTime,</span><br><span class="line">    renderExpirationTime,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountLazyComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  _current,</span></span><br><span class="line"><span class="params">  workInProgress,</span></span><br><span class="line"><span class="params">  elementType,</span></span><br><span class="line"><span class="params">  updateExpirationTime,</span></span><br><span class="line"><span class="params">  renderExpirationTime,</span></span><br><span class="line"><span class="params"></span>) &#123; </span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">Component</span> = <span class="title function_">readLazyComponentType</span>(elementType);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pending = 0, Resolved = 1, Rejected = 2</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> readLazyComponentType&lt;T&gt;(<span class="attr">lazyComponent</span>: <span class="title class_">LazyComponent</span>&lt;T&gt;): T &#123;</span><br><span class="line">  <span class="keyword">const</span> status = lazyComponent.<span class="property">_status</span>;</span><br><span class="line">  <span class="keyword">const</span> result = lazyComponent.<span class="property">_result</span>;</span><br><span class="line">  <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Resolved</span>: &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="title class_">Component</span>: T = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Component</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Rejected</span>: &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">error</span>: mixed = result;</span><br><span class="line">      <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Pending</span>: &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">thenable</span>: <span class="title class_">Thenable</span>&lt;T, mixed&gt; = result;</span><br><span class="line">      <span class="keyword">throw</span> thenable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">default</span>: &#123; <span class="comment">// lazyComponent 首次被渲染</span></span><br><span class="line">      lazyComponent.<span class="property">_status</span> = <span class="title class_">Pending</span>;</span><br><span class="line">      <span class="keyword">const</span> ctor = lazyComponent.<span class="property">_ctor</span>;</span><br><span class="line">      <span class="keyword">const</span> thenable = <span class="title function_">ctor</span>();</span><br><span class="line">      thenable.<span class="title function_">then</span>(</span><br><span class="line">        <span class="function"><span class="params">moduleObject</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (lazyComponent.<span class="property">_status</span> === <span class="title class_">Pending</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> defaultExport = moduleObject.<span class="property">default</span>;</span><br><span class="line">            lazyComponent.<span class="property">_status</span> = <span class="title class_">Resolved</span>;</span><br><span class="line">            lazyComponent.<span class="property">_result</span> = defaultExport;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (lazyComponent.<span class="property">_status</span> === <span class="title class_">Pending</span>) &#123;</span><br><span class="line">            lazyComponent.<span class="property">_status</span> = <span class="title class_">Rejected</span>;</span><br><span class="line">            lazyComponent.<span class="property">_result</span> = error;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// Handle synchronous thenables.</span></span><br><span class="line">      <span class="keyword">switch</span> (lazyComponent.<span class="property">_status</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">Resolved</span>:</span><br><span class="line">          <span class="keyword">return</span> lazyComponent.<span class="property">_result</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">Rejected</span>:</span><br><span class="line">          <span class="keyword">throw</span> lazyComponent.<span class="property">_result</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      lazyComponent.<span class="property">_result</span> = thenable;</span><br><span class="line">      <span class="keyword">throw</span> thenable;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：如果 readLazyComponentType 函数多次处理同一个 lazyComponent，则可能进入Pending、Rejected等 case 中。</p><p>从上述代码中可以看出，对于最初 React.lazy() 所返回的 LazyComponent 对象，其 _status 默认是 -1，所以首次渲染时，会进入 readLazyComponentType 函数中的 default 的逻辑，这里才会真正异步执行 import(url)操作，由于并未等待，随后会检查模块是否 Resolved，如果已经Resolved了（已经加载完毕）则直接返回moduleObject.default（动态加载的模块的默认导出），否则将通过 throw 将 thenable 抛出到上层。</p><p>为什么要 throw 它？这就要涉及到 Suspense 的工作原理，我们接着往下分析。</p><p><strong>Suspense 原理</strong></p><p>由于 React 捕获异常并处理的代码逻辑比较多，这里就不贴源码，感兴趣可以去看 throwException 中的逻辑，其中就包含了如何处理捕获的异常。简单描述一下处理过程，React 捕获到异常之后，会判断异常是不是一个 thenable，如果是则会找到 SuspenseComponent ，如果 thenable 处于 pending 状态，则会将其 children 都渲染成 fallback 的值，一旦 thenable 被 resolve 则 SuspenseComponent 的子组件会重新渲染一次。</p><p>为了便于理解，我们也可以用 componentDidCatch 实现一个自己的 Suspense 组件，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Suspense</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">promise</span>: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断 err 是否是 thenable</span></span><br><span class="line">    <span class="keyword">if</span> (err !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> err === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> err.<span class="property">then</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">promise</span>: err &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        err.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">promise</span>: <span class="literal">null</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; fallback, children &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">    <span class="keyword">const</span> &#123; promise &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span>&#123; promise ? fallback : children &#125;<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们分析完了 React 的懒加载原理。简单来说，React利用 React.lazy与import()实现了渲染时的动态加载 ，并利用Suspense来处理异步加载资源时页面应该如何显示的问题。</p><p>参考传送门☞ <a href="https://thoamsy.github.io/blogs/react-lazy/">React Lazy 的实现原理</a></p>]]></content>
    
    
    <summary type="html">🍟本文汇总React，可作为文档进行查询</summary>
    
    
    
    <category term="面试题" scheme="https://www.cameliia.top/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面试题" scheme="https://www.cameliia.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2023前端面试系列— 浏览器篇</title>
    <link href="https://www.cameliia.top/posts/106.html"/>
    <id>https://www.cameliia.top/posts/106.html</id>
    <published>2023-03-08T02:00:00.000Z</published>
    <updated>2023-08-01T10:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info no-icon flat"><p>本文是我的前端面试系列系列导航，其他章节内容可点击链接查看：</p><ol><li><a href="https://www.cameliia.top/posts/100.html">2023前端面试系列–HTML &amp; CSS 篇</a> ⇦当前位置🪂</li><li><a href="https://www.cameliia.top/posts/101.html">2023前端面试系列-- JS 篇</a></li><li><a href="https://www.cameliia.top/posts/102.html">2023前端面试系列–vue篇</a></li><li><a href="https://www.cameliia.top/posts/103.html">2023前端面试系列–TS篇</a></li><li><a href="https://www.cameliia.top/posts/104.html">2023前端面试系列–React篇</a></li><li><a href="https://www.cameliia.top/posts/105.html">2023前端面试系列–网络篇</a></li><li><a href="https://www.cameliia.top/posts/106.html">2023前端面试系列–浏览器篇</a></li></ol></div><h1>浏览器</h1><h3 id="从输入URL到页面加载的全过程">从输入URL到页面加载的全过程</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e44aa8a92602405db3c12161b71e2094~tplv-k3u1fbpfcp-zoom-1.image" alt="从输入URL到页面加载的主干流程"></p><ol><li><p>首先在浏览器中输入URL</p></li><li><p>查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。</p><ul><li>浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；</li><li>操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；</li><li>路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；</li><li>ISP缓存：若上述均失败，继续向ISP搜索。</li></ul></li><li><p>DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。<code>DNS服务器是基于UDP的，因此会用到UDP协议</code>。</p></li><li><p>建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接</p></li><li><p>发起HTTP请求：浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器</p></li><li><p>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器</p></li><li><p>关闭TCP连接：通过四次挥手释放TCP连接</p></li><li><p>浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：</p><ul><li>构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象</li><li>构建CSS规则树：生成CSS规则树（CSS Rule Tree）</li><li>构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）</li><li>布局（Layout）：计算出每个节点在屏幕中的位置</li><li>绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a90660027f0d4c559732519bad4c6323~tplv-k3u1fbpfcp-zoom-1.image" alt="浏览器渲染流程图"></p></li><li><p>JS引擎解析过程：调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</p><ul><li>创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。</li><li>加载文件：完成js引擎分析它的语法与词法是否合法，如果合法进入预编译</li><li>预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为’undefined’；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。</li><li>解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。</li></ul></li></ol><p>传送门 ☞ <a href="https://juejin.cn/post/7005468491067162655"># DNS域名解析过程</a> ☞<a href="https://juejin.cn/post/6992597760935460901"># 浏览器的工作原理</a></p><h3 id="在浏览器中输入URL到显示页面经历哪些过程，涉及到哪些协议？">在浏览器中输入URL到显示页面经历哪些过程，涉及到哪些协议？</h3><p>浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。<code>DNS服务器是基于UDP的，因此会用到UDP协议。</code></p><p>得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。</p><p>其中：</p><p>1、<code>DNS协议，http协议，https协议属于应用层</code></p><p>应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。</p><p>2、<code>TCP/UDP属于传输层</code></p><p>传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议TCP，和无连接的用户数据报协议UDP。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。</p><p>3、<code>IP协议，ARP协议属于网络层</code></p><p>网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。</p><p>4、数据链路层</p><p>当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及流量控制信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。</p><p>5、物理层</p><p>物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层。</p><h3 id="浏览器的主要功能">浏览器的主要功能</h3><p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。</p><h3 id="浏览器的工作原理">浏览器的工作原理</h3><p>渲染引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</p><p>然后进行如下所示的基本流程：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ef6cb226b374e89914a2315e4ca9ba9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>图：渲染引擎的基本流程。</p><p>渲染引擎将开始<code>解析 HTML 文档</code>，并将各标记逐个转化成“内容树”上的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.html5rocks.com%2Fzh%2Ftutorials%2Finternals%2Fhowbrowserswork%2F%23DOM" title="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#DOM">DOM</a> 节点。同时也会<code>解析外部 CSS 文件以及样式元素中的样式数据</code>。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.html5rocks.com%2Fzh%2Ftutorials%2Finternals%2Fhowbrowserswork%2F%23Render_tree_construction" title="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Render_tree_construction"><code>渲染树</code></a>。</p><p>渲染树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p><p>渲染树构建完毕之后，进入“<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.html5rocks.com%2Fzh%2Ftutorials%2Finternals%2Fhowbrowserswork%2F%23layout" title="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#layout">布局</a>”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.html5rocks.com%2Fzh%2Ftutorials%2Finternals%2Fhowbrowserswork%2F%23Painting" title="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Painting">绘制</a> - 渲染引擎会遍历渲染树，由用户界面后端层将每个节点绘制出来。</p><p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，渲染引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。</p><h3 id="浏览器的主要组成部分是什么？">浏览器的主要组成部分是什么？</h3><ol><li><strong>用户界面</strong> - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li><li><strong>浏览器引擎</strong> - 在用户界面和呈现引擎之间传送指令。</li><li><strong>呈现引擎</strong> - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li><li><strong>网络</strong> - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li><li><strong>用户界面后端</strong> - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li><li><strong>JavaScript 解释器</strong>。用于解析和执行 JavaScript 代码。</li><li><strong>数据存储</strong>。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f83cb61cb9de4a65abeb95e50608af48~tplv-k3u1fbpfcp-watermark.awebp" alt=""></li></ol><p>图：浏览器的主要组件。</p><p>值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</p><h3 id="浏览器是如何渲染UI的？">浏览器是如何渲染UI的？</h3><ol><li>浏览器获取HTML文件，然后对文件进行解析，形成DOM Tree</li><li>与此同时，进行CSS解析，生成Style Rules</li><li>接着将DOM Tree与Style Rules合成为 Render Tree</li><li>接着进入布局（Layout）阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标</li><li>随后调用GPU进行绘制（Paint），遍历Render Tree的节点，并将元素呈现出来</li></ol><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67b1336692f540c9a81756f93e82c2f5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="DOM-Tree是如何构建的？">DOM Tree是如何构建的？</h3><ol><li>转码: 浏览器将接收到的二进制数据按照指定编码格式转化为HTML字符串</li><li>生成Tokens: 之后开始parser，浏览器会将HTML字符串解析成Tokens</li><li>构建Nodes: 对Node添加特定的属性，通过指针确定 Node 的父、子、兄弟关系和所属 treeScope</li><li>生成DOM Tree: 通过node包含的指针确定的关系构建出DOM<br>Tree</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dc0f577836c4705bb582b2ac15bc5d1~tplv-k3u1fbpfcp-zoom-1.image" alt="2019-06-22-11-48-00"></p><h3 id="浏览器重绘与重排的区别？">浏览器重绘与重排的区别？</h3><ul><li><code>重排/回流（Reflow）</code>：当<code>DOM</code>的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。</li><li><code>重绘(Repaint)</code>: 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变</li></ul><p>单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分</p><p>重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。</p><p>『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。</p><h3 id="如何触发重排和重绘？">如何触发重排和重绘？</h3><p>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p><ul><li>添加、删除、更新DOM节点</li><li>通过display: none隐藏一个DOM节点-触发重排和重绘</li><li>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化</li><li>移动或者给页面中的DOM节点添加动画</li><li>添加一个样式表，调整样式属性</li><li>用户行为，例如调整窗口大小，改变字号，或者滚动。</li></ul><h3 id="如何避免重绘或者重排？">如何避免重绘或者重排？</h3><ol><li><p><code>集中改变样式</code>，不要一条一条地修改 DOM 的样式。</p></li><li><p>不要把 DOM 结点的属性值放在循环里当成循环里的变量。</p></li><li><p>为动画的 HTML 元件使用 <code>fixed</code> 或 <code>absoult</code> 的 <code>position</code>，那么修改他们的 CSS 是不会 reflow 的。</p></li><li><p>不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</p></li><li><p>尽量只修改<code>position：absolute</code>或<code>fixed</code>元素，对其他元素影响不大</p></li><li><p>动画开始<code>GPU</code>加速，<code>translate</code>使用<code>3D</code>变化</p></li><li><p>提升为合成层</p><p>将元素提升为合成层有以下优点：</p><ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li><li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li><li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li></ul><p>提升合成层的最好方式是使用 CSS 的 will-change 属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#target</span> &#123;</span><br><span class="line">  <span class="attribute">will-change</span>: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于合成层的详解请移步<a href="https://link.juejin.cn?target=http%3A%2F%2Ftaobaofed.org%2Fblog%2F2016%2F04%2F25%2Fperformance-composite%2F" title="http://taobaofed.org/blog/2016/04/25/performance-composite/">无线性能优化：Composite</a></p></blockquote></li></ol><h3 id="介绍下304过程">介绍下304过程</h3><ul><li>a. 浏览器请求资源时首先命中资源的Expires 和 Cache-Control，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过Cache-control: max-age指定最大生命周期，状态仍然返回200，但不会请求数据，在浏览器中能明显看到from cache字样。</li><li>b. 强缓存失效，进入协商缓存阶段，首先验证ETagETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据客户端上送的If-None-Match值来判断是否命中缓存。</li><li>c. 协商缓存Last-Modify/If-Modify-Since阶段，客户端第一次请求资源时，服务服返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间。再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。</li></ul><h3 id="浏览器的缓存机制-强制缓存-协商缓存">浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存</h3><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/487144abaada4b9a8b34bc9375191ec7~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>由上图我们可以知道：</p><ul><li>浏览器每次发起请求，都会<code>先在浏览器缓存中查找该请求的结果以及缓存标识</code></li><li>浏览器每次拿到返回的请求结果都会<code>将该结果和缓存标识存入浏览器缓存中</code></li></ul><p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是<code>强制缓存</code>和<code>协商缓存</code>。</p><ul><li><p><strong>强制缓存</strong></p><p><code>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。</code>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <code>Expires</code> 和 <code>Cache-Control</code>，其中Cache-Control优先级比Expires高。</p><p>强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p><ol><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。</li><li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。</li><li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li></ol></li><li><p><strong>协商缓存</strong></p><p><code>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</code>，同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<code>Last-Modified / If-Modified-Since</code> 和 <code>Etag / If-None-Match</code>，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。协商缓存主要有以下两种情况：</p><ol><li>协商缓存生效，返回304</li><li>协商缓存失效，返回200和请求结果结果</li></ol></li></ul><p>传送门 ☞ <a href="https://juejin.cn/post/6992843117963509791"># 彻底理解浏览器的缓存机制</a></p><h3 id="Cookie、sessionStorage、localStorage-的区别">Cookie、sessionStorage、localStorage 的区别</h3><p><strong>相同点</strong>：</p><ul><li>存储在客户端</li></ul><p><strong>不同点</strong>：</p><ul><li>cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+</li><li>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</li><li>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</li></ul><h3 id="说下进程、线程和协程">说下进程、线程和协程</h3><p><strong>进程</strong>是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，<code>是操作系统进行资源分配和调度的一个独立单位</code>，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。</p><p><strong>线程</strong>是程序执行中一个单一的顺序控制流程，是<code>程序执行流的最小单元</code>，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p><p><strong>协程</strong>，英文Coroutines，是一种<code>基于线程之上，但又比线程更加轻量级的存在</code>，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p><p><strong>进程和线程的区别与联系</strong></p><p>【区别】：</p><p>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</p><p>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</p><p>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。</p><p>系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p><p>【联系】：</p><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</p><p>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</p><p>处理机分给线程，即真正在处理机上运行的是线程；</p><p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p><p>传送门 ☞ <a href="https://juejin.cn/post/7005465381791875109"># 一文搞懂进程、线程、协程及JS协程的发展</a><br><a href="http://www.360doc.com/content/20/0417/14/32196507_906628857.shtml">☞了解更多</a></p><p>关于浏览器传送门 ☞<a href="https://juejin.cn/post/6993095345576083486"># 深入了解现代 Web 浏览器</a></p><h3 id="进程间的通信方式">进程间的通信方式</h3><p><code>进程通信</code>：<br>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。</p><p>进程间的通信方式：管道、有名管道、信号、消息队列、共享内存、信号量、socket</p><p><code>匿名管道( pipe )</code>： 管道是一种半双工的通信方式，数据只能<strong>单向流动</strong>，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指<strong>父子进程关系</strong>。</p><p><code>高级管道(popen)</code>：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。</p><p><code>有名管道 (named pipe) </code>： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p><p><code>消息队列( message queue )</code> ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><p><code>信号量( semophore )</code> ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><p><code>信号 ( sinal )</code> ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p><code>共享内存( shared memory )</code> ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p><p><code>套接字( socket ) 通信</code>： 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信</p><h3 id="浏览器样式兼容">浏览器样式兼容</h3><h4 id="一、CSS初始化">一、CSS初始化</h4><p>每个浏览器的css默认样式不尽相同，所以最简单有效的方式就是对其进行初始化（覆盖默认样式）</p><blockquote><p>常见 :  *{ margin: 0; padding: 0;}</p><p>库：normalize.css</p></blockquote><h4 id="二、浏览器私有属性">二、<strong>浏览器私有属性</strong></h4><blockquote><p>常用的前缀有：</p><p>firefox浏览器 ：-moz-</p><p>chrome、safari ：-webkit-</p><p>opera ：-o- / -xv-</p><p>IE浏览器 ：-ms-（目前只有 IE 8+支持）</p></blockquote><h4 id="三、CSS-hack（条件hack、属性级hack、选择符级hack）"><strong>三、CSS hack（条件hack、属性级hack、选择符级hack）</strong></h4><h3 id="JS垃圾回收机制">JS垃圾回收机制</h3><ol><li><p>项目中，如果存在大量不被释放的内存（堆/栈/上下文），页面性能会变得很慢。当某些代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存。</p></li><li><p>浏览器垃圾回收机制/内存回收机制:</p><blockquote><p>浏览器的<code>Javascript</code>具有自动垃圾回收机制(<code>GC:Garbage Collecation</code>)，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</p></blockquote><p><strong>标记清除</strong>:在<code>js</code>中，最常用的垃圾回收机制是标记清除：当变量进入执行环境时，被标记为“进入环境”，当变量离开执行环境时，会被标记为“离开环境”。垃圾回收器会销毁那些带标记的值并回收它们所占用的内存空间。<br><strong>谷歌浏览器</strong>：“查找引用”，浏览器不定时去查找当前内存的引用，如果没有被占用了，浏览器会回收它；如果被占用，就不能回收。<br><strong>IE浏览器</strong>：“引用计数法”，当前内存被占用一次，计数累加1次，移除占用就减1，减到0时，浏览器就回收它。</p></li><li><p>优化手段：内存优化 ; 手动释放：取消内存的占用即可。</p><p>（1）堆内存：fn = null 【null：空指针对象】</p><p>（2）栈内存：把上下文中，被外部占用的堆的占用取消即可。</p></li><li><p>内存泄漏</p><p>在 JS 中，常见的内存泄露主要有 4 种,全局变量、闭包、DOM 元素的引用、定时器</p></li></ol>]]></content>
    
    
    <summary type="html">🌭本文汇总浏览器知识，可作为文档进行查询</summary>
    
    
    
    <category term="面试题" scheme="https://www.cameliia.top/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面试题" scheme="https://www.cameliia.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2023前端面试系列—面试汇总篇</title>
    <link href="https://www.cameliia.top/posts/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB.html"/>
    <id>https://www.cameliia.top/posts/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB.html</id>
    <published>2023-03-08T02:00:00.000Z</published>
    <updated>2023-08-01T10:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>HTML</h1><h2 id="1-HTML5-新特性">1. HTML5 新特性</h2><ol><li>新的语义化元素：main、footer、header、nav、section</li><li>新的表单控件：date、time、email、url、search</li><li>新的 API：</li></ol><ul><li>音视频：audio 和 video 元素</li><li>绘图图形：canvas 元素</li><li>本地存储：localStorage，sessionStorage</li><li>多线程操作：Web Worker</li></ul><p>引申的内容：</p><ol><li>语义化：是什么？有什么用？</li></ol><ul><li>有利于 SEO，代码更加规范和可读</li><li>SEO 是搜索引擎优化：提升网站在搜索引擎排名<ul><li>可以通过 meta 标签设置 description / keyword 等值，一般值由产品需求提供</li><li>可以通过服务端渲染技术 SSR （react - next / vue - nuxt）</li></ul></li></ul><ol start="2"><li>canvas</li></ol><ul><li>概念：画布，用来绘制图形图表</li><li>项目中主要用来完成数据可视化功能：比如数据大屏展示/适配/实时更新等</li></ul><ol start="3"><li>localStorage / sessionStorage</li></ol><ul><li>区别<ul><li>localStorage 永久存储，通常用来存储用户的登录唯一标识 token</li><li>sessionStorage 临时会话存储（关闭浏览器会自动清空内容）</li></ul></li><li>扩展其他存储方案<ul><li>cookie<ul><li>储存体积小（4KB）</li><li>发送请求，cookie 会自动携带</li></ul></li><li>webStorage<ul><li>储存体积更大（2mb）</li><li>必须手动携带（封装 axios 中请求拦截器在请求头中携带 token 参数）</li></ul></li></ul></li></ul><ol start="4"><li>WebWorker</li></ol><ul><li>多线程操作，可以用于项目性能优化：比如将计算量大的任务交给 web worker 处理(大文件上传)</li></ul><h2 id="2-常见的行内元素和块级元素有哪些？它们的区别？">2. 常见的行内元素和块级元素有哪些？它们的区别？</h2><ol><li>行内元素 span i a</li><li>块级元素 div p ul/li header/footer form</li><li>行内块元素 img input</li></ol><p>区别：</p><ol><li>行内和行内块元素一行多个，块级元素独占一行</li><li>行内元素不能设置 width/height，行内块和块级元素可以设置</li></ol><h2 id="3-谈谈-iframe">3. 谈谈 iframe</h2><ol><li><p>概念：能在当前页面嵌套其他页面（能在当前应用嵌套其他子应用）</p></li><li><p>问题</p></li></ol><ul><li>同源情况下, 可以通过 iframe 标签直接获取子页面的数据（比如，iframe.documentWindow 获取到 window 对象）</li><li>不同源情况下，postMessage 方法 和 message 事件的方式进行通信<ul><li>postMessage 方法，用来发送数据</li><li>message 事件，用来接受数据</li></ul></li></ul><ol start="3"><li>引申</li></ol><p>公司有多个项目，需要汇总到一个项目中一起使用，简单实现可以用 iframe 标签，也可以使用前端微应用框架：qiankun / micro 来实现</p><h1>CSS</h1><h2 id="1-CSS3-新特性">1. CSS3 新特性</h2><ol><li>新增了选择器</li></ol><ul><li>:last-child 匹配父元素的最后一个子元素</li><li>:nth-child(n) 匹配父元素的第 n 个子元素</li></ul><ol start="2"><li>边框特性</li></ol><ul><li>border-radius 圆角</li></ul><ol start="3"><li>颜色与不透明度</li></ol><ul><li>opacity: 0.5;</li><li>color: rgba(0, 0, 0, 0.5)</li></ul><ol start="4"><li>阴影</li></ol><ul><li>text-shadow 文字阴影</li><li>box-shadow 盒子阴影</li></ul><ol start="5"><li>transform 变形</li></ol><ul><li>transform: rotate(9deg) 旋转</li><li>transform: scale(0.5) 缩放</li><li>transform: translate(100px, 100px) 位移</li></ul><ol start="6"><li>过渡与动画</li></ol><ul><li><p>transition 过渡</p></li><li><p>animation 动画</p><p>Vue 中 transition 组件，用来给显示隐藏切换的元素一个动画/过渡效果<br><a href="https://gitee.com/xxpromise/class220829/blob/master/03.vue3-vite/src-16-vue-router/App.vue">https://gitee.com/xxpromise/class220829/blob/master/03.vue3-vite/src-16-vue-router/App.vue</a></p></li></ul><ol start="7"><li>媒体查询</li></ol><ul><li>@media 用来做响应式布局</li></ul><blockquote><p>至少说 4 个点</p></blockquote><h2 id="2-盒模型">2. 盒模型</h2><ol><li><p>概念：页面渲染时，DOM 元素所采用的布局模型。 可通过 box-sizing 进行设置。</p></li><li><p>分类：</p></li></ol><ul><li>content-box (W3C 标准盒模型)<br>当给元素设置 width 和 height 时，只会改变 width + height。</li><li>border-box (IE 盒模型)<br>当给元素设置 width 和 height 时，会改变 width + height + padding。</li><li>其他未实现了</li></ul><h2 id="3-BFC">3. BFC</h2><ol><li>概念</li></ol><ul><li>BFC，又称为块级格式化上下文，指的是：一个独立的渲染区域.</li></ul><ol start="2"><li>触发条件（开启 BFC）</li></ol><ul><li>设置 overflow，即 hidden，auto，scroll</li><li>设置浮动，不包括 none</li><li>设置定位，absolute 或者 fixed 等方式</li></ul><ol start="3"><li>具体规则</li></ol><ul><li>BFC 是一个块级元素，块级元素在垂直方向上依次排列。</li><li>BFC 是一个独立的容器，内部元素不会影响容器外部的元素。</li><li>属于同一个 BFC 的两个盒子，外边距 margin 会发生重叠，并且取最大外边距。</li><li>计算 BFC 高度时，浮动子元素也要参与计算。</li></ul><ol start="4"><li>应用</li></ol><ul><li>阻止 margin 重叠</li><li>清除浮动，防止高度塌陷</li><li>阻止标准流元素被浮动元素覆盖</li></ul><h2 id="4-选择器权重-优先级">4. 选择器权重&amp;优先级</h2><ul><li><code>!important &gt; 行内样式 &gt; #id &gt; .class &gt; tag &gt; * &gt; 继承 &gt; 默认</code></li><li>CSS 选择器浏览器是 <strong>从右往左</strong> 依次解析</li></ul><h2 id="5-CSS-预处理器-Sass-Less-Stylus">5. CSS 预处理器(Sass/Less/Stylus)</h2><ol><li><p>概念：CSS 预处理器定义了一种新的语言，可以更方便的维护和管理 CSS 代码</p></li><li><p>比如我最常用的 sass</p></li></ol><ul><li>可以使用 <code>$</code> 来定义变量</li><li>可以样式嵌套</li><li>可以通过 <code>mixin</code> 来定义混合，复用代码</li></ul><ol start="3"><li>Vue 项目中使用</li></ol><ul><li>通过安装 <code>sass sass-loader</code> 依赖就可以直接使用 sass 了</li><li>开发中我会定义全局变量文件，那么这个文件每个 sass 使用都要引入，太麻烦了。所以我通常在项目中会进行脚手架配置，scss - additionalData 让其给每个 sass 文件自动追加引入全局变量文件的代码，从而让其全局生效</li></ul><ol start="4"><li>扩展</li></ol><ul><li>现阶段样式变量 css 也支持了<ul><li>通过 <code>:root&#123; --xxx-xx: xxx &#125;</code> 定义</li><li>通过 <code>var(--xxx-xx)</code> 使用</li></ul></li></ul><h2 id="6-flex-布局">6. flex 布局</h2><ol><li>概念</li></ol><p>Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。</p><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称&quot;容器&quot;。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称&quot;项目&quot;。</p><p>容器默认存在两根轴：主轴和交叉轴（也叫做侧轴）。默认水平方向的为主轴，垂直方向为侧轴。</p><ol start="2"><li>容器的属性（2-3 个）</li></ol><ul><li>flex-direction 定义主轴的方向</li><li>flex-wrap 定义是否换行</li><li>flex-flow 是 flex-direction 属性和 flex-wrap 属性的简写形式</li><li>justify-content 定义项目在主轴上的对齐方式</li><li>align-items 定义项目在侧轴上的对齐方式</li><li>align-content 定义项目在交叉轴上如何对齐</li></ul><ol start="3"><li>项目的属性（2-3 个）</li></ol><ul><li>order 定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</li><li>flex-grow 定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。</li><li>flex-shrink 定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。</li><li>flex-basis 定义了在分配多余空间之前，项目占据的主轴空间。它的默认值为 auto，即项目的本来大小。</li><li>flex 是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。</li><li>align-self 允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。</li></ul><ol start="4"><li>扩展：flex: 1 啥意思</li></ol><ul><li>flex-grow: 1 如果存在剩余空间, 该项目会放大。</li><li>flex-shrink: 1 如果剩余空间不足，该项目会缩小。</li><li>flex-basis: 0% 设置为 0% 之后，即不占据主轴空间，但是因为有 flex-grow 和 flex-shrink 的设置，该项目会自动放大或缩小。</li></ul><h2 id="7-实现两栏布局">7. 实现两栏布局</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: deeppink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-隐藏页面元素方式">8. 隐藏页面元素方式</h2><ol><li>display: none 不占位。不会响应 DOM 事件。</li><li>opacity: 0 占位，但不可见。会响应 DOM 事件。</li><li>visibility: hidden 占位，但不可见。不会响应 DOM 事件。</li><li>position: absolute; left: -10000px 移动到屏幕外</li><li>z-index: -1 将别的定位元素遮盖掉当前元素</li></ol><h2 id="9-让元素水平垂直居中方式">9. 让元素水平垂直居中方式</h2><ol><li>利用绝对定位, 子元素未知宽高</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用绝对定位, 子元素未知宽高</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>利用绝对定位, 子元素必须明确宽高</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>利用 flex</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>JavaScript</h1><h2 id="1-说说-JS-的数据类型">1. 说说 JS 的数据类型</h2><ol><li>基本数据类型</li></ol><ul><li>number</li><li>string</li><li>boolean</li><li>null</li><li>undefined</li><li>symbol<ul><li>用来给变量唯一的值</li><li>用来给对象唯一的属性名（对象属性名的类型只能是：string，symbol）</li></ul></li><li>bigint<ul><li>当 number 类型计算超过最大数（Number.MAX_SALE_NUMBER）或小于最小值，计算就会出现问题，这个时候可以用 bigint 解决（实际开发很少见）</li></ul></li></ul><ol start="2"><li>引用数据类型</li></ol><ul><li>object</li><li>function</li><li>array</li></ul><h2 id="2-如何判断-JS-数据类型">2. 如何判断 JS 数据类型</h2><ol><li>typeof</li></ol><p>大部分类型都能检查出来，但是对于 null\object\array 无法区分</p><ol start="2"><li>A instanceof B</li></ol><p>简单理解：检查 A 是否是 B 的实例<br>真正理解：检查 A 的某一个<code>__proto__</code>是否和 B.prototype 指向同一个对象</p><p>主要用来检测引用数据类型</p><ol start="3"><li>Object.prototype.toString.call(xxx).slice(8, -1)</li></ol><p>完美解决方案，可以检测所有数据类型，开发中使用 toString 方法去封装工具函数去检测类型</p><ol start="4"><li>Array.isArray</li></ol><p>检测是否是数组类型</p><ol start="5"><li>A === B</li></ol><p>检测 A 和 B 的值和类型都要相等</p><h2 id="3-说说常见的数组方法">3. 说说常见的数组方法</h2><ol><li>更新数组的方法</li></ol><ul><li>push 给数组最后添加一个元素</li><li>pop 删除数组最后一个元素</li><li>unshift 给数组最前面添加一个元素</li><li>shift 删除数组最前面一个元素</li><li>splice 删除/新增指定下标元素</li><li>sort 排序</li><li>reverse 反转</li></ul><ol start="2"><li>遍历元素的方法</li></ol><ul><li>forEach 遍历</li><li>map 返回一个新数组，新数组长度和原数组一致，但内部的值往往会发生变化。（长度不变，值变）<ul><li>在 React 中更新数据中某个值，往往使用 map 方法。</li></ul></li><li>filter 返回一个新数组，新数组长度往往比原数组更少，但内部的值和原数组一致。（长度变，值不变）<ul><li>在 React 中删除数据中某个值，往往使用 filter 方法。</li></ul></li><li>reduce 常用于统计、累加和求和等功能。<ul><li>购物车模块，计算总价。</li></ul></li><li>find 查找某个元素，找到返回这个元素，找不到返回 undefined。</li><li>findIndex 查找某个元素的下标，找到返回这个元素下标，找不到返回 -1。</li><li>every 所有返回 true 整体才返回 true，只要有一个返回 false，整体就返回 false。</li><li>some 只要有一个返回 true，整体就返回 true，只有全部返回 false，整体才返回 false。</li></ul><ol start="3"><li>其它方法</li></ol><ul><li>slice 截取数组中某些元素</li><li>concat 拼接数组</li><li>join 将数组内部元素以某种方式拼接成字符串</li><li>includes 判断是否包含某个元素，包含返回 true，不包含返回 false</li><li>indexOf 判断是否包含某个元素，包含返回其下标，不包含返回-1</li></ul><p><strong>至少能说个 6-7，并且相对复杂的方法</strong></p><h2 id="4-常见的-DOM-操作有哪些">4. 常见的 DOM 操作有哪些</h2><ol><li>新增 DOM 元素</li></ol><ul><li>document.createElement() 创建 DOM 元素</li><li>xxxDom.appendChild() 将某个 dom 元素插入到 xxxDom 内</li></ul><ol start="2"><li>删除 DOM 元素</li></ol><ul><li>xxxDom.removeChild() 将 xxxDom 下面某个子元素删除</li><li>xxxDom.remove()将 xxxDom 自身删除</li></ul><ol start="3"><li>修改 DOM 元素</li></ol><ul><li>xxxDom.innerText / xxxDom.textContent 设置元素的文本内容</li><li>xxxDom.innerHTML 设置元素的 html 内容</li></ul><ol start="4"><li>获取/查询 DOM 元素</li></ol><ul><li>document.getElementById() 根据 id 选择器获取某个 DOM 元素</li><li>document.querySelector()根据任意选择器获取找到的第一个 DOM 元素</li><li>document.querySelectorAll() 根据任意选择器获取找到的所有 DOM 元素集合</li></ul><h2 id="5-说说你对闭包的理解">5. 说说你对闭包的理解</h2><ol><li>概念</li></ol><p>通过 chrome 开发者调试工具得知: 闭包本质是内部函数中的一个容器(非 js 对象), 这个容器中包含了引用的局部变量</p><ol start="2"><li>产生原因</li></ol><ul><li>函数嵌套</li><li>内部函数引用外部函数的局部变量</li><li>调用外部函数时就会产生闭包</li></ul><ol start="3"><li>闭包的生命周期</li></ol><ul><li><p>产生：当内部函数创建时</p></li><li><p>死亡：当内部函数没有变量引用，成为垃圾对象，就会自动被 GC(垃圾回收机制)自动回收</p></li></ul><ol start="4"><li>闭包作用：</li></ol><ul><li>延长局部变量生命周期（活的久点）</li><li>让函数外部可以间接操作函数内部的局部变量数据</li></ul><ol start="5"><li>闭包在项目中的应用</li></ol><ul><li>React 中复用函数的手段，高阶函数形式</li><li>实际开发中很少使用闭包，我一般研究源码时发现闭包的场景，vue2 响应式原理中数据劫持阶段，内部通过闭包形式保存 dep 对象，这个 dep 对象在 vue2 响应式原理非常重要<ul><li>源码：<a href="https://github.com/vuejs/vue/blob/main/src/core/observer/index.ts">https://github.com/vuejs/vue/blob/main/src/core/observer/index.ts</a> 128 行开始</li></ul></li></ul><h2 id="6-谈谈-this-指向">6. 谈谈 this 指向</h2><p>普通情况下，this 指向看函数的调用方式：</p><ol><li><p>直接调用（默认绑定），this 指向 window, 严格模式（‘use strict’）下指向 undefined</p></li><li><p>对象调用函数（隐式绑定），this 指向调用的对象</p></li><li><p>call/apply/bind 调用函数（显示绑定），this 指向传入第一个参数</p></li></ol><ul><li>call/apply/bind 区别和联系：<ul><li>call/apply 都会立即执行函数，bind 返回一个新函数</li><li>call/apply 执行函数时函数的 this 指向第一个参数，bind 方法返回的新函数的 this 指向第一个参数，原函数不变</li><li>call/bind 方法传参是一致的, 可以 n 个参数, apply 只能两个参数，第二个参数是数组</li></ul></li></ul><ol start="4"><li>new 调用函数，this 指向生成的实例对象</li></ol><p>特殊情况：</p><ol><li><p>箭头函数：this 指向包裹它离它最近的函数的 this（指向外部函数的 this）</p></li><li><p>回调函数：</p></li></ol><ul><li>定时器回调函数：window，严格模式下 undefined</li><li>DOM 事件回调函数：指向绑定的事件的 DOM 元素</li><li>Vue 生命周期函数 / methods 中的函数 / 微信小程序生命周期函数：指向组件实例对象</li></ul><h2 id="7-说说原型与原型链">7. 说说原型与原型链</h2><ol><li>原型</li></ol><ul><li>我们说的原型，指的是两个原型属性：<code>__proto__</code> 和 prototype</li><li>prototype 叫做显示原型属性</li><li><code>__proto__</code> 叫做隐式原型属性</li><li>每个函数都有一个显式原型属性，它的值是一个对象，我们叫做原型对象。</li><li>这个原型对象上默认会有一个 constructor 方法，指向函数本身，有一个 <code>__proto__</code> 属性，指向 Object 的原型对象</li><li>每个实例都有一个隐式原型属性，它的值指向其对应构造函数的原型对象。</li></ul><p>特殊情况:</p><ul><li><code>Function.prototype === Function.__proto__</code> 他们指向同一个对象</li><li><code>Object.prototype.__proto__ === null</code> 这里是原型链的尽头</li></ul><ol start="2"><li>原型链</li></ol><ul><li>概念：从对象的 <code>__proto__</code> 开始, 连接的所有对象, 这个结构叫做原型链，也可称为“隐式原型链”</li><li>作用：用来查找对象的属性</li><li>规则：在查找对象属性或调用对象方法时，会先在对象自身上查找， 找不到就会沿着原型链查找，找到就返回属性的值，最终来到 <code>Object.prototype.__proto__</code>，找不到返回 undefined</li><li>应用：利用原型链可以实现继承<ul><li>Vue 中全局事件总线 $bus</li><li>项目中 <code>$api / $http</code> 汇总所有接口函数</li></ul></li></ul><h2 id="8-说说-JS-的垃圾回收机制">8. 说说 JS 的垃圾回收机制</h2><p>在 JS 中对象的释放（回收）是靠浏览器中的垃圾回收器来回收处理的</p><ol><li>垃圾回调器</li></ol><ul><li>浏览器中有个专门的线程， 它每隔很短的时间就会运行一次</li><li>主要工作：判断一个对象是否是垃圾对象，如果是，清除其内存数据，并标记内存是空闲状态</li></ul><ol start="2"><li>垃圾回收策略</li></ol><ul><li>机制 1：标记清除法<ul><li>简述：标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。</li><li>缺点：<ul><li>内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块</li><li>分配速度慢，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。</li></ul></li><li>解决：可以使用 标记整理（Mark-Compact）算法，标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存</li></ul></li></ul><p><strong>至少说上面内容</strong></p><ul><li>机制 2：引用计数法<ul><li>简述：它把对象是否不再需要简化定义为对象有没有其他对象引用到它。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。</li><li>缺点：<ul><li>需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限。</li><li>解决不了循环引用导致的无法回收问题。</li></ul></li></ul></li></ul><ol start="3"><li>JS 的 V8 引擎垃圾回收机制使用的是基于标记清除算法，不过对其做了一些优化。</li></ol><ul><li>针对新生区采用并行回收。</li><li>针对老生区采用增量标记与惰性回收。</li></ul><h2 id="9-说一下-JS-的事件循环机制">9. 说一下 JS 的事件循环机制</h2><ol><li><p>概念：异步代码执行机制</p></li><li><p>流程：</p></li></ol><ul><li>js 主线程会依次执行所有代码，遇到同步代码依次执行，遇到异步代码会交给相应管理模块（分线程）去处理：<ul><li>比如遇到定时器，会交给定时器管理模块管理，它会计时，到点时会自动将回调函数添加到回调队列中（宏任务队列）</li><li>比如遇到 DOM 事件，会交给 DOM 管理模块管理，它会绑定事件，当触发事件时会自动将回调函数添加到回调队列中（宏任务队列）</li><li>比如遇到 ajax 请求，会交给 ajax 管理模块管理，它会发送请求，等响应回来时会自动将回调函数添加到回调队列中（宏任务队列）</li></ul></li><li>js 主线程并不会等，会依次执行后面的代码，直到所有代码执行完毕，js 主线程就会开启事件轮询</li><li>js 主线程会遍历回调队列中回调函数，依次取出，同步执行<ul><li>回调队列分为两种队列：宏任务队列和微任务队列</li><li>宏任务队列：定时器回调函数、ajax 回调函数、DOM 事件回调函数</li><li>微任务队列：Promise.then/catch/finally、mutationObserver（nextTick 方法的原理）</li><li>优先执行微任务队列中的回调函数，直到全部执行完毕，</li><li>在执行宏任务队列中第一个回调函数，执行完又会执行，微任务队列中的回调函数，直到全部执行完毕，</li><li>在执行下一个宏任务队列中回调函数，执行完又会执行，微任务队列中的回调函数，直到全部执行完毕，以此类推</li></ul></li></ul><h2 id="10-Web-Worker">10. Web Worker</h2><ol><li>概念</li></ol><p>Web Worker 是 H5 新特性，允许我们开辟分线程，运行 js 代码。</p><ol start="2"><li>使用</li></ol><ul><li><code>const worker = new Worker('./xxx.js')</code> 创建分线程执行 js 脚本</li><li>主线程通过 <code>worker.onmessage</code> 事件接受分线程的消息</li><li>主线程通过 <code>worker.postMessage</code> 方法向分线程发送消息</li><li>分线程通过 <code>self.onmessage</code> 事件接受主线程的消息</li><li>分线程通过 <code>self.postMessage</code> 方法向主线程发送消息</li></ul><ol start="3"><li>应用</li></ol><p>主要用于 js 中大量计算工作，比如大文件上传中计算文件的 hash，使用了 web worker</p><h2 id="11-说出-ES6-常用新语法">11. 说出 ES6 常用新语法</h2><ol><li>简单的语法</li></ol><ul><li>const 与 let</li><li>解构赋值</li><li>形参默认值</li><li>扩展运算符: …</li><li>模板字符串</li><li>对象的属性与方法简写</li><li>模块化语法</li></ul><ol start="2"><li>比较复杂的语法</li></ol><ul><li>箭头函数<ul><li>编码简洁</li><li>不能通过 new 来创建实例对象，没有 constructor 方法</li><li>内部没有 arguments, 可以通过 rest 参数来代替</li><li>没有自己的 this, 使用外部作用域中的 this, 不能通过 bind 来绑定 this</li><li>说到 this 指向，平时我专门总结过 this 指向<ul><li>…</li></ul></li></ul></li><li>还有 class 与 extends<ul><li>主要用来做继承的，是构造函数+原型的语法糖</li><li>平时在项目主要还是通过原型的方式去继承：比如$bus</li></ul></li><li>promise / generator / async &amp; await（引申 js 事件循环机制）<ul><li>promise…(细说 promise)</li><li>promise 并不是解决回调地狱的最佳方案，后面推出了 generator</li><li>generator 惰性函数（懒），暂停 yield 执行 next，但是使用太复杂了，后面又推出了 async 函数</li><li>async、await、promise 一起使用，是项目中解决回调地狱的最佳方案</li></ul></li><li>Proxy（引申 vue2 和 vue3 响应式原理）<ul><li>可以对对象进行代理，当读取/设置对象上的属性时，会执行相应的 get/Set</li><li>这个内容主要在 Vue 响应式原理中使用了，Vue3 响应式通过 Proxy 实现的，原有和新增属性都是响应式。</li></ul></li><li>Map / Set / WeakMap / WeakSet (引申 vue3 响应式原理)<ul><li>他们都是新的存储数据的结构</li><li>Map 类似于对象，存储 key-value 的结构，特点：1. 有序 2. key 是任意类型</li><li>Set 类似于数组，特点：1. 值是唯一的</li><li>WeakMap 类似于 Map，存储 key-value 的结构，特点：1. 有序 2. key 必须是对象类型 3. 一旦 key 没有外部引用，会自动删除</li><li>WeakSet 类似于 Set，特点：1. 值是唯一的 2. 值必须是对象类型 3. 一旦值没有外部引用，会自动删除</li></ul></li></ul><h2 id="12-说说-ES6-的-promise">12. 说说 ES6 的 promise</h2><ol><li>概念</li></ol><p>异步代码解决方案，用于解决回调地狱问题。</p><ol start="2"><li>promise 对象内部有 3 种状态</li></ol><ul><li>pending 初始化状态</li><li>resolved / fulfilled 成功状态</li><li>rejected 失败状态</li></ul><p>状态只能变化一次，只能有以下两种变化：</p><ul><li>pending --&gt; resolved</li><li>pending --&gt; rejected</li></ul><p>状态发生变化后不能在改了。</p><ol start="3"><li>如何改变 promise 的状态</li></ol><ul><li>调用 resolve(), 改成成功状态</li><li>调用 reject(), 改为失败状态</li><li>throw new Error(), 改为失败状态</li></ul><ol start="4"><li>promise 实例对象上的方法</li></ol><ul><li>then 接受两个回调（一般只接受一个），第一个是成功回调，第二个是失败回调</li><li>catch 接受一个回调，是失败回调</li><li>finally 接受一个回调，不管成功/失败都会触发</li></ul><ol start="5"><li>Promise 构造函数上的方法</li></ol><ul><li>Promise.resolve() 返回一个成功的 promise 对象<ul><li>也可能返回失败的 promise 对象，比如 Promise.resolve(Promise.reject())</li></ul></li><li>Promise.reject() 返回一个失败的 promise 对象</li><li>Promise.all([promise1, promise2, …]) 只有所有 promise 成功才成功，只要有一个 promise 失败就会失败</li><li>Promise.allSettled([promise1, promise2, …]) 只要所有 promise 状态发生变化就成功，结果值包含所有 promise 的结果值（不管成功/失败）</li><li>Promise.race([promise1, promise2, …]) 只要有一个 promise 成功/失败，就成功/失败。</li></ul><ol start="6"><li>应用</li></ol><ul><li>在项目中一般是使用 axios 发送请求时会使用，返回值是一个 promise 对象，结合 async await 来处理</li><li>如果同时要发送多个请求的话，可以使用 Promise.all() 方法来处理</li></ul><h2 id="13-谈谈模块化语法">13. 谈谈模块化语法</h2><ol><li>Commonjs 模块化语法</li></ol><ul><li>主要用于 NodeJS 端</li><li>语法：<ul><li>引入：require</li><li>暴露：exports / module.exports</li></ul></li></ul><ol start="2"><li>ES6 模块化语法</li></ol><ul><li><p>主要用于浏览器端</p></li><li><p>语法：</p></li><li><p>引入：import</p></li><li><p>暴露：export</p></li><li><p>总结</p><ul><li>如果模块采用默认暴露：import xxx from ‘xxx’</li><li>如果模块采用分别/统一暴露：<ul><li>如果需要引入模块部分内容：import { xxx } from ‘xxx’</li><li>如果需要引入模块全部内容：<code>import * as xxx from 'xxx'</code></li></ul></li></ul></li><li><p>扩展</p><ul><li>无论什么暴露方式，暴露的一定是一个对象<ul><li>默认暴露：对象上添加一个 default 属性，值为暴露的内容</li><li>分别暴露/统一暴露：直接在对象上暴露内容</li></ul></li><li><code>import &#123; xxx &#125; from './xxx'</code> 引入暴露内容的某个属性（部分）</li><li><code>import xxx from './xxx'</code> 引入暴露内容的 default 属性（只要 default）</li><li><code>import * as xxx from './xxx'</code> 引入暴露内容的所有内容（全部）</li></ul></li></ul><h2 id="14-谈谈箭头函数">14. 谈谈箭头函数</h2><ul><li>编码简洁</li><li>不能通过 new 来创建实例对象，没有 constructor 方法</li><li>内部没有 arguments, 可以通过 rest 参数来代替</li><li>没有自己的 this, 使用外部作用域中的 this, 不能通过 bind 来绑定 this</li><li>说到 this 指向，平时我专门总结过 this 指向<ul><li>…</li></ul></li></ul><h2 id="15-浅度克隆和深度克隆">15. 浅度克隆和深度克隆</h2><ol><li>浅度克隆</li></ol><ul><li>object.assign()</li><li>扩展运算符: { …obj }</li><li>Array.prototype.slice()</li><li>Array.prototype.concat()</li></ul><ol start="2"><li>深度克隆</li></ol><ul><li>JSON.parse(JSON.stringify())</li><li>自定义深度克隆</li><li>lodash 中 cloneDeep</li></ul><ol start="3"><li>区别</li></ol><ul><li>浅度克隆: 对当前对象进行克隆，基本类型克隆生成新值，引用类型克隆的是地址值（所以当修改对象内部引用类型数据时，原对象也会发生变化）</li><li>深度克隆: 会完全复制整个对象，包括这个对象所包含的内部对象（所以不管如何修改对象数据，原对象都不会发生变化）。</li></ul><ol start="4"><li>深度克隆应用</li></ol><p>权限管理功能中使用深度克隆克隆了异步路由表</p><h2 id="16-节流和防抖">16. 节流和防抖</h2><h1>TypeScript</h1><h2 id="1-JavaScript-和-TypeScript-的区别">1. JavaScript 和 TypeScript 的区别</h2><ol><li>JavaScript 没有重载概念，TypeScript 有可以重载和接口类型合并</li><li>TypeScript 扩展更多的类型： 接口 interface、泛型、enum、unknown、any、void、never 等；</li><li>TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中；</li></ol><h2 id="2-interface-和-type-的区别">2. interface 和 type 的区别</h2><ol><li>interface 只能定义引用数据类型，不能定义基本数据类型。而 type 都可以；</li><li>interface 定义对象类型不够灵活，type 都可以；</li><li>type 声明的类型不能重名，interface 声明的重命名会声明合并；</li><li>两者继承的方法不同；</li></ol><ul><li>interface 使用 extends 继承</li><li>type 使用 &amp; 关键字</li></ul><p>总结： 一般开发中对象类型用 interface 定义，数组类型用 type</p><h2 id="3-泛型">3. 泛型</h2><ol><li>概念</li></ol><p>在接口、类、函数的时候，不预先定义类型，而是在使用时定义类型</p><ol start="2"><li>泛型默认值</li></ol><p><code>&lt;T = string&gt;</code></p><ol start="3"><li>泛型约束</li></ol><p><code>&lt;T extends U&gt;</code></p><ol start="4"><li><p>泛型工具类型：Pick(挑选)、Omit（排除）、Partial（可选）、Required（必填）</p></li><li><p>泛型应用：</p></li></ol><ul><li>axios: <code>request&lt;any, Xxx&gt;()</code></li><li>react: <code>useState&lt;Xxx&gt;()</code></li><li>vue3: <code>ref&lt;Xxx&gt;()</code> <code>reactive&lt;Xxx&gt;()</code></li></ul><h1>Server</h1><h2 id="1-谈谈-http-协议">1. 谈谈 http 协议</h2><ol><li>概念</li></ol><p>HTTP 是超文本传输协议(Hypertext Transfer Protocol)，是浏览器与服务器通信的协议。</p><ol start="2"><li>报文</li></ol><p>协议通信的内容我们称为报文。</p><p>浏览器发送给服务器叫做请求报文，服务器返回给浏览器的叫做响应报文。</p><p>报文由报文首行、报文头部、空行、报文体组成。</p><ol start="3"><li>请求报文</li></ol><p>请求报文：请求首行、请求头、空行、请求体组成。</p><p>请求首行主要有：请求方式、请求地址、get 请求的查询字符串参数、协议和版本号</p><p>请求头主要有：</p><ul><li><code>Connection: keep-alive</code> 保持长链接, 能共享一个 TCP 链接通道来发送请求，通信效率更高</li><li><code>Content-Type</code> 请求体参数类型<ul><li>我们使用 axios 发送请求，一般是：application/json 格式</li><li>我们使用原生 form 表单发送请求，一般是：application/x-www-form-urlencoded 格式</li></ul></li><li><code>User-Agent</code> 用户代理, 可以识别用户的客户端环境</li><li><code>Referer</code> 请求来源地址, 防盗链</li><li><code>Cookie / token</code> 用户唯一标识</li></ul><p>请求体主要有：POST 请求的参数</p><ol start="4"><li>响应报文</li></ol><p>响应报文：响应首行、响应头、空行、响应体组成。</p><p>响应首行主要有：协议和版本号、响应状态码</p><p>响应状态码分为 5 种类型：1xx、2xx、3xx、4xx、5xx（1 开头、2 开头、3 开头、4 开头、5 开头）</p><ul><li>1xx 请求正在处理</li><li>2xx 请求处理成功<ul><li>200 请求成功</li></ul></li><li>3xx 请求需要进一步处理（请求重定向）<ul><li>301 永久重定向</li><li>302 临时重定向</li><li>304 重定向到浏览器缓存中（协商缓存）</li></ul></li><li>4xx 客户端错误<ul><li>401 认证/授权失败</li><li>403 禁止访问</li><li>404 找不到资源</li><li>407 token 过期/失效</li></ul></li><li>5xx 服务器错误<ul><li>500 服务器内部错误</li></ul></li></ul><p>响应头：</p><ul><li>强制缓存字段 Cache-Control / Expires</li><li>协商缓存字段 Etag / Last-Modified</li><li>CORS 解决跨域字段：Access-Control-Allow-Origin</li></ul><p>响应体：响应的具体数据</p><h2 id="2-HTTP-1-1-和-HTTP-2-0-的区别">2. HTTP 1.1 和 HTTP 2.0 的区别</h2><ol><li>二进制格式(Binary Format)</li></ol><ul><li>HTTP/1.1 通信内容可以是文本或二进制</li><li>HTTP/2 通信内容都是二进制</li></ul><ol start="2"><li>多路复用(MultiPlexing)</li></ol><ul><li>HTTP/1.1 长链接（connection: keep-alive）是串行的，后面的请求等待前面请求的返回才能发送</li><li>HTTP/2 多路复用，一个连接里，客户端和服务器都可以同时发送多个请求或响应，而且不用按照顺序一一发送</li></ul><ol start="3"><li>头部压缩</li></ol><ul><li>HTTP 1.1 通信的请求头内容太多了，多次通信字段重复</li><li>HTTP/2 实现了头部压缩（ gzip 或 compress ），体积更小，同时只会发送不同的字段，和相同字段的索引号，体积更小</li></ul><ol start="4"><li>服务器推送(server push)</li></ol><ul><li>HTTP 1.1 协议不能服务器向浏览器发送消息，需要借助 ajax 轮询或 WebSocket 实现</li><li>HTTP/2 允许服务器向浏览器主动发送消息</li></ul><h2 id="3-HTTP-和-HTTPS-协议的区别">3. HTTP 和 HTTPS 协议的区别</h2><ol><li>HTTP 协议是明文传输的，HTTPS 通过 SSL 加密传输的；</li><li>使用不同的连接方式，端口也不同，HTTP 协议默认端口是 80，HTTPS 协议默认端口是 443；</li></ol><h2 id="4-TCP-的三次握手和四次挥手">4. TCP 的三次握手和四次挥手</h2><p>三次握手的目的：是为了确认双方的接收能力和发送能力是否正常。</p><p>第一次握手：由浏览器发送给服务器，服务器确定浏览器的发送能力<br>第二次握手：由服务器发送给浏览器，浏览器确定的服务器接受和发送能力<br>第三次握手：由浏览器发送给服务器，服务器确定的浏览器的接受能力</p><p>四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代表不能再向对方发送数据，连接处于的是半释放的状态。（确保双方都接受完毕和发送完毕数据）</p><p>第一次挥手：由浏览器发送给服务器，告诉服务器数据发送完了<br>第二次挥手：由服务器发送给浏览器，告诉浏览器数据接受完了<br>第三次挥手：由服务器发送给浏览器，告诉浏览器数据发送完了<br>第四次挥手：由浏览器发送给服务器，告诉服务器数据接受完了，此时浏览器会自动断开链接，服务器也会</p><h2 id="5-当在浏览器输入一个地址，按下回车发生了什么">5. 当在浏览器输入一个地址，按下回车发生了什么</h2><ol><li>解析 URL</li></ol><p>解析 URL 是否合法，合法进行下一步，不合法就直接出错。</p><ol start="2"><li>缓存判断</li></ol><p>判断该请求是否命中缓存，命中直接读取缓存，没有命中进行下一步</p><ol start="3"><li>DNS 解析</li></ol><p>将域名地址解析为 ip 地址</p><p>流程：</p><ul><li>首先读取 DNS 缓存：浏览器 DNS 缓存 - 计算机 DNS 缓存 - 路由器 DNS 缓存 - 网络运营商</li><li>然后 DNS 递归查询：根域名服务器 - 顶级域名服务器 - 权威域名服务器</li></ul><ol start="4"><li>TCP 三次握手</li></ol><p>为了确认双方的接收能力和发送能力是否正常。</p><p>第一次握手：由浏览器发送给服务器，服务器确定浏览器的发送能力<br>第二次握手：由服务器发送给浏览器，浏览器确定的服务器接受和发送能力<br>第三次握手：由浏览器发送给服务器，服务器确定的浏览器的接受能力</p><ol start="5"><li>发送请求</li></ol><p>将请求以请求报文形式发送给服务器。</p><p>请求报文由请求首行、请求头、空行、请求体组成。</p><p>请求首行主要有：请求方式、请求地址、get 请求的查询字符串参数、协议和版本号</p><p>请求头主要有：</p><ul><li><code>Connection: keep-alive</code> 保持长链接, 能共享一个 TCP 链接通道来发送请求，通信效率更高</li><li><code>Content-Type</code> 请求体参数类型<ul><li>我们使用 axios 发送请求，一般是：application/json 格式</li><li>我们使用原生 form 表单发送请求，一般是：application/x-www-form-urlencoded 格式</li></ul></li><li><code>User-Agent</code> 用户代理, 可以识别用户的客户端环境</li><li><code>Referer</code> 请求来源地址, 防盗链</li><li><code>Cookie / token</code> 用户唯一标识</li></ul><p>请求体主要有：POST 请求的参数</p><p><strong>报文内容简单说说也行，可以不用这么复杂</strong></p><ol start="6"><li>返回数据</li></ol><p>服务器以响应报文形式返回响应</p><p>响应报文：响应首行、响应头、空行、响应体组成。</p><p>响应首行主要有：协议和版本号、响应状态码</p><p>响应状态码分为 5 种类型：1xx、2xx、3xx、4xx、5xx（1 开头、2 开头、3 开头、4 开头、5 开头）</p><ul><li>1xx 请求正在处理</li><li>2xx 请求处理成功<ul><li>200 请求成功</li></ul></li><li>3xx 请求需要进一步处理（请求重定向）<ul><li>301 永久重定向</li><li>302 临时重定向</li><li>304 重定向到浏览器缓存中（协商缓存）</li></ul></li><li>4xx 客户端错误<ul><li>401 认证/授权失败</li><li>403 禁止访问</li><li>404 找不到资源</li><li>407 token 过期/失效</li></ul></li><li>5xx 服务器错误<ul><li>500 服务器内部错误</li></ul></li></ul><p>响应头：</p><ul><li>强制缓存字段 Cache-Control / Expires</li><li>协商缓存字段 Etag / Last-Modified</li><li>CORS 解决跨域字段：Access-Control-Allow-Origin</li></ul><p>响应体：响应的具体数据</p><p><strong>报文内容简单说说也行，可以不用这么复杂</strong></p><ol start="7"><li>页面渲染</li></ol><ul><li>将 DOM 结构解析成 DOM 树</li><li>将 CSS 样式解析成 CSSOM 树</li><li>将 DOM 树和 CSSOM 树合成渲染（render）树</li><li>根据渲染（render）树首先进行布局，然后进行渲染</li><li>整个过程会触发多次渲染，也就是说构建了部分 DOM 树和 CSSOM 树就会开始合成渲染了</li><li>如果遇到 script 标签会同步执行里面的 js 代码，会阻塞渲染</li><li>如果 script 标签 js 操作了 DOM 或 CSS，重新生成 DOM 树和 CSSOM 树，合成渲染树，布局（重排），渲染（重绘）</li></ul><ol start="8"><li>TCP 四次挥手</li></ol><p>四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代表不能再向对方发送数据，连接处于的是半释放的状态。（确保双方都接受完毕和发送完毕数据）</p><p>第一次挥手：由浏览器发送给服务器，告诉服务器数据发送完了<br>第二次挥手：由服务器发送给浏览器，告诉浏览器数据接受完了<br>第三次挥手：由服务器发送给浏览器，告诉浏览器数据发送完了<br>第四次挥手：由浏览器发送给服务器，告诉服务器数据接受完了，此时浏览器会自动断开链接，服务器也会</p><h2 id="6-强制缓存和协商缓存">6. 强制缓存和协商缓存</h2><p>强制缓存字段：Cache-Control（优先级更高） 、Expires</p><p>协商缓存字段：位于响应头的：Etag / Last-Modified 和位于请求头的 If-None-Match / If-Modified-Since</p><p>整体流程：</p><ol><li><p>第一次请求该资源，没有缓存，服务器返回新资源，同时在响应头携带：强制缓存字段 Cache-Control 和 协商缓存字段：Etag / Last-Modified，此时响应状态码 200</p></li><li><p>第二次以后请求该资源，首先判断该资源强制缓存是否过期，没有过期，直接读取缓存，不会发送请求了，响应状态码 200</p></li><li><p>如果强制缓存过期了，就会发送请求给服务器，同时在请求头自动携带协商缓存字段: 此时 Etag 会改名为 If-None-Match, Last-Modified 会改名为 If-Modified-Since</p></li><li><p>由服务器检查和服务器的 Etag 和 Last-Modified 是否匹配</p></li><li><p>如果匹配没变，就返回响应状态码 304，浏览器接受到会自动去缓存中找该资源使用</p></li><li><p>如果变了，就会返回新的资源，同时在响应头携带新的：强制缓存字段 Cache-Control 和 协商缓存字段：Etag / Last-Modified，此时响应状态码 200</p></li></ol><h2 id="7-谈谈-WebSocket">7. 谈谈 WebSocket</h2><p>WebSocket 是一个全双工通讯协议。</p><p>特点：服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。</p><p>使用：</p><p>new WebSocket(url) 传入 url 就可以连接上 WebSocket 服务器了</p><p>通过 message：接受服务器发送的消息</p><p>通过 send 方法：可以给服务器发送消息</p><p>除此以外还有其他方法：close 关闭连接</p><p>其他事件：open：打开事件 error 错误事件 close 关闭事件</p><p>功能：WebSocket 连接时可能因为不好的网络环境会断开链接，此时可以使用心跳检测机制来进行断开重连</p><p>心跳检测:</p><p>web socket 在连接过程中可能会因为网络问题断开连接，我们需要重连，这里用到心跳检测机制</p><p>具体来说：</p><ol><li>检测是否断开链接：</li></ol><p>当我们连接上 ws 服务时，需要开启定时器，隔一段时间（10s - 30s）向 ws 服务器发送一个特殊信号（ping），同时开启定时器（2s）检测服务器是否有回应信号（pong）</p><p>如果在规定时间内有回应，继续此操作，如果没有回应，说明断开连接了，我们要开始重连 ws</p><ol start="2"><li>重连机制</li></ol><p>每隔一段时间发起 ws 的重连，同时重连次数增加，一旦重新连接成功，就归零重连次数，方便下次重连，如果重连次数超过最大次数，就要提示错误，不在尝试了</p><h2 id="8-谈谈-ajax">8. 谈谈 ajax</h2><p>可以发送异步请求，进行局部页面更新</p><p>流程：</p><ol><li>new XMLHttpRequest() 来创建 xhr 对象</li><li>通过 xhr 调用 open 方法，设置请求方式和请求地址（请求地址可以添加查询字符串参数）</li><li>通过 xhr.send 方法发送请求（可以携带请求体参数）</li><li>通过 xhr.onreadystatechange 或 onload 事件监听响应回来的结果，往往需要判断 xhr 的响应状态码是否 2 开头，来判断请求成功还是失败</li></ol><h2 id="9-跨域">9. 跨域</h2><ol><li><p>什么是跨域？<br>违背同源策略产生跨域。</p></li><li><p>什么是同源策略？<br>同源指的是：协议、域名、端口号三者必须完全一致。</p></li><li><p>什么样的请求存在跨域问题？</p></li></ol><p>只有浏览器端的 ajax 请求存在跨域。</p><p>服务器与服务器之间没有跨域，浏览器的 script、img、form 等标签都没有跨域。</p><ol start="4"><li>解决跨域的方案：</li></ol><ul><li>jsonp: 利用 script 标签可以跨域特性进行跨域。</li></ul><p>可以说说具体做法</p><ul><li><p>cors: 服务器设置特定响应头即可实现。access-control-allow-Origin</p></li><li><p>NodeJS 代理服务器: 这是我开发中主要使用解决跨域的方案</p></li></ul><p>比如 vue2 项目，可以在 vue.config.js 中进行配置，配置 devServer 的 proxy，设置代理请求前缀和目标服务器地址等来完成</p><ul><li>Nginx 代理服务器：项目上线时公司采用 nginx 反向代理解决跨域</li></ul><h2 id="10-Nginx">10. Nginx</h2><ol><li>概念</li></ol><p>Nginx 是开源、高性能、高可靠的 Web 服务器和反向代理服务器。</p><ol start="2"><li>基本使用</li></ol><ul><li>反向代理解决跨域</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">3000</span>;</span><br><span class="line">  <span class="attribute">server_name</span> localhost;</span><br><span class="line">  <span class="section">location</span> /app-prod &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://xxx.com/; <span class="comment"># 转发到目标服务器地址</span></span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/app-prod/(.*)</span> /<span class="variable">$1</span> <span class="literal">break</span>; <span class="comment"># 路径重写</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解决 history 模式前端路由 404 问题</li></ul><p><code>try_files $uri $uri/ /index.html;</code></p><h1>Builder</h1><h2 id="1-谈谈-Git-常见指令">1. 谈谈 Git 常见指令</h2><h2 id="2-谈谈-Git-Flow-Git-工作流程">2. 谈谈 Git Flow / Git 工作流程</h2><ol><li>概念</li></ol><p>是一个 git 标准化操作流程</p><ol start="2"><li>Git 分支</li></ol><ul><li>master 是长期分支，一般用于管理对外发布版本，每个 commit 对一个 tag，也就是一个发布版本</li><li>develop 是长期分支，一般用于作为日常开发汇总，即开发版的代码<br>开发一个新的 feature 直接新在 develop 新开一个临时的 feature 分支，开发完成向 develop 提 Pull Request。</li><li>feature 是短期分支，一般用于一个新功能的开发</li><li>hotfix 是短期分支 ，一般用于正式发布以后，出现 bug，需要创建一个分支，进行 bug 修补。</li><li>release 是短期分支，一般用于发布正式版本之前（即合并到 master 分支之前），需要有的预发布的版本进行测试。release 分支在经历测试之后，测试确认验收，将会被合并的 develop 和 master。</li></ul><ol start="3"><li>提交 commit 规范</li></ol><ul><li><p>feat：开发新功能（feature）</p></li><li><p>fix：修复 bug</p></li><li><p>style： 调整格式（不影响代码运行的变动）</p></li><li><p>build：修改构建相关内容，如 npm、maven 内容。</p></li><li><p>imp：优化已有功能(improve)</p></li><li><p>refactor：重构功能</p></li><li><p>test：添加测试</p></li><li><p>docs：撰写文档（documentation）</p></li><li><p>ci：修改持续集成相关内容(Continues Intergration)</p></li></ul><p><strong>记住一部分就好</strong></p><ol start="4"><li>流程概述</li></ol><ul><li>开发时，以 develop 分支为模板新建一个新的分支：feature/{任务 id}-{任务名称}</li><li>克隆仓库，拉取 feature 开发分支，切换到 feature 开发分支上进行开发</li><li>开发完成，提交合并请求（Pull Request, 也叫 PR），合并 feature 和 develop 分支代码</li><li>由组长审核通过，经过流水线（eslint 检查、测试等），完成合并</li><li>当所有特性开发&amp;基本测试完成，会以 develop 分支为模板新建一个新的分支：release/{版本号}</li><li>release 是预发布分支，会进行进一步测试</li><li>没问题后，会将 release 分支合并到 master 分支，同时生成一个 tag 备份代码，上线代码从 master 分支取出使用</li><li>将来上线代码出现问题，会以 master 分支为模板创建新的分支：hotfix/{任务 id}-{bug 名称}</li><li>解决 bug 后，会合并到 master 分支上，生成新的 tag</li></ul><h2 id="3-谈谈-Webpack">3. 谈谈 Webpack</h2><ol><li>概念</li></ol><p>静态模块打包工具，可以将静态模块编译、打包和输出成一个或多个文件（bundles）。</p><ol start="2"><li>5 个核心概念</li></ol><ul><li>入口(entry): 指示 webpack 从哪个文件开始打包。</li><li>输出(output): 指示 webpack 编译、打包后的文件输出到哪里去。</li><li>加载器(loader): webpack 只能识别 js、json 文件，其他类型的文件需要通过 loader 转化成有效模块才能识别。<ul><li>比如：处理样式文件可以使用 css-loader\style-loader\less-loader\sass-loader</li><li>处理 vue 文件可以使用 vue-loader</li></ul></li><li>插件(plugin): 相对 loader，plugin 可以做范围更广的工作，比如：打包优化，资源管理，注入环境变量。<ul><li>比如：处理 html 资源需要使用 html-webpack-plugin</li><li>eslint 语法风格检查需要使用 eslint-webpack-plugin</li></ul></li><li>模式(mode): 可以选择 development, production 或 none 之中的一个。不同模式会加载不同的配置。</li></ul><h2 id="4-webpack-优化">4. webpack 优化</h2><h2 id="5-vite-和-webpack-的区别">5. vite 和 webpack 的区别</h2><ol><li>底层语言不同</li></ol><p>Vite 是基于 esbuild 采用 go 语言编写，go 语言的操作是纳秒级别</p><p>Webpack 是基于 Nodejs，以毫秒计数</p><p>所以 vite 比 webpack 更快。</p><ol start="2"><li>启动方式</li></ol><p>webpack 启动慢：webpack 首先分析各个模块之间的依赖，然后将所有内容进行打包，模块越多打包速度越慢，所以启动慢。</p><p>vite 启动快：vite 采用了一种懒加载的方式，它在启动的时候不需要打包，而是需要某个模块时，再对模块内容进行编译，所以启动很快</p><ol start="3"><li>首屏渲染</li></ol><p>webpack 渲染快：webpack 启动时已经将所有内容进行打包了，渲染时直接获取资源渲染即可</p><p>vite 渲染慢：Vite 渲染时才会打包编译文件，然后再渲染，打包越慢，渲染速度越慢（但是 vite 有缓存，所以第二次渲染速度没问题）</p><ol start="4"><li>生态</li></ol><p>webpack 诞生很久了，生态基本完善</p><p>vite 生态不够全，对代码分割不够友好</p><h1>React</h1><h2 id="1-React-和-Vue-的区别">1. React 和 Vue 的区别</h2><ol><li>数据流</li></ol><ul><li>Vue 默认支持双向数据绑定</li><li>React 提倡单向数据流</li></ul><ol start="2"><li>虚拟 DOM</li></ol><ul><li>Vue 宣称可以更快地计算出 Virtual DOM 的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</li><li>对于 React 而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate 这个生命周期方法来进行控制，但 Vue 将此视为默认的优化。</li></ul><ol start="3"><li>组件化</li></ol><ul><li>Vue 提供单文件组件方式，类似于 HTML 语法。</li><li>React 通过 JSX 语法来定义组件。</li></ul><ol start="4"><li>更新用户界面方式</li></ol><ul><li>Vue 的数据是响应式的，更新数据同时用户界面也会更新</li><li>React 要触发用户界面更新需要使用 this.setState 方法或者 useState 提供的函数</li></ul><ol start="5"><li>构建工具</li></ol><ul><li>Vue 有 vite-cli / vue-cli</li><li>React 有 create-react-app</li></ul><ol start="6"><li>跨平台</li></ol><ul><li>Vue 有 Weex</li><li>React 有 React Native</li></ul><ol start="7"><li>数据可变性</li></ol><ul><li>Vue 使用的是可变数据</li><li>React 强调不可变数据</li></ul><h2 id="2-谈谈-redux">2. 谈谈 redux</h2><h2 id="3-对-React-Hook-的理解">3. 对 React Hook 的理解</h2><h2 id="4-React-组件间通信">4. React 组件间通信</h2><h2 id="5-React-生命周期">5. React 生命周期</h2><h2 id="6-谈谈-React-Router">6. 谈谈 React Router</h2><h2 id="7-什么是虚拟-DOM？">7. 什么是虚拟 DOM？</h2><h2 id="8-React-中虚拟-DOM-Diff-算法">8. React 中虚拟 DOM Diff 算法</h2><h1>Vue</h1><h2 id="1-生命周期函数">1. 生命周期函数</h2><ol><li>基础</li></ol><ul><li>初始化阶段<ul><li>beforeCreate</li><li>created</li></ul></li><li>挂载阶段<ul><li>beforeMount</li><li>mounted</li></ul></li><li>更新阶段<ul><li>beforeUpdate</li><li>updated</li></ul></li><li>卸载阶段<ul><li>Vue2: beforeDestroy / destroyed</li><li>Vue3: beforeUnmount / unmounted</li></ul></li></ul><ol start="2"><li>重要的生命周期</li></ol><p>其中重要生命周期：mounted 和 beforeDestroy（beforeUnmount）</p><ul><li>mounted 用来发送请求、设置定时器、绑定事件等任务</li><li>beforeDestroy 用来解绑定时器，解绑事件等收尾工作，防止内存泄漏</li></ul><ol start="3"><li>其他生命周期函数</li></ol><p>除此之外，还有一些别的生命周期函数：</p><ul><li><p>被 keep-alive 缓存的组件会自动拥有两个生命周期函数</p><ul><li>activated</li><li>deactivated</li></ul></li><li><p>用来捕获后代组件产生的错误</p><ul><li>errorCaptured</li></ul></li></ul><ol start="4"><li>Vue3 提供了两种开发模式：选项式和组合式，其中组合式 API 生命周期用法有一些变化</li></ol><ul><li>setup：相当于之前的 beforeCreate/created</li><li>剩下的生命周期函数需要引入使用，比如：<ul><li>onMounted</li><li>onBeforeUnmount</li></ul></li><li>每个生命周期函数都能使用多次</li></ul><h2 id="2-组件间通信">2. 组件间通信</h2><ol><li>props 父 -&gt; 子</li></ol><p>可以展开说说 props 具体内容</p><ol start="2"><li>自定义事件 子 -&gt; 父</li></ol><ul><li>Vue2 中给组件绑定的事件默认都是自定义事件，加上<code>.native</code>才是 DOM 事件</li><li>Vue3 中给组件绑定的事件默认是 DOM 事件（当然实际要满足条件才会绑定：1. 事件名需要是 DOM 事件名称 2. 子组件必须有根标签 3. 子组件内部不能 defineEmits 声明接受），不满足条件就是自定义事件</li></ul><ol start="3"><li>v-model 父 &lt;-&gt; 子</li></ol><p>vue2 和 vue3 用法也不一样：</p><ul><li>vue2 中给组件绑定 value 属性和 input 自定义事件</li><li>vue3 中默认给组件绑定 modelValue 属性和 update:modelValue 事件<ul><li>也可以通过 v-model:xxx 的方式修改属性名和事件名</li></ul></li></ul><ol start="4"><li>v-bind:xxx.sync 父 &lt;-&gt; 子</li></ol><ul><li>只有 vue2 才能使用，vue3 不能使用了</li><li>绑定 xxx 属性和 update:xxx 自定义事件</li></ul><ol start="5"><li>插槽 父 &lt;-&gt; 子</li></ol><ul><li>通信的内容主要是标签数据（之前通信方案都是普通数据）</li><li>分类：默认插槽、具名插槽和作用域插槽</li><li>一般我设置组件时，会优先最重要内容用默认插槽（因为简单），其他内容考虑具名插槽，如果需要子向父通信用作用域插槽（table）</li></ul><ol start="6"><li>vuex / pinia 兄弟、祖孙</li></ol><ul><li>一般 vue2 项目用 vuex，vue3 项目用 pinia</li></ul><ol start="7"><li>还有其他通信方案</li></ol><ul><li>全局事件总线(兄弟)：vue2 中能使用，vue3 不能使用了, 因为删除了<code>$on/$off</code>等自定义事件方法，想要使用必须用第三方库，比如 mitt 实现</li><li><code>$parent/$children/$refs</code>（父 &lt;-&gt; 子），其中 vue3 删除了<code>$children</code></li><li><code>$attrs/$listeners</code> （父 -&gt; 子）, 其中 vue3 删除了<code>$listeners</code>， 内容放入了<code>$attrs</code>中</li><li>provide/inject 祖孙</li></ul><h2 id="3-谈谈-Vuex">3. 谈谈 Vuex</h2><p>一个集中式状态管理方案，通常用于管理多个组件共享的状态数据。</p><p>开发时需要定义主模块和其他分模块</p><p>主模块主要定义 modules 属性用来汇总其他分模块</p><p>其他分模块主要定义 state、getters、actions、mutations、namespaced。</p><ul><li>state 模块管理的状态数据</li><li>getters 只读计算属性数据</li><li>actions 一般用来与服务器进行交互的函数，比如：发送请求</li><li>mutations 直接更新数据的函数</li><li>namespaced 的值为 true，开启命名空间，这样每个 vuex 模块的内容就被隔离，不会互相影响。</li></ul><p>组件读取/更新 vuex 数据有两种方式，一种通过<code>$store</code>，一种 map 函数形式</p><p>一般如果数据只用一两次，我会用$store，比较简单。数据比较频繁使用，用 map 函数形式</p><h2 id="4-谈谈-Pinia">4. 谈谈 Pinia</h2><p>一个集中式状态管理方案，通常用于管理多个组件共享的状态数据。</p><p>相对于 Vuex 来说，pinia 优点：</p><ul><li>没有 mutations （流程更简洁）</li><li>Typescript 支持更友好</li><li>pinia 模块定义即可使用，不用汇总</li></ul><p>开发时需要定义主模块和其他分模块：主模块定义好后，就定义分模块即可，不用汇总</p><p>分模块主要由以下内容：</p><ul><li>state 模块管理的状态数据</li><li>getters 只读计算属性数据</li><li>actions 与服务器进行交互（发送请求），同时更新数据</li></ul><p>组件引入分模块暴露的 useXxxStore 函数，得到 Store 对象，即可操作数据和方法了</p><ul><li>一般如果我需要直接更新一个数据：就直接操作数据即可</li><li>如果我需要直接更新多个数据：store.$patch 方法更新数据</li><li>如果我需要更新数据并且发送请求：就需要定义 action 函数，通过 store 调用 action 函数来更新</li></ul><h2 id="5-Vue2-和-Vue3-的区别">5. Vue2 和 Vue3 的区别</h2><ol><li>生命周期不一样</li></ol><p>卸载阶段</p><ul><li>vue2 beforeDestroy destroyed</li><li>vue3 beforeUnmount unmounted</li></ul><ol start="2"><li>组件间通信方案用法不一样</li></ol><ul><li>vue3 删除了<code>$on/$off/$once</code>API，所以默认不能全局事件总线，如果想要使用全局事件总线，需要使用第三方库 mitt</li><li>vue3 删除了 v-bind:xxx.sync 修饰符，父子组件双向通信只能使用 v-model</li><li>v-model 对组件用法不一样<ul><li>vue2 v-model 绑定的是 value 属性和 input 自定义事件</li><li>vue3 v-model 绑定的是 modelValue 属性和 update:modelValue 自定义事件</li></ul></li><li>vue3 删除<code>$listeners</code>，整合到<code>$attrs</code>中</li><li>vue3 删除<code>$children</code>，获取子组件实例对象必须使用 ref</li></ul><ol start="3"><li>指令不一样</li></ol><ul><li>v-for 和 v-if 优先级不同<ul><li>vue2 是 v-for 优先级更高</li><li>vue3 是 v-if 优先级更高</li></ul></li><li>vue3 新增了一个指令：v-memo 用来缓存 DOM 元素</li><li>vue3 删除了 v-bind:xxx.sync 修饰符</li><li>vue3 v-model 用法不一样</li></ul><ol start="4"><li>开发模式不一样</li></ol><ul><li>vue2 只有选项式开发模式</li><li>vue3 除了有选项式开发模式以外，新增了组合式开发模式<ul><li>setup</li><li>ref / reactive / watch / computed</li><li>onMounted / onBeforeUnmount</li></ul></li></ul><ol start="5"><li>响应式原理不一样</li></ol><ul><li>vue2 通过 Object.defineProperty 实现的响应式</li><li>vue3 通过 Proxy 实现的响应式</li></ul><h2 id="6-谈谈-Vue-的指令">6. 谈谈 Vue 的指令</h2><ol><li>常用指令</li></ol><ul><li>v-if / v-else-if / v-else 条件渲染（控制元素的显示和隐藏）</li><li>v-show 条件渲染（控制元素的显示和隐藏）<ul><li>v-if 和 v-show 区别：<ul><li>v-if 隐藏时，销毁元素（卸载组件）</li><li>v-show 隐藏时，通过 display:none 来隐藏的</li><li>结论：频繁切换用 v-show，不频繁用 v-if</li></ul></li></ul></li><li>v-for 遍历展示（列表渲染）<ul><li>key 属性作用：在 diff 算法中，尽可能复用相同 key 的元素，更新性能更好</li><li>key 属性取值：一般用 id，用 index 可能导致更新性能不好</li><li>v-for 和 v-if 优先级：<ul><li>vue2 是 v-for 更高</li><li>vue3 是 v-if 更高</li></ul></li></ul></li><li>v-on 绑定事件 @<ul><li>事件修饰符 .prevent .stop .once .self</li><li>按键修饰符 .enter .13</li></ul></li><li>v-model 双向数据绑定<ul><li>双向数据绑定原理<ul><li>给普通 input 元素（text）绑定，绑定的是 value 属性和 input 事件</li><li>给单选（radio）或多选（checkout）绑定，绑定的是 checked 属性和 change 事件</li><li>给下拉列表（select）绑定，绑定的是 value 属性和 change 事件</li><li>给组件绑定<ul><li>vue2 中，组件绑定和普通元素绑定效果一样</li><li>vue3 中，默认绑定 modelValue 属性和 update:modelValue 事件</li></ul></li></ul></li></ul></li><li>v-bind 单向数据绑定（强制绑定数据） :</li><li>v-slot 插槽 #<ul><li>默认插槽、具名插槽和作用域插槽</li></ul></li><li>v-memo(新增的指令) 用于缓存部分 DOM 元素</li></ul><ol start="2"><li>不常用指令</li></ol><ul><li>v-text 设置元素 textContent</li><li>v-html 设置元素 innerHTML</li><li>v-once 元素只解析渲染一次，后续再也不变了</li><li>v-pre 跳过解析，直接渲染最原始的内容</li><li>v-cloak 防止解析时渲染表达式(用于隐藏尚未完成编译的 DOM 模板。)</li></ul><h2 id="7-ref-和-reactive-的区别">7. ref 和 reactive 的区别</h2><ol><li>ref 可以用来定义基本类型和引用类型数据，reactive 只能用来定义引用类型数据；</li><li>ref 定义的数据如果是引用数据类型，实际是通过 reactive 来定义的。</li><li>ref 定义的数据需要通过 .value 来读取或更新，reactive 可以直接操作数据；</li></ol><h2 id="8-谈谈-Vue-Router">8. 谈谈 Vue Router</h2><ol><li>概念<br>用来实现 Vue 的单页面应用（single page web application，SPA）。</li></ol><p>单页面应用特点：</p><ul><li>整个应用只有一个完整页面，所有更新只是这个页面的局部渲染</li><li>点击页面链接不会刷新整个页面，只会更新浏览历史记录和页面局部更新</li></ul><ol start="2"><li>路由两种模式</li></ol><ul><li>hash<ul><li>特点<ul><li>hash 路径带 #，# 后面的值（路由路径）不会提交到 server 端；</li><li>hash 可以改变 url ，准确来说改变的是 # 后面的值，页面不会刷新；</li><li>兼容性更好, IE6+。</li></ul></li><li>原理<ul><li>hash 通过 window.location.hash 的方式，实现路由跳转的功能。</li><li>hash 通过 window.onhashchange 的方式，来监听 hash 的改变，借此实现无刷新跳转的功能。</li></ul></li></ul></li><li>history<ul><li>特点<ul><li>history 路径不带 #，更美观。</li><li>history 可以改变 url ，改变的是整个 url，页面不会刷新；</li><li>兼容性稍差, IE10+；</li><li>页面刷新时，history 可能会出现 404 问题。</li></ul></li><li>原理<ul><li>history 通过 window.history.pushState / replaceState 等方式，实现路由跳转的功能。</li><li>history 通过 window.onpopstate 的方式，来监听 url 的改变，借此实现无刷新跳转的功能。</li></ul></li></ul></li></ul><ol start="3"><li>基本内容</li></ol><ul><li>提供两个组件<ul><li>router-link 用来路由跳转（声明式导航）</li><li>router-view 用来加载渲染路由组件</li></ul></li><li>提供两个属性<ul><li>$router 用来路由跳转（编程式导航）</li><li>$route 用来获取路由参数和路由路径</li></ul></li></ul><ol start="4"><li>路由跳转两种方式</li></ol><ul><li>声明式导航 router-link</li><li>编程式导航 this.$router.push/replace/go</li></ul><ol start="5"><li>路由传参</li></ol><ul><li>query</li><li>params</li><li>meta</li></ul><ol start="6"><li>路由导航守卫</li></ol><ul><li>全局路由导航守卫<ul><li>beforeEach</li><li>afterEach</li></ul></li><li>路由独享守卫</li><li>组件独享守卫</li></ul><p>最重要的是全局路由导航守卫的 beforeEach</p><p>主要用来：权限管理功能，控制用户的访问权限</p><ol start="7"><li>路由懒加载</li></ol><p>通过 import 动态加载组件，实现组件懒加载</p><p>内部做了两件事：</p><ul><li>代码分割：将路由组件单独打包成一个 js 文件</li><li>按需加载：需要使用这个路由组件时，才会加载对应的 js 文件</li></ul><h2 id="9-nextTick-方法的原理">9. nextTick 方法的原理</h2><h3 id="9-1-Vue2">9.1. Vue2</h3><ol><li>定义一个数组（callbacks）用来存储回调函数</li><li>定义一个用来遍历数组，执行回调函数的方法（flushCallbacks）</li><li>定义一个用来将执行回调函数的方法添加到异步队列去的方法（timerFunc）</li></ol><ul><li>这个方法内部会通过 4 种方式来操作：Promise、MutationObserver、setImmediate、setTimeout</li><li>会从上到下依次判断来选择，一旦选择前面的方案，后面就不看了</li></ul><ol start="4"><li><p>到此准备工作完成了，接下来组件会调用 nextTick 方法</p></li><li><p>调用 nextTick 方法时，会将回调函数添加到数组（callbacks）中，在通过 timerFunc 将执行回调函数的方法 flushCallbacks 添加到异步队列等待将来执行</p></li><li><p>等主线程执行完所有同步代码，就会执行异步代码，此时会就执行 flushCallbacks 函数</p></li><li><p>执行 flushCallbacks 函数就会遍历所有回调函数依次执行</p></li></ol><p>总结：</p><p>所以 nextTick 方法的真正理解就是将回调函数添加到异步队列中，等待将来执行。</p><p>它之所以可以等 DOM 元素渲染完成才触发回调函数，是因为我们先更新响应式数据，此时内部会将更新用户界面的方法通过 nextTick 添加到异步队列去，在调用 nextTick 方法，会将其他代码也添加到异步队列去，队列先进先出，所以先更新用户界面，在执行其他代码，此时就能操作更新后的 DOM 元素了</p><h3 id="9-2-Vue3">9.2. Vue3</h3><p>调用 nextTick 方法，如果不传入参数，就会直接返回一个成功的 promise 对象。后续代码会添加到异步队列等待将来执行。</p><p>问题：为什么 Vue3 的 nextTick 这么简单？</p><ul><li>因为 Vue2 要考虑低版本浏览器的兼容性处理，所以用了 4 种方式来将回调函数添加到异步队列。</li><li>而 Vue3 放弃了低版本浏览器的兼容，所以只需要考虑最佳方案：Promise 即可。</li></ul><h2 id="10-双向数据绑定原理">10. 双向数据绑定原理</h2><p>v-model 主要用于双向数据绑定（收集表单数据），它给元素绑定时，不同元素做法不一样：</p><ol><li>如果是文本类型元素（<input> 和 <textarea>）：绑定 value 属性和 input 事件；</li><li>如果是单选或多选元素（<input type="checkbox"> 和 <input type="radio">）：绑定 checked 属性和 change 事件；</li><li>如果是下拉列表元素（<select>）：绑定 value 属性和 change 事件；</li><li>如果不是上述这些元素（比如组件），会按照文本类型元素处理。</li></ol><ul><li>Vue3 中，给组件绑定的是 modelValue 属性和 update:modelValue 事件</li></ul><h2 id="11-响应式原理">11. 响应式原理</h2><h3 id="11-1-Vue2">11.1. Vue2</h3><ol><li>数据代理</li></ol><ul><li><p>总结：将 data/props/methods 等属性代理到 this 上，可以通过 this 直接访问数据，从而让访问数据更加方便</p></li><li><p>详情：遍历 data 所有属性，对每一个属性通过 Object.defineProperty 方法，将 data 属性定义在 vm 上，同时定义了读取数据的 get 和设置属性值的 set 方法。此时我们就能通过 <a href="http://this.xxx">this.xxx</a> 的方式访问 data 中的数据了。 get/set 实际访问/操作的都是原 data 数据</p></li></ul><ol start="2"><li>数据劫持</li></ol><ul><li><p>总结：将原 data 数据中所有属性进行重新定义，定义成响应式的属性</p></li><li><p>详情：遍历 data 所有属性，每一个属性都会创建一个 dep 对象， 然后通过 Object.defineProperty 方法进行重新定义，同时定义读取数据的 get 和设置属性值的 set 方法, 此时 dep 对象会以闭包的形式保存在 get 和 set 方法中。</p><ul><li>未来当你读取属性数据就会触发 get 方法，会返回属性的值，同时会调用 dep.depend() 方法，它用来建立响应式联系，响应式联系就是，dep 保存 watcher，watcher 保存 dep</li><li>未来当你设置属性的值就会触发 set 方法，内部会同步更新值，同时会调用 dep.notify() 方法，它用来遍历 dep 保存的所有 watcher，调用 watcher 的方法将更新用户界面的方法添加到异步队列，等待异步更新。（更新数据是同步的，更新用户界面是异步的。）</li></ul></li></ul><ol start="3"><li>页面解析渲染</li></ol><ul><li><p>总结：将模板页面内部模板语法进行解析生成虚拟 DOM 树，这个过程会建立响应式联系，遍历虚拟 DOM 树渲染成真实 DOM 元素，插入页面根标签生效，完成初始化渲染</p></li><li><p>详情：首先 new Watcher，然后内部会调用方法去进行页面初始化渲染，初始化渲染过程中就会构建虚拟 DOM 树，此时会读取表达式的值，会触发数据代理的 get，又触发数据劫持的 get，此时会通过 dep.depend() 建立响应式联系，所谓的响应式联系就是 dep 保存 watcher，watcher 保存 dep（dep 保存 watcher 的目的为了将来能通过 dep 找到 watcher 从而更新用户界面，watcher 保存 dep 为了防止重复保存），构建完虚拟 DOM 树，就会将虚拟 DOM 树解析成真实 DOM 元素，插入页面生效</p></li></ul><ol start="4"><li>更新触发响应式</li></ol><ul><li>将来当你更新 data 数据时，就会触发数据代理阶段给属性设置的 set 方法，方法内部实际更新的是原 data 数据，又会触发数据劫持阶段给属性设置的 set 方法，此时会同步更新数据的值，同时触发 dep.notify() 方法遍历 dep 保存的 watcher 将更新用户界面的方法添加到异步队列，等待异步更新（通过 nextTick 方法做得：我在官网查询 nextTick 方法的时候，发现他能等 DOM 元素渲染好在触发指定回调，我就去研究它怎么做到的，发现原来它真正原理，并没有等 DOM 元素渲染好，仅仅是将回调函数添加到异步队列而已（这里可以在展开说为什么，也可以等他来问））。</li></ul><h3 id="11-1-Vue3">11.1. Vue3</h3><ol><li>概述</li></ol><p>主要由 4 个方法构成 reactive、track、trigger、effect</p><ul><li>reactive 用来将数据定义成响应式</li><li>track 用来进行依赖收集：建立响应式数据和 effect 实例之间的联系</li><li>trigger 用来触发依赖更新：找到响应式数据对应的 effect 实例，去更新用户界面</li><li>effect 用来存储更新用户界面的方法</li></ul><ol start="2"><li><p>当你定义 reactive 数据时，内部通过 Proxy 方法对数据进行代理，当你读取属性的时候会触发 get，设置属性的值的时候会触发 set，get 方法中会返回属性的值，同时通过 track 进行依赖收集，set 方法中会更新属性的值，同时会通过 trigger 触发依赖更新</p></li><li><p>默认 effect 方法一上来就会执行一遍，此时会生成 effect 实例，将更新用户界面的方法存储在 effect 实例, 并调用更新用户界面的方法来完成页面初始化渲染</p></li><li><p>初始化渲染时会读取表达式的值，触发 Proxy 设置的 get，此时会通过 track 进行依赖收集：依赖收集会创建一个 weakMap 容器，存储的 key 为响应式对象，值为 Map 容器，Map 容器 存储的 key 为响应式对象中某个属性，值为 Set 容器，Set 容器会存储对应的 effect 实例。到此依赖收集完成，初始化渲染后续也会完成</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="comment">// WeakMap容器 key是响应式数据 value是一个Map容器</span></span><br><span class="line">  &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;: &#123; <span class="comment">// Map容器 key是响应式数据中某个属性 value是Set容器</span></span><br><span class="line">    <span class="attr">age</span>: [ <span class="comment">// Set容器保存effect实例</span></span><br><span class="line">      effect1, effect2, ...</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>将来更新响应式数据时，数据的值会同步更新，同时会触发 Proxy 设置的 set，此时会通过 trigger 触发依赖更新: 依赖更新会通过 weakMap 容器找到响应式数据对应的 Map 容器，通过 Map 容器找到对应属性的 Set 容器，遍历 Set 容器中 effect 实例调用更新用户界面的方法，从而更新用户界面达到响应式</li></ol><h2 id="12-Vue2-中虚拟-DOM-Diff-算法">12. Vue2 中虚拟 DOM Diff 算法</h2><ol><li>Diff 算法简述</li></ol><p>初始化渲染阶段会生成一个虚拟 DOM 树（旧树），更新数据时会生成一个新的虚拟 DOM 树，新旧虚拟 DOM 树进行比较，找到不同的内容，从而更新，这就是虚拟 DOM Diff 算法做的事情</p><ol start="2"><li>虚拟 DOM 树简述</li></ol><p>虚拟 DOM 树就是一个对象，这个对象通过特定属性代表真实 DOM 元素的信息，比如：tag 代表元素标签，data 代表元素属性，children 代表子元素</p><ol start="3"><li>Diff 算法详细流程</li></ol><p>Diff 算法一共会经历三个函数：patch、patchVnode、updateChildren</p><p>其中最重要的是 updateChildren 方法：</p><p>它是对相同层级的所有子节点进行 diff（比较），整体流程是从两端到中间遍历，一个一个元素进行比较，从而更新。</p><p>具体来说：</p><ul><li><p>定义 4 个指针，分别指向旧的虚拟 DOM 树开头，也叫做旧前，指向旧的虚拟 DOM 树结尾，叫做旧后，新的虚拟 DOM 树开头，叫做新前，新的虚拟 DOM 树结尾，叫做新后</p></li><li><p>整个遍历过程（详细版本）：</p><ul><li>判断旧前元素是否存在，不存在就更新下标（旧前++），存在就下一步</li><li>判断旧后元素是否存在，不存在就更新下标（旧后–）存在就下一步</li><li>判断旧前和新前元素是否一致（sameVnode：看 key 和 tag），如果一致就会进一步比较（patchVnode），（新前旧前）下标++，不一致就下一步</li><li>判断旧后和新后元素是否一致（sameVnode：看 key 和 tag），如果一致就会进一步比较（patchVnode），（新后旧后）下标–，不一致就下一步</li><li>判断旧前和新后元素是否一致（sameVnode：看 key 和 tag），如果一致就会进一步比较（patchVnode），更新下标（新后–旧前++），移动 DOM 元素位置（将旧前插入到旧后的后面），不一致就下一步</li><li>判断旧后和新前元素是否一致（sameVnode：看 key 和 tag），如果一致就会进一步比较（patchVnode），更新下标（旧后–新前++），移动 DOM 元素位置（将旧后插入到旧前的前面），不一致就下一步</li><li>看 key，提取旧树剩下的子元素的 key 属性，判断新前节点的 key 在不在旧树 key 中，存在就移动 DOM 元素位置，不存在创建新前元素插入页面，更新下标（新前++）</li></ul></li><li><p>整个遍历过程（简化版本）：</p><ul><li>旧前新前</li><li>旧后新后</li><li>旧前新后</li><li>旧后新前</li><li>看 key</li><li>其中 旧前新后 旧后新前 看 key 更新 DOM 元素后，还需要移动 DOM 元素位置</li></ul></li></ul><p>到此更新基本完成。（后面还有两个流程，也可以说）</p><h2 id="13-keep-alive-原理">13. keep-alive 原理</h2><h1>Mobile</h1><h2 id="1-移动端适配方案">1. 移动端适配方案</h2><ol><li>rem</li></ol><p>原理：</p><ul><li>rem 单位是相对长度单位，是相对 html 标签字体大小的。</li><li>我们通过动态更新 html 标签字体大小，就能控制 rem 的大小，从而实现适配</li></ul><p>具体做法</p><ul><li>准备 js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> docEl = <span class="variable language_">document</span>.<span class="property">documentElement</span>;</span><br><span class="line"><span class="comment">// 设置 1rem = 屏幕宽度 / 100</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setRemUnit</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> rem = docEl.<span class="property">clientWidth</span> / <span class="number">100</span>;</span><br><span class="line">  docEl.<span class="property">style</span>.<span class="property">fontSize</span> = rem + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setRemUnit</span>();</span><br><span class="line"><span class="comment">// 当浏览器大小调整时，重新更新字体大小</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, setRemUnit);</span><br></pre></td></tr></table></figure><ul><li>配置插件：postcss-pxtorem，能够自动将 px 转 rem 单位</li></ul><ol start="2"><li>viewport</li></ol><p>原理：</p><ul><li>vw/vh 也是相对长度单位，相对于整个浏览器视口的宽度和高度</li><li>1vw 等于屏幕宽度的 1%</li></ul><p>具体做法：</p><ul><li>设置 meta 标签</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置插件 postcss-px-to-viewport，能够自动将 px 转 vw 单位</li></ul><h2 id="2-1-物理像素边框方案">2. 1 物理像素边框方案</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border-b</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.border-b</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="selector-class">.border-b</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="selector-class">.border-b</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.33333</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="selector-class">.border-b</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.25</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-小程序的生命周期函数">3. 小程序的生命周期函数</h2><ol><li>应用生命周期</li></ol><ul><li>onLaunch: 用于登录</li><li>onShow</li><li>onHide</li></ul><ol start="2"><li>页面生命周期</li></ol><ul><li>onLoad</li><li>onShow</li><li>onReady</li><li>onHide</li><li>onUnload：做收尾工作，清除定时器等任务，防止内存泄漏</li></ul><p>如果需要发送请求，需要分析需求，看当前页面的数据是否要实时更新：</p><ul><li>需要实时更新：onShow</li><li>不需要实时更新，一次就好：onLoad</li></ul><ol start="3"><li>组件生命周期</li></ol><ul><li><p>组件自身生命周期函数</p><ul><li>created</li></ul></li><li><p>组件所在页面的生命周期函数</p><ul><li>show</li><li>hide</li></ul></li></ul><h2 id="4-小程序的分包">4. 小程序的分包</h2><ol><li>分包目的</li></ol><ul><li>小程序体积能更大能写更多功能</li><li>优化小程序首次启动的下载时间</li></ul><ol start="2"><li>分类</li></ol><p>主包和分包</p><p>分包又分为：普通分包和独立分包</p><ol start="3"><li>普通分包和独立分包区别</li></ol><ul><li><p>普通分包可以使用自己和主包的内容</p></li><li><p>独立分包只能使用自己的内容（除了插件等以外）</p></li></ul><ol start="4"><li>分包大小限制</li></ol><ul><li><p>整个小程序所有分包大小不超过 20M</p></li><li><p>单个分包/主包大小不能超过 2M</p></li></ul><ol start="5"><li>分包具体配置</li></ol><p>需要将分包的页面和其他资源放入一个单独的文件夹中，再在 app.json 中配置 subpackages</p><p>独立分包需要配置中加上 independent</p><ol start="6"><li>分包预下载</li></ol><p>有时候我们加载分包速度比较慢，可以提前加载分包</p><p>需要在 app.json 配置 preloadRule 就可以</p><h2 id="5-微信小程序组件间通信">5. 微信小程序组件间通信</h2><ol><li>页面与组件之间的通信</li></ol><ul><li>properties 父 -&gt; 子</li><li>自定义事件 子 -&gt; 父<ul><li>通过 bind:xxx 绑定事件</li><li>通过 this.triggerEvent 触发事件</li></ul></li></ul><ol start="2"><li>全局通信方案</li></ol><ul><li><p>globalData</p><ul><li>在 app.js 中定义 globalData</li><li>其他页面/组件通过 getApp() 得到 app 实例对象，进而操作数据</li></ul></li><li><p>storage</p><ul><li>wx.getStorageSync() 获取</li><li>wx.setStorageSync() 设置</li></ul></li></ul><p>通常情况下不建议直接用 storage 通信，性能较差。storage 主要用于持久化存储数据，如果要频繁通信，可以在 app.globalData 中存储一份使用</p><ul><li>事件总线<ul><li>pubsub-js</li></ul></li></ul><ol start="3"><li>页面之间通信</li></ol><ul><li><p>query</p><ul><li>跳转路由携带 query 参数</li><li>下个页面通过 onLoad 生命周期函数的参数接受使用</li></ul></li><li><p>getCurrentPages()</p><ul><li>可以获取路由历史记录，从而得到上个页面的实例对象进而操作数据</li></ul></li></ul><h2 id="6-微信小程序登录流程">6. 微信小程序登录流程</h2><ol><li>需求：用户无需登录，可以访问部分页面。需要用户手动点击授权登录进行登录</li></ol><ul><li><p>点击授权登录，通过 wx.login 得到 code</p></li><li><p>将 code 发送请求给服务器得到用户的 token</p></li><li><p>将 token 存储起来（globalData 和 storage）</p><ul><li>storage 为了持久化存储</li><li>globalData 读写速度更快，性能更好</li></ul></li><li><p>在封装请求函数中在请求头携带 token 参数</p></li><li><p>发送请求获取用户数据，将用户数据存储起来（globalData 和 storage）</p></li><li><p>跳转回之前页面</p></li><li><p>默认会返回默认头像和用户名，可以通过微信提供最新填写能力，引导用户设置用户头像和用户名</p></li></ul><ol start="2"><li>需求：用户必须登录才能使用小程序，一上来就需要进行登录</li></ol><ul><li>用户无需点击，在 app.js 中 onLaunch 生命周期函数就进行登录操作</li><li>wx.login - 发送请求携带 code - 得到 token 并存储 - 发送请求携带 …</li></ul><h2 id="7-微信小程序支付流程">7. 微信小程序支付流程</h2><ol><li>用户可以从两个地方来到订单支付页面</li></ol><ul><li><p>商品详情 - 点击立即购买</p></li><li><p>购物车 - 点击提交订单</p></li><li><p>商品详情点击立即购买就打算要买这个商品，将商品 id 以 query 参数传递给订单支付页面，在跳转过去</p></li><li><p>购物车点击提交订单直接跳转订单支付页面</p></li></ul><ol start="2"><li>订单支付页面需要展示商品信息和收件人信息</li></ol><ul><li><p>商品信息，可以通过判断是否有 query 参数来识别是哪种渠道进入的</p><ul><li>如果是有商品 id，说明是商品详情进入，通过商品 id 发送请求获取商品数据展示</li><li>如果没有商品 id，说明是购物车进入的，直接发送请求获取购物车已选择商品列表展示</li></ul></li><li><p>收件人信息，直接发送请求获取默认收件人展示即可。同时提供方式跳转页面可以对收件人信息 CRUD</p></li></ul><ol start="3"><li>当用户确认并填写好信息后，点击结算开始支付</li></ol><ul><li>首先将收件人、商品详情等信息发送请求给服务器获取 orderId</li><li>通过 orderId 发送请求获取微信支付需要的参数：（timeStamp 时间戳、paySign 签名、signType 签名算法 nonceStr 随机字符串等）</li><li>将微信支付需要的参数通过 wx.requestPayment(微信支付接口)来发起支付</li><li>支付成功进行提示，跳转到支付成功页面</li></ul><h2 id="8-小程序上线流程">8. 小程序上线流程</h2><ol><li>将写好的代码上传到微信</li></ol><p>微信开发者工具 - 右上角 - 上传</p><ol start="2"><li><p>来到微信小程序管理平台，填写小程序的信息和条目等内容</p></li><li><p>来到 管理 - 版本管理 - 提交审核</p></li><li><p>此时微信小程序官方会审核你提交的小程序代码，审核通过小程序就上线了</p></li></ol><h2 id="9-小程序代码上线后修改代码，如何让用户看到最新效果">9. 小程序代码上线后修改代码，如何让用户看到最新效果</h2><p>在 app.js 中 onLaunch 中通过 UpdateManager 实例来监听小程序新版本下载完成事件，调用实例的 applyUpdate 方法就能应用新版本并重启了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkUpdateVersion</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 判断小程序版本是否可以使用小程序更新机制API</span></span><br><span class="line">  <span class="keyword">if</span> (wx.<span class="title function_">canIUse</span>(<span class="string">&quot;getUpdateManager&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 2. 创建 UpdateManager 实例</span></span><br><span class="line">    <span class="keyword">const</span> updateManager = wx.<span class="title function_">getUpdateManager</span>();</span><br><span class="line">    <span class="comment">// 3. 监听检测版本更新事件</span></span><br><span class="line">    updateManager.<span class="title function_">onCheckForUpdate</span>(<span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">      <span class="comment">// 4. 如果有新的版本，小程序会自动在后台下载新版本，开发者无需设置</span></span><br><span class="line">      <span class="keyword">if</span> (res.<span class="property">hasUpdate</span>) &#123;</span><br><span class="line">        <span class="comment">// 5. 监听小程序新版本下载完成事件</span></span><br><span class="line">        updateManager.<span class="title function_">onUpdateReady</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="comment">// 6. 调用方法应用新版本并重启</span></span><br><span class="line">          updateManager.<span class="title function_">applyUpdate</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 7. 监听小程序新版本下载失败事件</span></span><br><span class="line">        updateManager.<span class="title function_">onUpdateFailed</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          wx.<span class="title function_">showModal</span>(&#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&quot;已经有新版本喽~&quot;</span>,</span><br><span class="line">            <span class="attr">content</span>:</span><br><span class="line">              <span class="string">&quot;请您删除当前小程序，到微信 “发现-小程序” 页，重新搜索打开哦~&quot;</span>,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    wx.<span class="title function_">showModal</span>(&#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&quot;溫馨提示&quot;</span>,</span><br><span class="line">      <span class="attr">content</span>: <span class="string">&quot;当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-原生小程序和-uni-app-的区别">10. 原生小程序和 uni-app 的区别</h2><ol><li>uni-app 开发一套代码，能运行多个平台。原生小程序只能在微信小程序中运行</li><li>uni-app 是使用 Vue 框架语法进行开发。原生小程序使用 WXML 语法进行开发</li><li>uni-app 生命周期支持 Vue 的生命周期，原生小程序只能使用 onLoad、onShow 等</li><li>uni-app 全局对象是 uni，能兼容多个平台，原生小程序全局对象是 wx</li></ol><h2 id="11-uni-app-的生命周期">11. uni-app 的生命周期</h2><p>生命周期和微信小程序类似，但是支持 Vue 的生命周期</p><h2 id="12-uni-app-怎么打包成-apk（打包-App-流程）">12. uni-app 怎么打包成 apk（打包 App 流程）</h2><ol><li>来到 manifest.json 文件配置 app 的图标、启动页、appid、使用权限等</li><li>使用 HbuilderX - 发行 - 云打包开始打包</li><li>打包需要填写应用名称和证书等内容，点击打包即可</li><li>云打包后会提供下载地址，下载打包好的 app</li><li>也可以本地打包</li></ol><h2 id="13-开发-uni-app-项目，使用过哪些插件库">13. 开发 uni-app 项目，使用过哪些插件库</h2><ol><li><p>UI 组件库：uView-ui</p></li><li><p>其他内容可看插件市场：<a href="https://ext.dcloud.net.cn/">https://ext.dcloud.net.cn/</a></p></li></ol><h1>Project</h1><h2 id="1-项目开发过哪些功能模块">1. 项目开发过哪些功能模块</h2><p>6-7 个模块以上</p><h2 id="2-项目难点">2. 项目难点</h2><h3 id="2-1-axios-二次封装">2.1. axios 二次封装</h3><ol><li>基本功能</li></ol><p><strong>说法一：</strong></p><ul><li>携带统一的请求前缀</li></ul><p>通过 baseURL 指定，它的值通常从.env 环境变量文件中获取</p><ul><li>携带公共请求参数：token</li></ul><p>在设置请求拦截器中携带公共参数</p><ul><li>成功返回成功的数据，失败返回失败的原因</li></ul><p>在响应拦截器成功回调中，还需要进一步判断返回值中的 code，来判断是否功能成功</p><p>成功返回成功的数据（外面使用更简单），失败做出对应的错误提示（不同的 code 错误提示不一样的）</p><ul><li>响应拦截器失败回调错误提示</li></ul><p>通过判断响应状态吗和响应 message 信息来做出相应的错误提示</p><p>例如：404 资源找不到等</p><p><strong>说法二：</strong></p><p>首先通过 axios.create 来生成 axios 实例，这个时候可以定义 baseUrl 来指定公共请求前缀，它的值通常从.env 环境变量文件中获取</p><p>接下来可以定义 axios 的请求拦截器和响应拦截器，它们分别是发送请求前和得到响应后触发的回调函数</p><p>在请求拦截器中我们添加公共请求参数 token</p><p>在响应拦截器成功回调中，还需要进一步判断返回值中的 code，来判断是否功能成功</p><p>成功返回成功的数据（外面使用更简单），失败做出对应的错误提示（不同的 code 错误提示不一样的）</p><p>在响应拦截器失败回调中进行更加详细的错误提示，通过判断响应状态吗和响应 message 信息来做出相应的错误提示</p><p>例如：404 资源找不到等</p><ol start="2"><li>取消重复请求</li></ol><ul><li>给每个请求生成一个 key（相同请求生成的 key 相同，不同请求升成的 key 不相同）</li></ul><p>key 由 url、method、params 和 data 拼接组成</p><ul><li>给每个请求生成一个取消请求的方法 cancel</li></ul><p>给每个请求 config 添加 cancelToken，值 new axios.CancelToken 产生，此时在回调函数中可以得到取消当前请求的 cancel 方法。</p><ul><li><p>使用 map 容器将 key 和 cancel 存储起来（使用对象也可以的）</p></li><li><p>发送请求的请求拦截器中，先判断当前请求的 key 是否存在 map 容器中，存在就调用 cancel 方法取消请求，同时删除这个数据，不存在就将当前请求的 key 的 cancel 存储起来</p></li><li><p>完成请求的响应拦截器中，将当前请求的 key 和 cancel 给删除掉</p></li></ul><ol start="3"><li>取消上一个页面的请求</li></ol><ul><li>在存储 key 和 cancel 时，还存储当前请求对应页面的路由路径（可以通过 window.location.pathname 获取）</li><li>在路由前置守卫中，遍历 map 容器，取出每一个请求，判断请求对应页面的路径和当前 to.path 是否相同，不相同说明是之前页面的请求，调用 cancel 方法取消掉即可</li></ul><h3 id="2-2-echarts-大屏适配-大数据渲染问题-实时数据通信">2.2 echarts 大屏适配/大数据渲染问题/实时数据通信</h3><h4 id="1-echarts-基本理解">1. echarts 基本理解</h4><p>echarts 用来数据可视化，将数据以图形图表的方式展示</p><p>它默认有两种渲染方式：canvas 和 svg 形式，一般用 canvas 渲染</p><p>它主要是通过配置去渲染图表，它的配置有：</p><ul><li>title 标题</li><li>xAxis x 轴</li><li>yAxis y 轴</li><li>series 类型：指定图表类型、图表数据、图表样式</li><li>legend 图例：切换显示图表</li><li>grid 布局</li><li>tooltip 提示框</li><li>dataZoom 数据缩放：只查看一定范围内的数据</li><li>geo 地理坐标系，可以绘制地图</li></ul><h4 id="2-echarts-大屏适配">2. echarts 大屏适配</h4><p>有 rem、viewport、scale 等方案，其中 rem 和 viewport 方案对图表中的字体大小等调整不友好，需要手动处理，比较麻烦，所以项目中我采用了 scale 的方案</p><p>scale 方案通过比较屏幕和设计稿宽高比来对页面进行缩放，缩放过程保持页面整体宽高比不变。</p><ol><li>计算设计稿的宽高比和当前页面的宽高比</li><li>判断当前页面的宽高比是否大于设计稿的宽高比，如果大于说明当前屏幕宽度更宽，高度更小，此时需要拿取高度来进行缩放</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缩放的值等于屏幕高度/设计稿高度</span></span><br><span class="line">scale.<span class="property">value</span> = clientHeight / draftHeight;</span><br></pre></td></tr></table></figure><ol start="3"><li>判断当前页面的宽高比是否小于设计稿的宽高比，如果小于说明当前屏幕宽度更窄，高度更大，此时需要拿取宽度来进行缩放</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缩放的值等于屏幕宽度/设计稿宽度</span></span><br><span class="line">scale.<span class="property">value</span> = clientWidth / draftWidth;</span><br></pre></td></tr></table></figure><ol start="4"><li>onMounted 绑定窗口 resize 事件，当窗口大小调整时，重新设置 scale 即可，为了防止内存泄漏，onBeforeUnmount 时解绑事件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scale = <span class="title function_">ref</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大屏适配</span></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resize</span>();</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, resize);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">onBeforeUnmount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;resize&quot;</span>, resize);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">resize</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 设计稿的宽高</span></span><br><span class="line">  <span class="keyword">const</span> draftWidth = <span class="number">1366</span>;</span><br><span class="line">  <span class="keyword">const</span> draftHeight = <span class="number">617</span>;</span><br><span class="line">  <span class="comment">// 整个屏幕的宽高</span></span><br><span class="line">  <span class="keyword">const</span> clientWidth = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span><br><span class="line">  <span class="keyword">const</span> clientHeight = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当屏幕的比例（16 / 7）大于设计稿的比例（16 / 9）,说明屏幕更宽</span></span><br><span class="line">  <span class="keyword">if</span> (clientWidth / clientHeight &gt; draftWidth / draftHeight) &#123;</span><br><span class="line">    scale.<span class="property">value</span> = clientHeight / draftHeight;</span><br><span class="line">    <span class="comment">// 当屏幕的比例（16 / 7）小于设计稿的比例（16 / 9）,说明屏幕更窄</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clientWidth / clientHeight &lt; draftWidth / draftHeight) &#123;</span><br><span class="line">    scale.<span class="property">value</span> = clientWidth / draftWidth;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    scale.<span class="property">value</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-echarts-数据实时通信">3. echarts 数据实时通信</h4><p>echarts 数据实时通信和 echarts 没啥关系，主要使用 web socket 技术进行实时通信的</p><p>WebSocket 是一个全双工通讯协议。</p><p>特点：服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。</p><p>使用：</p><p>new WebSocket(url) 传入 url 就可以连接上 WebSocket 服务器了</p><p>通过 message：接受服务器发送的消息</p><p>通过 send 方法：可以给服务器发送消息</p><p>除此以外还有其他方法：close 关闭连接</p><p>其他事件：open：打开事件 error 错误事件 close 关闭事件</p><p>功能：WebSocket 连接时可能因为不好的网络环境会断开链接，此时可以使用心跳检测机制来进行断开重连</p><p>心跳检测:</p><p>web socket 在连接过程中可能会因为网络问题断开连接，我们需要重连，这里用到心跳检测机制</p><p>具体来说：</p><ol><li>检测是否断开链接：</li></ol><p>当我们连接上 ws 服务时，需要开启定时器，隔一段时间（10s - 30s）向 ws 服务器发送一个特殊信号（ping），同时开启定时器（2s）检测服务器是否有回应信号（pong）</p><p>如果在规定时间内有回应，继续此操作，如果没有回应，说明断开连接了，我们要开始重连 ws</p><ol start="2"><li>重连机制</li></ol><p>每隔一段时间发起 ws 的重连，同时重连次数增加，一旦重新连接成功，就归零重连次数，方便下次重连，如果重连次数超过最大次数，就要提示错误，不在尝试了</p><h4 id="4-echarts-大数据渲染">4. echarts 大数据渲染</h4><p>有三种方案：</p><ol><li>降采样策略</li></ol><p>不会渲染全部数据，按照某种算法只加载部分数据，但是保留整体图形相似的形状。</p><p>具体配置：大部分图表都有一个配置项 sampling，配置它就可以达到了</p><ol start="2"><li>添加 dataZoom 组件</li></ol><p>设置渲染数据范围：startValue 和 endValue，这么做的目的就是一次性渲染一部分数据，速度更快</p><ol start="3"><li>appendData</li></ol><p>能支持大数据量（百万以上）的渲染场景，可以对数据进行分片加载数据和增量渲染。</p><p>但是只能部分图表才能使用，具体用法一般会参考文档使用。</p><h3 id="2-3-后台实现权限管理功能">2.3. 后台实现权限管理功能</h3><ol><li>搭建三个页面来管理权限功能：用户管理、角色管理、菜单管理</li></ol><ul><li>菜单管理：需要填写路由名称、路由组件地址、菜单图标、按钮权限值等内容</li><li>角色管理：管理角色对应访问菜单的权限</li><li>用户管理：管理用来登录的账户，同时会分配角色（一旦分配该用户就有角色对应的访问权限了）</li></ul><ol start="2"><li>登录</li></ol><p>当用户进行登录时，就能得到 token，我们将 token 存储起来（pinia/vuex 和 localStorage）</p><p>使用：在 axios 请求拦截器中携带 token 参数</p><ol start="3"><li>路由全局前置导航守卫</li></ol><p>登录成功，会进行路由跳转。或者用户第一次访问，都会触发路由全局前置导航守卫</p><p>此时会判断是否有 token，没有 token 说明没有登录，只能访问登录页面</p><p>有 token 说明登录了，需要进一步判断是否有用户数据，如果有，直接访问页面</p><p>如果没有用户数据，需要发送请求获取用户数据</p><ol start="4"><li>获取用户数据</li></ol><p>获取用户数据可以得到用户基本信息、用户的菜单权限列表和用户按钮权限列表</p><p>用户的菜单权限列表：就是服务器返回的用户拥有访问权限的路由表</p><p>用户按钮权限列表：就是用户拥有页面上某个按钮的权限表</p><ol start="5"><li>路由权限控制</li></ol><p>一开始路由表分成两部分：静态路由表和任意路由表</p><p>静态路由表：登录、404 等页面</p><p>任意路由表：匹配任意地址，跳转 404</p><p>一上来只加载静态路由表，所以可以访问登录页面</p><p>当用户数据加载完成时，我们会遍历用户的菜单权限列表，将内部 component 通过路由懒加载形式替换成路由组件，然后在遍历通过 router.addRoute 方法将配置追加到路由中，此时我们就能访问这些路由了（最后会追加任意路由表）</p><ol start="6"><li>按钮权限控制</li></ol><p>通过指令方式实现的：自定义全局指令 v-permission</p><p>内部会判断某个按钮传入的权限值在不在用户按钮权限列表中，如果在啥也不处理，不在就删除当前元素</p><p>让用户无法访问，从而实现按钮权限控制</p><h3 id="2-4-其他">2.4 其他</h3><p>也能说项目优化和组件封装</p><h2 id="3-项目优化">3. 项目优化</h2><ol><li>样式方面</li></ol><ul><li>定义公共样式，混合，全局变量复用</li></ul><ol start="2"><li>js 方面</li></ol><ul><li>v-if 和 v-show，频繁用 v-show，不频繁用 v-if</li><li>页面比较长的表达式，或者使用了多次表达式，用 computed 缓存</li><li>vue 中遇到大量数据可以使用 Object.freeze 冻结数据（这样能让内部数据不被数据劫持，不会生产 dep 对象等，节省内存提升性能）</li><li>vue 中遇到不涉及用户界面更新的数据不定义成响应式（这个数据也不会被数据劫持，比如定时器的返回值）</li><li>使用 keep-alive 缓存路由组件，切换性能更好，但是要注意数据是否需要及时更新（activated 生命周期）</li><li>v-for 遍历 key 属性尽量唯一且稳定（这里可以聊一下 diff 算法），且在 vue2 中避免同时使用 v-if，vue3 中可以。</li><li>echarts 大量数据渲染优化（…），普通大数据渲染：分页 或 虚拟长列表优化（商品数据展示）</li><li>图片懒加载</li><li>路由懒加载</li><li>第三方插件的按需引入（element-ui、echarts 按需加载配置）</li><li>高频触发的事件使用防抖、节流（购物车商品数量操作）</li><li>大量的事件使用事件委托优化（三级分类导航）</li><li>封装函数、封装组件复用（EchartsCard、Card 等）</li></ul><ol start="3"><li>打包工具层面的优化</li></ol><p>vue2 项目：通过配置 webpack splitChunk 代码分割，从而将 element-ui、echarts、vue 等库进行单独打包，就能并行加载速度更快</p><ol start="4"><li>网络层面的优化</li></ol><ul><li>开启 gzip 压缩</li><li>浏览器缓存（强缓存和协商缓存）</li><li>CDN 的使用（要结合 webpack 配置一起使用）</li><li>升级 http 协议为 2.0</li></ul><h2 id="4-项目组件封装">4. 项目组件封装</h2><h3 id="1-大文件上传">1. 大文件上传</h3><p>需求: 项目中有超过几百 mb 的文件需要上传，原来 el-upload 是整体上传比较慢，同时网络一旦不稳定，需要重新上传，不太好，所以重新封装 el-upload 组件，实现大文件上传</p><ol><li>切片上传</li></ol><ul><li>通过 el-upload 组件定义 http-request 方法来自定义上传，在回调函数中可以得到上传文件</li><li>将上传文件按照预先定义好单个切片大小（比如 10mb），通过文件的 slice 方法，将大文件截取成一个个小文件，添加到数组中，实现切片</li><li>设置文件名称和代表顺序的下标，通过 formData 方式并行上传到服务器</li><li>再通过 Promise.all 方法等所有切片上传好，在发送一个请求通知服务器所有切片上传完成，请求合并文件，服务器返回大文件在线访问地址</li></ul><ol start="2"><li>进度条</li></ol><ul><li><p>el-upload 组件 file-list 文件列表中每个文件都有一个 status 和 percentage 属性</p><ul><li>status 代表上传的状态：uploading 代表上传中，此时会显示上传进度条，success 代表上传成功，显示成功的图标</li><li>percentage 显示上传的进度</li></ul></li><li><p>上传切片之前初始化 file 的 status 为 uploading，此时会显示上传进度条，percentage 为 0，同时定义一个用来存储已经上传文件大小的属性（loaded）</p></li><li><p>在上传切片请求方法中添加 onProgress 回调，它会在上传文件时触发，此时就能得到已经上传的文件大小，将<code>已经上传的文件大小累加 / 文件总大小 * 100</code> 就能得到上传的进度 percentage</p></li><li><p>判断<code>percentage=100</code>时，将 status 调成 success，上传成功</p></li></ul><ol start="3"><li>创建 hash</li></ol><p>要想实现断点续传，需要服务器记录已经上传的切片内容，并且要保证如果多个用户上传文件名一样的话，文件不能冲突</p><p>所以我们根据文件内容生成 hash 值（相同文件生成 hash 值一样，不同文件生成 hash 值不一样），将 hash 值作为切片名称，这样就不会受文件名影响了</p><p>因为上传文件非常大，计算 hash 值需要比较长的时间，这里我使用 web worker 进行优化，将根据文件内容计算 hash 值的任务交给分线程完成，这样主线程还可以干其他事情</p><ol start="4"><li>断点续传</li></ol><ul><li>在上传切片之前，需要先发送请求给服务器获取当前 hash 对应文件已经上传的切片</li><li>服务器会返回值，值有一个数组，内部包含已经上传的切片名称</li><li>我们上传切片之前，对所有切片进行过滤，判断当前切片是否已经上传过，上传过就过滤，没有上传过就保留，这样就能实现断点续传了（此时 loaded 值初始化就不能为 0 了，而是<code>已经上传的切片数量 * 10mb</code>）</li></ul><ol start="5"><li>秒传</li></ol><ul><li>在上传切片之前，需要先发送请求给服务器获取当前 hash 对应文件已经上传的切片</li><li>如果文件全部上传过，会返回一个标识和文件在线访问地址 url，我们判断标识如果满足条件，就直接使用 url 就好</li><li>不满足条件继续走断点续传逻辑</li></ul><h3 id="2-配置化表单-动态化表单">2. 配置化表单/动态化表单</h3><p>需求: 后台管理项目有大量的表单需要开发，传统一个个开发效率太低，重复度高，所以封装了一个 Schema Form 组件来配置化表单</p><ol><li>给组件传递 schema、rules、model 等属性</li></ol><ul><li><p>schema：是一个数组内部是对象，包含：</p><ul><li>component 代表要渲染的组件</li><li>label 左侧文字</li><li>props 渲染组件的 props 数据</li><li>model 要收集的数据名称，也是表单校验规则名称</li><li>key 遍历的 key 属性</li><li>span 栅格布局占份数</li><li>下拉列表 selectOptions、单选 radioOptions 等</li></ul></li><li><p>rules：表单校验规则</p></li><li><p>model：表单的数据</p></li></ul><ol start="2"><li>组件内部会根据 schema 的值来动态渲染表单（可以说说具体做法）</li></ol><h1>Other</h1><h2 id="1-你的期望薪资多少">1. 你的期望薪资多少</h2><h2 id="2-你为什么从上家公司离职">2. 你为什么从上家公司离职</h2><h2 id="3-上家公司有多少人？前端多少？">3. 上家公司有多少人？前端多少？</h2><h2 id="4-公司开发项目流程">4. 公司开发项目流程</h2><h2 id="5-如果你的上级将一些不是你的任务交给你，你怎么办？">5. 如果你的上级将一些不是你的任务交给你，你怎么办？</h2><h2 id="6-怎么与后端协商？怎么与其他同事交流？">6. 怎么与后端协商？怎么与其他同事交流？</h2>]]></content>
    
    
    <summary type="html">🌭本文汇总面试题，可作为文档进行查询</summary>
    
    
    
    <category term="面试题" scheme="https://www.cameliia.top/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面试题" scheme="https://www.cameliia.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
